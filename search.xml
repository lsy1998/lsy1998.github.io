<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基础操作</title>
    <url>/2023/06/24/ESlint/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g eslint</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ESlint</category>
      </categories>
  </entry>
  <entry>
    <title>Home</title>
    <url>/2023/06/24/Home/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快去-Git-Pull-一下"><a href="#快去-Git-Pull-一下" class="headerlink" title="快去 Git Pull  一下"></a>快去 <mark style="background: #FF5582A6;">Git Pull </mark> 一下</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var i = [dv.pages().length,dv.pages().length,dv.pages().length,</span><br><span class="line">         dv.pages().file.etags.distinct().length]</span><br><span class="line">dv.paragraph(`总共有 **$&#123;i[0]&#125;** 个文件`)</span><br><span class="line">dv.paragraph(`==标签== **$&#123;i[3]&#125;**个`)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var y = &quot;2023&quot;</span><br><span class="line">var m = Array(12).fill(0).map(function(v,i)&#123;return i&#125;);</span><br><span class="line">var d = [31,29,31,30,31,30,31,31,30,31,30,31]</span><br><span class="line"></span><br><span class="line">for(let i of m)</span><br><span class="line">&#123;</span><br><span class="line">    var n = Array(d[i]).fill(0).map(function(v,i)&#123;return i+1&#125;);</span><br><span class="line">    var data = Array(d[i]).fill(0);</span><br><span class="line"></span><br><span class="line">    for(let j of dv.pages().filter(p=&gt;String(p.file.cday).split(&quot;-&quot;)[0]==y &amp;&amp; String(p.file.cday).split(&quot;-&quot;)[1]==i+1).groupBy(p=&gt;String(p.file.cday).split(&quot;-&quot;)[2].slice(0,2)))</span><br><span class="line">         data[j.key-1] = dv.pages().filter(p=&gt;String(p.file.cday).split(&quot;-&quot;)[2].slice(0,2)==j.key).length;</span><br><span class="line"></span><br><span class="line">    if(data.every(p=&gt;p==0))</span><br><span class="line">        continue</span><br><span class="line">    dv.header(4, i+1+&quot;月&quot;);</span><br><span class="line">    dv.paragraph(`\`\`\`chart</span><br><span class="line">type: line</span><br><span class="line">labels: [$&#123;n&#125;]</span><br><span class="line">series:</span><br><span class="line">- title: 笔记数量</span><br><span class="line">  data: [$&#123;data&#125;]</span><br><span class="line">labelColors: true</span><br><span class="line">\`\`\``)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Home</category>
      </categories>
  </entry>
  <entry>
    <title>生词本</title>
    <url>/2023/07/12/English/%E7%94%9F%E8%AF%8D%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><input disabled="" type="checkbox"> make use of 利用</li>
<li><input disabled="" type="checkbox"> changes over time 随着时间改变</li>
<li><input disabled="" type="checkbox"> prefix it with 以…开头</li>
<li><input disabled="" type="checkbox"> take the opportunity to 抓住机会，借此机会</li>
<li><input disabled="" type="checkbox"> dive right in 立即投入、立即开始做某事</li>
<li><input disabled="" type="checkbox"> to do so 去做、就这么</li>
<li><input disabled="" type="checkbox"> more on this later 稍后详述</li>
<li><input disabled="" type="checkbox"> to recap 回顾</li>
<li><input disabled="" type="checkbox"> get a sense of 了解、感受</li>
<li><input disabled="" type="checkbox"> a taste of 尝试、一点点</li>
<li><input disabled="" type="checkbox"> aim to 目标是… 旨在</li>
<li><input disabled="" type="checkbox"> for instance 例如</li>
<li><input disabled="" type="checkbox"> turn … into … 使…变成…</li>
<li><input disabled="" type="checkbox"> some of the terms 一些术语</li>
<li><input disabled="" type="checkbox"> take place on 发生</li>
<li><input disabled="" type="checkbox"> opt to 选择</li>
<li><input disabled="" type="checkbox"> from scratch 从零开始</li>
<li><input disabled="" type="checkbox"> put … in the pit of 形容一种状态或情感</li>
<li><input disabled="" type="checkbox"> in tens of thousands of 成千上万</li>
<li><input disabled="" type="checkbox"> so far 到目前为止</li>
<li><input disabled="" type="checkbox"> go back and forth 来回走动</li>
</ul>
<blockquote>
<p>interactivity n 交互性<br>possible adj 可能的 n 可能性<br>descriptive adj 描述性的<br>confidence n 信心、自信<br>invaluable adj 极其有用的、极其宝贵的<br>adopt v 接受、领养<br>enable 使、令、使得、启用、允许<br>excel v 擅长、优于<br>scalable adj 可拓展的<br>advanced adj 先进的、高级的 v 发展、前进<br>transition n 转变、过渡、转换<br>auto n 汽车 adj 汽车的<br>instantaneous adj 瞬间发生的<br>recap v 摘要说明 n 概述<br>recap v 扼要重述<br>reduction n 减少、降价、折扣、规约<br>primitives n 基元<br>essential adj 基础的、必要的、本质的<br>summarize v 总结<br>continuing adj 继续的、持续的<br>familiar adj 熟悉的<br>foundation n 地基、基础、基金会<br>basic adj 基础的、简单的 n 基本原则、基本要素<br>structure n 结构、组织、结构体、机构 v 组织、计划、安排<br>integration n 集成、整合<br>performant adj 性能好的、运行良好的<br>consideration n 考量、注意事项<br>compiler n 编译器<br>compiling n 编译、汇编<br>compilation n 编译 、编绘 、汇编 、编制<br>readability n 可读性<br>large-scale 大规模<br>massive adj 大规模的、大而重的<br>resolve v 分解、解析<br>bundle n 捆绑包<br>chunk n 快、区块<br>built-in 内置<br>redundant adj 冗余的、被解雇的<br>appropriate adj 合适的 v 挪用<br>contrast n 差异、对照物 v 对比、对照<br>incremental adj 递增的<br>basis n 基础、基本、要素、方法、理由<br>capable adj 能干的 n 能力、帆<br>geographically adv 在地理上<br>fringe n 边缘、刘海、穗 adj 次要的<br>generalized adj 广义的<br>latency n 延迟、潜在因素</p>
</blockquote>
<blockquote>
<p>scratch v 挠、轻抓 n 划痕<br>otherwise adv 否则、不然<br>pit n 坑、洼<br>intuitive adj 直接的、易懂的<br>prefetch n 预先载入<br>specific adj 明确的、特定的<br>quiz n 小测验<br>quizzes n 小测验（复数）<br>stuck adj 卡住的 v 粘、贴<br>iterate v 迭代</p>
</blockquote>
<blockquote>
<p>forth adv 离去、外出、带来、拿出、自……以后，向前<br>near-instant 几乎即时的<br>serve sth to 送…去…<br>penalize v 惩罚，处罚<br>cumulative adj 积累的，渐增的<br>shift v 移动、转移 n 改变<br>vital adj  至关重要的，必不可少的 n 关键<br>aspect n 方面、层面、角度<br>desire n 期望、渴望、欲望</p>
</blockquote>
<blockquote>
<p>substitution n 代替、替换、代替物<br>registry n 注册处<br>facilitate v 方便、促进、遍历<br>scenarios n 场景、情节、脚本<br>applicable adj 适当的、适用的<br>idle adj 空闲的<br>variety n 多样化、种类、各种各样<br>unintentionally adv 无意地<br>intention n 意图、目的<br>polish v 润色</p>
</blockquote>
<blockquote>
<p>equivalent adj 等同的，等效的 n 对等的人（或事物），对应的人（或事物）</p>
</blockquote>
<h2 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h2><table>
<thead>
<tr>
<th>词组</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>make use of</td>
<td>利用</td>
</tr>
<tr>
<td>changes over time</td>
<td>随着时间改变</td>
</tr>
<tr>
<td>prefix it with</td>
<td>以…开头</td>
</tr>
<tr>
<td>take the opportunity to</td>
<td>抓住机会，借此机会</td>
</tr>
<tr>
<td>dive right in</td>
<td>立即投入、立即开始做某事</td>
</tr>
<tr>
<td>to do so</td>
<td>去做、就这么</td>
</tr>
<tr>
<td>more on this later</td>
<td>稍后详述</td>
</tr>
<tr>
<td>to recap</td>
<td>回顾</td>
</tr>
<tr>
<td>get a sense of</td>
<td>了解、感受</td>
</tr>
<tr>
<td>a taste of</td>
<td>尝试、一点点</td>
</tr>
<tr>
<td>aim to</td>
<td>目标是… 旨在</td>
</tr>
<tr>
<td>for instance</td>
<td>例如</td>
</tr>
<tr>
<td>turn … into …</td>
<td>使…变成…</td>
</tr>
<tr>
<td>some of the terms</td>
<td>一些术语</td>
</tr>
<tr>
<td>take place on</td>
<td>发生</td>
</tr>
<tr>
<td>opt to</td>
<td>选择</td>
</tr>
<tr>
<td>from scratch</td>
<td>从零开始</td>
</tr>
<tr>
<td>put … in the pit of</td>
<td>形容一种状态或情感</td>
</tr>
<tr>
<td>in tens of thousands of</td>
<td>成千上万</td>
</tr>
<tr>
<td>so far</td>
<td>到目前为止</td>
</tr>
<tr>
<td>go back and forth</td>
<td>来回走动</td>
</tr>
<tr>
<td>as well as</td>
<td>也、除、而且、和 、或者</td>
</tr>
<tr>
<td>in addition to</td>
<td>除了…</td>
</tr>
</tbody></table>
<h2 id="关联词"><a href="#关联词" class="headerlink" title="关联词"></a>关联词</h2><table>
<thead>
<tr>
<th>单词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>otherwise</td>
<td>否则</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>生词本1</title>
    <url>/2023/07/19/English/%E7%94%9F%E8%AF%8D%E6%9C%AC1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>[!note]+<br>oriented adj 以…为方向<br>orient v 朝向、面对<br>hood n 兜帽、头巾、暴徒、街区<br>make use of 利用<br>robust adj 强壮的、强健的、健壮的<br>under the hood 在底层<br>myriad adj 无数的 n 无数<br>underlying adj 根本的、底层的 v 位于…之下、构成…的基础<br>philosophy n 哲学、基本原理<br>superb adj 极佳的、质量极高的<br>architecture n 架构、建筑设计<br>out-of-the-box 开箱即用<br>loose adj 松动的、松散的 v 释放、松开、发泄<br>coupled adj 耦合的、成对的、共轭的<br>loosely coupled 低耦合的<br>scaffold v 给…搭脚手架 n 脚手架<br>conventional adj 依照惯例的、常规的<br>populate v 给文件增添数据、居住于<br>invention n 发明物、发明<br>alternative n 替代物、替代选择<br>flavor n 风情、味道<br>boilerplate n 样板文件<br>a lot of ground at 大部分<br>sth be compatible with sth 与…兼容<br>takes advantage of 利用<br>advantage n 优势<br>vanilla adj 普通的<br>requisite n 必需品、必备品<br>fulfill v 实现<br>inbound adj 入境的 n 入站<br>minimalist n 温和政治改良主义者；极简抽象派艺术家<br>overhead n 开销、支出<br>respectively adv 分别地，依次地<br>specify v 明确指出、具体说明<br>exclusively adv 单独地、专门地、仅仅<br>prompt n 提示符<br>at scale 大规模<br>be responsible for 负责…<br>purpose n 目的<br>perform v 执行、表演、表现<br>decorator n 装饰器<br>corresponding adj 相关的<br>validation n 生效、验证<br>repetitive adj 重复的<br>portion n 一部分<br>correspond v 相当于、类似于<br>concatenate v 连接<br>arbitrary adj 随意的、任意的<br>significance n 重要性、意义<br>manipulate v 操纵、操作<br>thus adv 因此<br>furthermore adv 此外、而且<br>except for 除了…<br>signature n 签名<br>compatibility n 兼容性<br>hang v 挂起<br>wildcard n 通配符<br>pattern n 模式<br>asterisk n 星号<br>hyphen n 连字符（-）</p>
</blockquote>
<blockquote>
<p>omit v 省略<br>intercept v 拦截<br>singleton n 单例、单件<br>hence adv 所以<br>for instant 例如<br>multi-tenancy 多租户<br>tenancy n 租期、租用、租约<br>deferred adj 延期的<br>payload n 负荷、载荷<br>transpilation n 转译<br>preserve v 保存、保留 n 保护区<br>reserve v 保存、保留<br>liquidity n 现金、液体<br>thereafter adv 此后<br>breed v 饲养 n 品种<br>separate adj 单独的、分开的 v 分开<br>schema n 模式、架构、纲要、方案<br>wiring up 接线<br>delegate v 授权、委托<br>retrieval n 找回、取回、检索<br>inversion n 相反、倒置、转换<br>occasionally adv 偶然、偶尔<br>tedious adj 冗长的、单调乏味的<br>thus far 迄今<br>circumstance n 情况、环境<br>theoretically adv 理论上地<br>emphasize  v 强调<br>emphasis n 重要性、重调<br>encapsulating  n 封装 v 封进内部<br>capabilities n 能力、力量<br>demonstrate v 演示、游行<br>as seen above 如上所示<br>circular adj 圆形的、环形的<br>elsewhere adv 在别处、去别处<br>ubiquitous adj 普遍存在的、无处不在的<br>manner n 方式、风格、习俗、态度、举止、礼貌</p>
</blockquote>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>Drawing 2023-05-29 21.30.43.excalidraw</title>
    <url>/2023/06/24/Excalidraw/Drawing%202023-05-29%2021.30.43.excalidraw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p>
<p>%%</p>
<h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;excalidraw&quot;</span>,<span class="attr">&quot;version&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;source&quot;</span>:<span class="string">&quot;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.17&quot;</span>,<span class="attr">&quot;elements&quot;</span>:[],<span class="attr">&quot;appState&quot;</span>:&#123;<span class="attr">&quot;gridSize&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;viewBackgroundColor&quot;</span>:<span class="string">&quot;#ffffff&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>%%</p>
]]></content>
      <categories>
        <category>Excalidraw</category>
      </categories>
  </entry>
  <entry>
    <title>Drawing 2023-05-06 11.00.41.excalidraw</title>
    <url>/2023/06/24/Excalidraw/Drawing%202023-05-06%2011.00.41.excalidraw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p>
<p>%%</p>
<h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;excalidraw&quot;</span>,<span class="attr">&quot;version&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;source&quot;</span>:<span class="string">&quot;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.17&quot;</span>,<span class="attr">&quot;elements&quot;</span>:[],<span class="attr">&quot;appState&quot;</span>:&#123;<span class="attr">&quot;gridSize&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;viewBackgroundColor&quot;</span>:<span class="string">&quot;#ffffff&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>%%</p>
]]></content>
      <categories>
        <category>Excalidraw</category>
      </categories>
  </entry>
  <entry>
    <title>Drawing 2023-06-21 16.25.16.excalidraw</title>
    <url>/2023/06/24/Excalidraw/Drawing%202023-06-21%2016.25.16.excalidraw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p>
<p>%%</p>
<h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;excalidraw&quot;</span>,<span class="attr">&quot;version&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;source&quot;</span>:<span class="string">&quot;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.17&quot;</span>,<span class="attr">&quot;elements&quot;</span>:[],<span class="attr">&quot;appState&quot;</span>:&#123;<span class="attr">&quot;gridSize&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;viewBackgroundColor&quot;</span>:<span class="string">&quot;#ffffff&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>%%</p>
]]></content>
      <categories>
        <category>Excalidraw</category>
      </categories>
  </entry>
  <entry>
    <title>CSS知识点</title>
    <url>/2023/06/24/CSS/CSS%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID: ID_h1w7</span><br><span class="line">Number of Columns: 4</span><br><span class="line">Largest Column: standard</span><br></pre></td></tr></table></figure>

<ul>
<li>[[SVG]]</li>
<li>[[@font-face]]</li>
<li> [[grid-template-columns]]</li>
<li>[[margin-inline]]</li>
</ul>
<p>— end-column —</p>
<ul>
<li>[[可变字体]]</li>
<li>[[@media]]</li>
<li>[[fr]]</li>
<li>[[margin-inline]]</li>
</ul>
<p>— end-column —</p>
<ul>
<li>[[自定义属性]]</li>
<li>[[place-items]]</li>
<li>[[align-content,justify-content,align-items,justify-items]]</li>
</ul>
<p>— end-column —</p>
<ul>
<li>[[hsl()和hsla()]]</li>
<li>[[focus-visible 和 focus]]</li>
<li> [[aspect-ratio]]</li>
</ul>
<p>— end-multi-column</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID: ID_uezt</span><br><span class="line">Number of Columns: 3</span><br><span class="line">Largest Column: standard</span><br></pre></td></tr></table></figure>

<h2 id="分栏1"><a href="#分栏1" class="headerlink" title="分栏1"></a>分栏1</h2><ul>
<li>[[CSS 单位]]</li>
</ul>
<p>— column-end —</p>
<h2 id="分栏2"><a href="#分栏2" class="headerlink" title="分栏2"></a>分栏2</h2><p>— column-end —</p>
<h2 id="分栏3"><a href="#分栏3" class="headerlink" title="分栏3"></a>分栏3</h2><p>— end-multi-column</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS代码规范</title>
    <url>/2023/06/24/CSS/CSS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="class-命名"><a href="#class-命名" class="headerlink" title="class 命名"></a>class 命名</h2><p>避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。<br>class 名称应当尽可能短，并且意义明确。<br>随着项目模块增多，防止因为不同页面或者组件中定义的 css 冲突，所以规范 css 语法也变得至关重要，推荐:BEM，分别代表着:<strong>Block(块)、Element(元素)、Modifier(修饰符)</strong></p>
<blockquote>
<p>.user-info {} # user-info 是一个块，我理解是一个模块<br>.user-info–feature {} # user-info–feature 是一个修饰符，用来表示这个块的不同状态<br>.user-info__title{} # user-info__title 是一个元素，属于userinfo模块下的，多个元素组成块</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;user-info&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;user-info__title&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;user-info__age&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabs&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab tab-active&quot;</span>&gt;</span>选中的标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab &quot;</span>&gt;</span>标签二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab &quot;</span>&gt;</span>标签三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="css-属性声明顺序"><a href="#css-属性声明顺序" class="headerlink" title="css 属性声明顺序"></a>css 属性声明顺序</h2><ol>
<li>Positioning</li>
<li>Box model</li>
<li>Typographic</li>
<li>Visual</li>
<li>Misc<br>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。<br>其他属性只是影响组件的 内部 或者是不影响前两组属性，因此排在后面。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.declaration-order</span> &#123;</span><br><span class="line">  <span class="comment">/* Positioning  定位和层级等属性*/</span></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Box-model 盒子模型或者浮动相关*/</span></span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Typography 字体配置*/</span></span><br><span class="line">  <span class="attribute">font</span>: normal <span class="number">13px</span> <span class="string">&quot;Helvetica Neue&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Visual 背景色边框等*/</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Misc 透明度和动画等*/</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>柯里化</title>
    <url>/2023/06/24/JS/%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addOne = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addOneAndTwo = addOne(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> addOneAndTwoAndThree = addOneAndTwo(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addOneAndTwoAndThree);</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的<code>curry</code>帮助函数（<code>helper function</code>）使这类函数的定义和调用更加容易。</p>
<p>用<code>ES6</code>的箭头函数，我们可以将上面的<code>add</code>实现成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">z</span> =&gt;</span> x + y + z;</span><br></pre></td></tr></table></figure>

<p><mark style="background: #FF5582A6;">好像使用箭头函数更清晰了许多</mark>😒。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>#FF</tag>
      </tags>
  </entry>
  <entry>
    <title>bind函数</title>
    <url>/2023/06/24/JS/bind%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Function.prototype.bind() bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.temp);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c, d)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> demo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = hello.bind(demo, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">h(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// out &#x27;demo&#x27; &#x27;1 2 3 4 &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，bind方法实现了更改原函数内部的this指向并返回了一个新函数出来。所以后面要有一个小括号，也就是执行后才会得到对应的结果。bind中里第一个括号里面的第一个参数被当做函数的this，其余参数包括后面执行函数时传入的参数依次被原函数使用（[[柯里化]]）。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>形参和实参</title>
    <url>/2023/06/24/JS/%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h2><p>函数定义的可接受参数</p>
<h4 id="获取形参"><a href="#获取形参" class="headerlink" title="获取形参"></a>获取形参</h4><ol>
<li>通过<code>fn.length</code>获取形参数量</li>
</ol>
<h2 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h2><p>传入函数的实际函数</p>
<h4 id="获取实参"><a href="#获取实参" class="headerlink" title="获取实参"></a>获取实参</h4><ol>
<li>通过<code>argument</code>获取所有的实参，</li>
<li><code>argument</code>是伪数组，有<code>length</code>属性，可通过下标获取参数，不能直接使用数组的方法</li>
</ol>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log(num1 + num2); </span><br><span class="line">&#125; </span><br><span class="line">sum(<span class="number">100</span>, <span class="number">200</span>); </span><br><span class="line"><span class="comment">// 形参和实参个数相等，输出正确结果 sum(100, 400, 500, 700); </span></span><br><span class="line"><span class="comment">// 实参个数多于形参，只取到形参的个数 sum(200); </span></span><br><span class="line"><span class="comment">// 实参个数少于形参，多的形参定义为undefined，结果为NaN</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>理解依赖注入</title>
    <url>/2023/07/21/Others/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>依赖注入(<code>Dependency injection</code>，简称DI)是Angular中的一个基本概念。DI被连接到Angular框架中，它允许带有Angular装饰器的类(比如<code>component</code>、<code>directive</code>、<code>Pipes</code>和<code>Injectables</code>)配置它们需要的依赖项。</p>
<p>依赖依赖系统中存在两个主要角色:<strong>依赖消费者</strong>和<strong>依赖提供者</strong>。</p>
<p>Angular通过一个叫做注入器的抽象来促进依赖消费者和依赖提供者之间的交互。当一个依赖项被请求时，注入器会检查它的注册表，看看那里是否已经有可用的实例。如果没有，则创建一个新实例并将其存储在注册表中。Angular会在应用的引导过程中创建一个应用级注入器(也称为“root”注入器)，还会根据需要创建其他注入器。在大多数情况下，你不需要手动创建注入器，但你应该知道有一个连接提供者和消费者的层。</p>
<p>本主题涵盖了类如何作为依赖项的基本场景。Angular还允许你使用函数、对象、基本类型(如string或Boolean)或任何其他类型作为依赖项。有关更多信息，请参见<a href="https://angular.io/guide/dependency-injection-providers">依赖提供程序</a>。</p>
<h2 id="提供的依赖"><a href="#提供的依赖" class="headerlink" title="提供的依赖"></a>提供的依赖</h2><p>想象一下，有一个叫做<code>HeroService</code>的类需要作为组件中的依赖项。</p>
<p>第一步是添加<code>@Injectable</code>装饰器，以显示该类可以被注入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下一步是通过provide它来使它在DI中可用。一个依赖可以在多个地方provide:</p>
<ul>
<li>在组件级别，使用<code>@Component</code>装饰器的providers字段。在这种情况下，<code>HeroService</code>对该组件的所有实例以及模板中使用的其他组件和指令都是可用的。例如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;hero-list&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">providers</span>: [HeroService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroListComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当您在组件级别注册提供者时，每个组件的新实例都会获得该服务的新实例。</p>
<ul>
<li>在NgModule级别，使用@NgModule装饰器的providers字段。在这种情况下，HeroService对本NgModule或其他NgModule中声明的所有组件、指令和管道都是可用的，只要这些组件、指令和管道位于适用于本NgModule的同一个ModuleInjector中。当你在某个特定的NgModule中注册了一个提供商时，所有组件、指令和管道都可以使用同一个服务实例。要了解所有边缘情况，请参见分层注入器。例如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">  <span class="attr">declarations</span>: [HeroListComponent]</span><br><span class="line">  <span class="attr">providers</span>: [HeroService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroListModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在应用程序根级，这允许将其注入到应用程序中的其他类中。这可以通过在@Injectable装饰器中添加providedIn: ‘root’字段来实现:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Injectable(&#123;</span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当你在根级提供该服务时，Angular会创建一个单独的、共享的<code>HeroService</code>实例，并把它注入到任何请求它的类中。在<code>@Injectable</code>元数据中注册该提供商还允许Angular通过从编译后的应用中删除未使用的服务来优化应用，这个过程被称为<code>tree-shaking</code>。</p>
<h2 id="注入依赖项"><a href="#注入依赖项" class="headerlink" title="注入依赖项"></a>注入依赖项</h2><p>注入依赖项最常见的方法是在类构造函数中声明它。当Angular创建一个组件、指令或管道类的新实例时，它会通过查看构造函数的参数类型来确定该类需要哪些服务或其他依赖项。例如，如果<code>HeroListComponent</code>需要<code>HeroService</code>，它的构造函数可以是这样的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Component(&#123; … &#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroListComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private service: HeroService</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个选择是使用inject方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Component(&#123; … &#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroListComponent</span> </span>&#123;</span><br><span class="line">  private service = inject(HeroService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Angular发现某个组件依赖于某个服务时，它首先会检查注入器中是否存在该服务的实例。如果被请求的服务实例还不存在，注入器就会使用已注册的提供商创建一个，并在将该服务返回给Angular之前把它添加到注入器中。</p>
<p>当所有请求的服务都被解析并返回后，Angular就可以用这些服务作为参数来调用组件的构造函数。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250945448.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>React学习路径</title>
    <url>/2023/06/24/React/React%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>React学习路径</p>
<p>React是一个用于构建用户界面的JavaScript库，它提供了一种声明式、组件化和高效的方式来开发前端应用。React的核心思想是使用组件来表示不同的UI元素，然后通过状态和属性来控制组件的渲染和交互。React还支持虚拟DOM技术，可以实现高性能的DOM更新。</p>
<p>如果你想学习React，那么你需要掌握以下几个方面的知识：</p>
<ul>
<li>基础知识：你需要了解JavaScript的基本语法和特性，包括变量、函数、对象、数组、字符串、运算符、条件语句、循环语句等。你还需要熟悉HTML和CSS的基本用法，以及如何在浏览器中使用开发者工具进行调试。</li>
<li>React基础：你需要学习React的基本概念和用法，包括如何创建组件、如何使用JSX语法、如何管理组件的状态和属性、如何使用事件处理器、如何使用生命周期方法等。你还需要了解React的设计原则和最佳实践，以及如何在不同场景下使用类组件或函数组件。</li>
<li>React进阶：你需要学习React的高级特性和技巧，包括如何使用Hooks来简化函数组件的逻辑和副作用管理、如何使用自定义Hooks来复用逻辑和状态、如何使用Context API来实现跨组件的数据共享、如何使用Ref API来访问DOM元素或子组件实例等。你还需要了解React的性能优化策略，以及如何利用DevTools工具进行分析和调试。</li>
<li>React生态：你需要学习React周边的一些库和工具，以及它们与React的集成方式。例如，你可以学习如何使用Redux或MobX来管理应用的全局状态，如何使用Router或Next.js来实现路由导航和服务端渲染，如何使用Material UI或Ant Design等UI框架来提升界面美观度和交互体验，如何使用Webpack或Create React App等构建工具来配置开发环境和打包部署等。</li>
<li>React实战：你需要通过一些项目案例来综合运用所学知识，并且掌握一些常见需求和问题的解决方案。例如，你可以尝试开发一个Todo List应用或一个电商网站，并且实现一些功能模块，比如登录注册、购物车结算、商品列表筛选排序等。你还可以参考一些优秀的开源项目或教程，并且尝试改进或扩展它们。</li>
</ul>
<p>以上就是一个简单而全面的React学习路径，当然这并不是唯一或最佳的路径，每个人根据自己的情况和目标可以有不同的选择。但无论怎样，在学习过程中要保持兴趣和耐心，并且多动手多思考多总结。希望这篇文章对你有所帮助！</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2023/06/24/Hexo/Hexo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/554333805">Obsidian+Git完美维护Hexo博客 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/daniel_wangt/article/details/107201959">(34条消息) Hexo + Gitee安装部署完整过程_gitee部署hexo_itnwork的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>搭建开发环境</title>
    <url>/2023/06/24/React/%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>interface</title>
    <url>/2023/06/24/TypeScript/interface/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#面向对象<br>接口用来定义一个类的结构，或者用作类型声明</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">	age:int;</span><br><span class="line">	sayHello(name:<span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同名interface会合并，而type不会</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">	age:int;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">	<span class="attr">gender</span>:<span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等于</span><br><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">	age:int;</span><br><span class="line">	gender:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接口中的属性不能有实际的值</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>rest参数</title>
    <url>/2023/06/24/JS/rest%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>…</p>
</blockquote>
<p>在JavaScript中，省略号(…)表示剩余参数语法，可以将多个参数表示为数组。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b, ...args</span>) </span>&#123;   </span><br><span class="line">	<span class="built_in">console</span>.log(args); </span><br><span class="line">&#125; </span><br><span class="line">myFunction(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>


<p>这将输出：[3, 4, 5]</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>abstract</title>
    <url>/2023/06/24/TypeScript/abstract/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#面向对象</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>不能实例化，专门用来被继承的类</p>
<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>没有方法体，必须在抽象类中，子类必须重写</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>super</title>
    <url>/2023/06/24/TypeScript/super/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#面向对象<br>子类重写构造函数一定要在里面调用super</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>使用Webpack打包ts</title>
    <url>/2023/06/24/TypeScript/%E4%BD%BF%E7%94%A8Webpack%E6%89%93%E5%8C%85ts/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HTMLWebPackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cleanWebPackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 指定入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./index.ts&#x27;</span>,</span><br><span class="line">    <span class="comment">// 指定打包文件所在路径</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定webpack打包要使用哪些模块</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定要加载的规则</span></span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="comment">// 要使用的loader</span></span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//指定加载器</span></span><br><span class="line">                        <span class="attr">loader</span>:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>:&#123;</span><br><span class="line">                            <span class="attr">presets</span>:[</span><br><span class="line">                                <span class="comment">//指定环境的插件</span></span><br><span class="line">                                <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">                                <span class="comment">//配置信息</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">//要兼容的目标浏览器</span></span><br><span class="line">                                    <span class="attr">targets</span>: &#123;</span><br><span class="line">                                        <span class="string">&quot;chrome&quot;</span>:<span class="string">&quot;88&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;ie&quot;</span>:<span class="string">&quot;11&quot;</span></span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    <span class="comment">//指定core.js的版本</span></span><br><span class="line">                                    <span class="string">&quot;corejs&quot;</span>:<span class="string">&quot;3&quot;</span>,</span><br><span class="line">                                    <span class="comment">//使用corejs的方式&quot;usage&quot;表示按需加载</span></span><br><span class="line">                                    <span class="string">&quot;useBuiltIns&quot;</span>:<span class="string">&quot;usage&quot;</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;ts-loader&#x27;</span>],</span><br><span class="line">                <span class="comment">//要排除的文件</span></span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置webpack插件</span></span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="comment">//清除dist</span></span><br><span class="line">        <span class="keyword">new</span> cleanWebPackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HTMLWebPackPlugin(&#123;</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;自定义html文件的title&#x27;</span>,</span><br><span class="line">            <span class="comment">//指定一个模板</span></span><br><span class="line">            <span class="comment">// template: &#x27;&#x27;,</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//哪些文件可以当作模块引入</span></span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>type</title>
    <url>/2023/06/24/TypeScript/type/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#面向对象 </p>
<p>声明一个对象的类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">	<span class="attr">age</span>:int</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj:myType</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>小技巧</title>
    <url>/2023/06/24/TypeScript/%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-在构造函数里面直接声明属性"><a href="#1-在构造函数里面直接声明属性" class="headerlink" title="1.在构造函数里面直接声明属性"></a>1.在构造函数里面直接声明属性</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title">constructor</span> <span class="title">className</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span>, <span class="keyword">public</span> age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2023/06/24/TypeScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="number-string-boolean"><a href="#number-string-boolean" class="headerlink" title="number,string,boolean"></a>number,string,boolean</h2><p>数字，字符串，布尔型</p>
<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>表示任何类型</p>
<h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p>类型安全的any，unknown的变量不能直接赋值给其他变量</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b: unknown;</span><br><span class="line"><span class="keyword">let</span> bb: <span class="built_in">string</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// b = 123;  //success</span></span><br><span class="line"><span class="comment">// bb = b;  //error</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// b = &#x27;xiaomi&#x27;;</span></span><br><span class="line"><span class="comment">// bb = b;  //error</span></span><br><span class="line"><span class="comment">// 如何成功</span></span><br><span class="line"><span class="comment">/* 类型断言：用来告诉解析器变量的实际类型</span></span><br><span class="line"><span class="comment">    语法：</span></span><br><span class="line"><span class="comment">        变量 as 类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">b = <span class="string">&#x27;xiaomi&#x27;</span>;</span><br><span class="line">bb = b <span class="keyword">as</span> <span class="built_in">string</span>;  <span class="comment">//success</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) bb = b  <span class="comment">//success</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* any类型，不报错,怎么设置都可以，可以赋值给任意变量，可见any真的不到万不得已不能使用 */</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">any</span>;</span><br><span class="line">c = <span class="number">999</span>;</span><br><span class="line">bb = c; <span class="comment">//success  </span></span><br><span class="line"> </span><br><span class="line">c = [<span class="string">&#x27;123&#x27;</span>];</span><br><span class="line">bb = c; <span class="comment">//success</span></span><br></pre></td></tr></table></figure>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>表示没有值或者undefined</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return &#x27;123&#x27;;  //error</span></span><br><span class="line">    <span class="comment">// return &#x27;xiaomi&#x27;; //error</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//success</span></span><br><span class="line">    <span class="comment">// return undefined; //success</span></span><br><span class="line">    <span class="comment">// return null; //success</span></span><br><span class="line">    <span class="comment">//或者不写return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data: <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// data = &#x27;123&#x27;; //error</span></span><br><span class="line"><span class="comment">// data = [123]; //error</span></span><br><span class="line"><span class="comment">// data = undefined; //success</span></span><br><span class="line"><span class="comment">// data = null; //success</span></span><br></pre></td></tr></table></figure>
<h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>从不会出现的值，没有值，不能是任何值,永远不会有返回结果（返回“从不”的函数不能具有可访问的终结点）</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> good: <span class="built_in">never</span>;</span><br><span class="line"><span class="comment">// good = &#x27;123&#x27;; //error</span></span><br><span class="line"><span class="comment">// good = undefined; //error</span></span><br><span class="line"><span class="comment">// good = null; //error</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goodFun</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return &#x27;123&#x27;; //error</span></span><br><span class="line">    <span class="comment">// return;  //error</span></span><br><span class="line">    <span class="comment">// return undefined; //error</span></span><br><span class="line">    <span class="comment">// return null; //error</span></span><br><span class="line">    <span class="comment">// console.log(&#x27;123&#x27;); //error</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>); <span class="comment">//success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>需要留意这两个特殊点</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如要求 name属性，salary属性这两个属性必须要有，其他的属性随便添加修改</span></span><br><span class="line"><span class="comment">// job = &#123; name: &#x27;ios&#x27;, salary: 11, company: &#x27;阿里巴巴&#x27; &#125;; //error，多设置了属性名，此属性名并未在job中声明</span></span><br><span class="line"><span class="comment">// [propName: string]: type; type:any:表示任意类型的属性； type:string:表示属性的值只能为string 同理···</span></span><br><span class="line"><span class="keyword">let</span> job2: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">salary</span>: <span class="built_in">number</span>, [propName: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;</span><br><span class="line">job2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;ios&#x27;</span>, <span class="attr">salary</span>: <span class="number">11</span>, <span class="attr">company</span>: <span class="string">&#x27;阿里巴巴&#x27;</span>, <span class="attr">boss</span>: <span class="string">&#x27;马云&#x27;</span> &#125;;<span class="comment">//success</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如这个时候，我们只想设置一个name，salary不想设置，这个时候是报错的，修改如下</span></span><br><span class="line"><span class="comment">// job = &#123; name: &#x27;ios&#x27; &#125;; //error </span></span><br><span class="line"><span class="keyword">let</span> job1: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, salary?: <span class="built_in">number</span> &#125;  <span class="comment">//属性 ? : type  表示此属性可有可无</span></span><br><span class="line">job1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;android&#x27;</span> &#125;; <span class="comment">//success</span></span><br></pre></td></tr></table></figure>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>两种声明方式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="built_in">number</span>[];</span><br><span class="line"><span class="keyword">let</span> a:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>固定长度的数组，多了少了都不行</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:[<span class="built_in">string</span>,<span class="built_in">string</span>]</span><br><span class="line">a=[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>] <span class="comment">//success</span></span><br><span class="line">a=[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>] <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Gender &#123;</span><br><span class="line">    woman,</span><br><span class="line">    man,</span><br><span class="line">    <span class="comment">//woman = 0,</span></span><br><span class="line">    <span class="comment">//man=1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">gender</span>: Gender &#125;;</span><br><span class="line">person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;科比&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: Gender.man</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (person.gender === Gender.man) <span class="built_in">console</span>.log(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (person.gender === Gender.woman) <span class="built_in">console</span>.log(<span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>类型的就是值，不可变</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="number">10</span>;</span><br><span class="line">a = <span class="number">1</span> <span class="comment">//false</span></span><br><span class="line">a = <span class="string">&#x27;1&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>特殊点</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="string">&#x27;a&#x27;</span>|<span class="number">123</span>|<span class="literal">false</span>;</span><br><span class="line">a = <span class="string">&#x27;a&#x27;</span> <span class="comment">//true</span></span><br><span class="line">a = <span class="number">123</span> <span class="comment">//true</span></span><br><span class="line">a = <span class="literal">false</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>权限修饰符</title>
    <url>/2023/06/24/TypeScript/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>修饰的属性可以在任意位置访问和修改</p>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>私有属性，私有属性只能在类内部进行访问，<br>通过get/set方法可以被外部访问</p>
<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>受保护的属性，只能在当前类和当前类的子类中被访问，不能被实例访问</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>编译配置(tsconfig.json)</title>
    <url>/2023/06/24/TypeScript/%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE(tsconfig.json)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p>需要编译的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">**  <span class="comment">//表示任意目录</span></span><br><span class="line">* <span class="comment">//表示任意文件</span></span><br></pre></td></tr></table></figure>
<h2 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h2><p>不需要的文件</p>
<h2 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h2><p>编译器选项</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>使用的模块系统</p>
<h3 id="outDir"><a href="#outDir" class="headerlink" title="outDir"></a>outDir</h3><p>编译后产生的文件所在的目录</p>
<h3 id="outFile"><a href="#outFile" class="headerlink" title="outFile"></a>outFile</h3><p>编译到一个文件里面</p>
<h3 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h3><p>是否对js进行编译</p>
<h3 id="checkJs"><a href="#checkJs" class="headerlink" title="checkJs"></a>checkJs</h3><p>检查js是否符合规范</p>
<h3 id="removeComments"><a href="#removeComments" class="headerlink" title="removeComments"></a>removeComments</h3><p>是否移除注释</p>
<h3 id="noEmit"><a href="#noEmit" class="headerlink" title="noEmit"></a>noEmit</h3><p>不生成编译后的文件</p>
<h3 id="noEmitOnError"><a href="#noEmitOnError" class="headerlink" title="noEmitOnError"></a>noEmitOnError</h3><p>有错误时不编译</p>
<h3 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a>alwaysStrict</h3><p>编译后的文件是否使用严格模式，默认false</p>
<h3 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h3><p>不允许隐式的any</p>
<h3 id="noImplicitThis"><a href="#noImplicitThis" class="headerlink" title="noImplicitThis"></a>noImplicitThis</h3><p>不允许不明确类型的this</p>
<h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h3><p>严格的检查空值</p>
<h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h3><p>所有严格检查的总开关</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>国际化</title>
    <url>/2023/06/24/Vue/%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在页面重新加载时重新初始化i18n对象，需要从localstorage读取当前的语言，vuex在页面刷新时会被重置，所以不要通过vuex去初始化i18n</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">&#x27;vue-i18n&#x27;</span></span><br><span class="line"><span class="comment">// import Cookies from &#x27;js-cookie&#x27;</span></span><br><span class="line"><span class="keyword">import</span> locale <span class="keyword">from</span> <span class="string">&#x27;element-ui/lib/locale&#x27;</span></span><br><span class="line"><span class="keyword">import</span> elementEnLocale <span class="keyword">from</span> <span class="string">&#x27;element-ui/lib/locale/lang/en&#x27;</span> <span class="comment">// element-ui lang</span></span><br><span class="line"><span class="keyword">import</span> elementZhLocale <span class="keyword">from</span> <span class="string">&#x27;element-ui/lib/locale/lang/zh-CN&#x27;</span><span class="comment">// element-ui lang</span></span><br><span class="line"><span class="keyword">import</span> enLocale <span class="keyword">from</span> <span class="string">&#x27;./en&#x27;</span></span><br><span class="line"><span class="keyword">import</span> zhLocale <span class="keyword">from</span> <span class="string">&#x27;./zh&#x27;</span></span><br><span class="line">Vue.use(VueI18n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">  <span class="attr">en</span>: &#123;</span><br><span class="line">    ...enLocale,</span><br><span class="line">    ...elementEnLocale</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">zh</span>: &#123;</span><br><span class="line">    ...zhLocale,</span><br><span class="line">    ...elementZhLocale</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n(&#123;</span><br><span class="line">  <span class="comment">// 设置语言 选项 en | zh</span></span><br><span class="line">  <span class="comment">// locale: Cookies.get(&#x27;language&#x27;) || &#x27;en&#x27;,</span></span><br><span class="line">  <span class="attr">locale</span>: <span class="built_in">localStorage</span>.lang || <span class="string">&#x27;zh&#x27;</span>, <span class="comment">//初始默认 cn 中文</span></span><br><span class="line">  <span class="comment">// 设置文本内容</span></span><br><span class="line">  messages</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">locale.i18n(<span class="function">(<span class="params">key, value</span>) =&gt;</span> i18n.t(key, value)) <span class="comment">//兼容element</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n</span><br></pre></td></tr></table></figure>

<p>修改语言要通过全局的<code>this.$i18n.locale</code>对象来修改，同时要修改localstorage中语言的值</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2023/06/26/Vue/Vuex/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="vuex-mutation和action的区别"><a href="#vuex-mutation和action的区别" class="headerlink" title="vuex mutation和action的区别"></a>vuex mutation和action的区别</h2><p>Vuex 中的 mutation 和 action 都是一种改变应用程序状态的方法，它们的目的不同。</p>
<p>Mutation 是 Vuex 中专门用于改变状态的方法。它是一个同步操作，通过 mutation 中定义的方法来修改 state，从而实现状态的响应式更新。Mutation 必须是同步函数，使得 Vuex 能够确保状态的响应式更新，同时也使得开发者能够更容易的去理解和追踪状态的变化记录。</p>
<p>Action 主要用于业务操作和异步操作。Action 可以包含任何异步操作，如发送网络请求或执行定时任务等。使用 Action 可以使代码更加模块化，易于维护。Action 中也可以调用 Mutation 来更新状态，但是当需要在异步操作结束后，才能对状态进行修改的时候，应该使用 Action。</p>
<p>在应用程序中，当需要执行异步操作或者一些复杂的操作时，使用 Action 是更好的选择。而当需要修改状态时，则应该使用 Mutation。</p>
<p>需要注意的是，<mark style="background: #FF5582A6;">Mutation 能够触发组件中的渲染，而 Action 不能触发组件中的渲染</mark>，因此在改变状态的时候，如果需要触发组件中的更新，应该使用 Mutation。</p>
<h2 id="commit和dispatch的区别"><a href="#commit和dispatch的区别" class="headerlink" title="commit和dispatch的区别"></a>commit和dispatch的区别</h2><p>在 Vuex 中，commit 和 dispatch 是用于触发 mutation 和 action 的两个方法，它们的区别如下：</p>
<p>commit：用于触发 mutation，并且只能触发 mutation。它的语法是 store.commit(‘mutationName’)，其中 mutationName 是对应的 mutation 名称。</p>
<p>dispatch：用于触发 action，同时也可以触发 mutation。它的语法是 store.dispatch(‘actionName’)，其中 actionName 是对应的 action 名称。</p>
<p>因此，<mark style="background: #FF5582A6;">dispatch 可以用于处理异步操作</mark>，例如从后端获取数据后再触发相应的 mutation 更新状态；而 <mark style="background: #FF5582A6;">commit 则适用于同步操作</mark>，例如更新状态时直接触发相应的 mutation。</p>
<h2 id="获取vuex的值"><a href="#获取vuex的值" class="headerlink" title="获取vuex的值"></a>获取vuex的值</h2><p>要获取 Vuex 的状态值，可以通过 store.state 访问任何已注册的模块的状态，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex 的状态值</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vuex 的 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; state &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问状态值</span></span><br><span class="line"><span class="built_in">console</span>.log(store.state.count); <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>

<p>如果需要获取某个模块下的状态值，可以使用 store.state.moduleName 的方式，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex 的模块状态值</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vuex 的 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问模块的状态值</span></span><br><span class="line"><span class="built_in">console</span>.log(store.state.moduleA.count); <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>

<p>如果需要获取派生状态值（计算属性），可以使用 store.getters 和 mapGetters 工具函数，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="function"><span class="title">countPlusFive</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.count + <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vuex 的 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; state, getters &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mapGetters</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">&#x27;countPlusFive&#x27;</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.countPlusFive); <span class="comment">// 输出 5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>总之，获取 Vuex 的状态值应该根据具体的情况选择合适的方式，上面的代码片段只是提供了一些常见的方法。</p>
<h2 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h2><p>mapGetters 是一个辅助函数，可以将 store 中的 getters 映射到局部计算属性中。这个函数返回一个对象，对象的键是与 getters 名称相同，同时也会被映射为组件的局部计算属性。<br>如果你的 Vuex store 分成了多个模块，那么使用 mapGetters 也是类似的。你只需要根据模块的层级关系，按照格式 modulePath/getterName 来书写即可。<br>假设你有一个名为 myModule 的模块，其中有一个 getter 名为 doneTodosCount，那么在使用 mapGetters 时，应该这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// mapGetters 的第一个参数是一个对象，其中的键是新的计算属性的名称，</span></span><br><span class="line">    <span class="comment">// 值则是已声明的 Getter 函数名</span></span><br><span class="line">    ...mapGetters(<span class="string">&#x27;myModule&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// 这里的 &#x27;myModule&#x27; 是模块名称，用于区分 getter 是否为全局的。</span></span><br><span class="line">      <span class="comment">// 注意，如果你是在全局 getters 中定义的 getter，仍需要把模块命名为 &#x27;&#x27;（空字符串）</span></span><br><span class="line">      <span class="string">&#x27;newDoneTodosCount&#x27;</span>: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要同时使用多个 getter，则可以在传递第二个参数时，直接使用 getter 名称组成的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...mapGetters(<span class="string">&#x27;myModule&#x27;</span>, [</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子将 myModule 中的 doneTodosCount 和 anotherGetter 映射到了当前组件的计算属性中。<br>需要注意，如果你使用的是模块的 namespaced 特性，则在传入模块名称时需要加上命名空间前缀，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...mapGetters(<span class="string">&#x27;myModule&#x27;</span>, [</span><br><span class="line">      <span class="string">&#x27;myModule/doneTodosCount&#x27;</span>, <span class="comment">// 注意名字空间前缀</span></span><br><span class="line">      <span class="string">&#x27;myModule/anotherGetter&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，’myModule/‘ 表示模块命名空间前缀。由于 doneTodosCount 和 anotherGetter 函数是在 myModule 模块内定义的，因此需要在函数名称前面加上命名空间前缀 myModule/。这样做的目的是为了在多个模块互相调用时，确保每个函数的名称互不冲突。</p>
<h2 id="监听vuex"><a href="#监听vuex" class="headerlink" title="监听vuex"></a>监听vuex</h2><p>要使用 Vuex Store 的值并在其更改时触发组件上的响应，可以使用$store.watch方法监视 Store 的状态。</p>
<p>使用 this.$store.watch 可以监听 store 中 state 的属性，或者 getters 函数的返回值。watch 方法接收两个参数：</p>
<p>第一个参数是一个函数，用于获取 state 或 getters 的值。<br>第二个参数是回调函数，当监测到更改时会执行它，并传入新值和旧值。<br>例如，如果需要在 Store 中的 count 属性更改时触发组件上的方法，可以这样编写代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.watch(</span><br><span class="line">      <span class="comment">// 监视器函数</span></span><br><span class="line">      <span class="function">(<span class="params">state</span>) =&gt;</span> state.count,</span><br><span class="line">      <span class="comment">// 回调函数</span></span><br><span class="line">      <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 响应数据的更改</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;count 属性的值发生了变化，新值为：&#x27;</span>, newVal)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;旧值为：&#x27;</span>, oldVal)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，mapState 函数用于读取 count 属性的值。在 created 生命周期钩子中，我们通过 this.$store.watch 方法来监听 Store 中 count 属性的更改情况，当被监视的状态发生了变化时，回调函数将被触发。回调函数可以将新值和旧值作为参数传递，并在其中执行一些逻辑。</p>
<p>值得注意的是，除了 watch 方法，还有一些其他的方法可用于监视 Vuex 的状态变化。subscribe 和 subscribeAction 两个方法可用于监听 Mutations 和 Actions 的执行情况，subscribe 方法接受一个回调函数作为参数，而 subscribeAction 方法需要将要监听的 Action 函数名称作为参数。共同之处是，每当对应的 Mutations 或 Actions 执行时，回调函数都会被调用，可以在其中执行一些逻辑。但是，这两个方法都会返回一个用于解除监视的函数，使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = <span class="built_in">this</span>.$store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mutation:&#x27;</span>,mutation,<span class="string">&#x27;state:&#x27;</span>,state)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">unwatch() <span class="comment">// 取消监视</span></span><br><span class="line"><span class="keyword">const</span> unwatchAction = <span class="built_in">this</span>.$store.subscribeAction(<span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;action:&#x27;</span>,action,<span class="string">&#x27;state:&#x27;</span>,state)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">unwatchAction() <span class="comment">// 取消监视</span></span><br></pre></td></tr></table></figure>
<p>以上方法可以帮助你更好地掌控 Vuex Store 的状态，确保组件中能够及时响应 Store 中状态的变化。</p>
<p>我们也可以直接监听 Vuex Store 中的 count 属性，而不必声明额外的计算属性。<br>下面是使用 watch 监听 Vuex Store 中的 count 属性的示例代码：</p>
<p>Vue 组件代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前计数为: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">count</span>: <span class="built_in">this</span>.$store.state.count,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="string">&#x27;$store.state.count&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newCount, oldCount</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(<span class="string">&#x27;count属性的值发生了变化，新值为：&#x27;</span>, newCount)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(<span class="string">&#x27;旧值为：&#x27;</span>, oldCount)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.count = newCount</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>Vuex Store 代码同前面的示例。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Other</title>
    <url>/2023/07/04/notion/Other/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[[浅谈 “交浅言深” - 简书]]<br>[[1st Line Meeting]]<br>[[Top3 task]]<br>[[钉钉宜搭低代码平台分析报告]]<br>[[蓝色多瑙河-小约翰史特劳德]]</p>
]]></content>
      <categories>
        <category>notion</category>
      </categories>
  </entry>
  <entry>
    <title>自定义指令1</title>
    <url>/2023/06/24/Vue/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A41/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line">  <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  <span class="function"><span class="title">beforeMount</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  <span class="function"><span class="title">beforeUpdate</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line">  <span class="function"><span class="title">updated</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  <span class="function"><span class="title">beforeUnmount</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  <span class="function"><span class="title">unmounted</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="钩子参数​"><a href="#钩子参数​" class="headerlink" title="钩子参数​"></a>钩子参数<a href="https://cn.vuejs.org/guide/reusability/custom-directives.html#hook-arguments">​</a></h3><p>指令的钩子会传递以下几种参数：</p>
<ul>
<li><code>el</code>：指令绑定到的元素。这可以用于直接操作 DOM。</li>
<li><code>binding</code>：一个对象，包含以下属性。<ul>
<li>  <code>value</code>：传递给指令的值。例如在 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，值是 <code>2</code>。</li>
<li>  <code>oldValue</code>：之前的值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用。无论值是否更改，它都可用。</li>
<li>  <code>arg</code>：传递给指令的参数 (如果有的话)。例如在 <code>v-my-directive:foo</code> 中，参数是 <code>&quot;foo&quot;</code>。</li>
<li>  <code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如在 <code>v-my-directive.foo.bar</code> 中，修饰符对象是 <code>&#123; foo: true, bar: true &#125;</code>。</li>
<li>  <code>instance</code>：使用该指令的组件实例。</li>
<li>  <code>dir</code>：指令的定义对象。</li>
</ul>
</li>
<li><code>vnode</code>：代表绑定元素的底层 VNode。</li>
<li>  <code>prevNode</code>：之前的渲染中代表指令所绑定元素的 VNode。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>[object Object]</title>
    <url>/2023/06/24/Template/front-matter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Template</category>
      </categories>
  </entry>
  <entry>
    <title>Personal Home</title>
    <url>/2023/07/04/notion/Personal%20Home/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Personal-Home"><a href="#Personal-Home" class="headerlink" title="Personal Home"></a>Personal Home</h1><p><a href="https://indify.co/widgets/live/weather/hf8hgSJzeDCmsUGFgVeh">https://indify.co/widgets/live/weather/hf8hgSJzeDCmsUGFgVeh</a></p>
<p>Organize everything in your life in one place.</p>
<h2 id="Daily"><a href="#Daily" class="headerlink" title="Daily"></a>Daily</h2><hr>
<p>[[Movie List]]</p>
<p>[[Recipes]]</p>
<h2 id="Life"><a href="#Life" class="headerlink" title="Life"></a>Life</h2><hr>
<p>[[Yearly Goals]]</p>
<p>[[Travel Plans]]</p>
<p><a href="https://indify.co/widgets/live/quotes/S0KtrMv5J1IuvgwMLumH">https://indify.co/widgets/live/quotes/S0KtrMv5J1IuvgwMLumH</a></p>
<p><a href="https://indify.co/widgets/live/gallery/ejKdLPqWkfBHM5mCCnOH">https://indify.co/widgets/live/gallery/ejKdLPqWkfBHM5mCCnOH</a></p>
<p><a href="http://player.bilibili.com/player.html?aid=931519362&bvid=BV1uM4y1M77t&cid=368208679&page=1">http://player.bilibili.com/player.html?aid=931519362&amp;bvid=BV1uM4y1M77t&amp;cid=368208679&amp;page=1</a></p>
<p>[[ ]]</p>
<p>[[23周年庆]]</p>
<p>[[减肥日记]]</p>
<p>[[2021-2022]]</p>
<p>[[约会注意事项]]</p>
<p>[[随笔]]</p>
<p>[[金金的减肥日记]]</p>
<p>[[嵌入式开发入门指南]]</p>
]]></content>
      <categories>
        <category>notion</category>
      </categories>
  </entry>
  <entry>
    <title>学习</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>[[我的书库]]</p>
<p>[[Lessons]]</p>
<p>[[Projects]]</p>
<p>[[WebAssembly]]</p>
<p>[[Vue]]</p>
<p>[[Server]]</p>
<p>[[Docker]]</p>
<p>[[Javascript]]</p>
<p>[[Vim]]</p>
<p>[[Git]]</p>
<p>[[Java]]</p>
<p>[[Oral English]]</p>
<p>[[Web3]]</p>
<p>[[Block Chain]]</p>
<p>[[Database]]</p>
<p>[[Unity]]</p>
<p>[[Development]]</p>
<p>[[Long-term Target]]</p>
<p>[[Python]]</p>
]]></content>
      <categories>
        <category>notion</category>
      </categories>
  </entry>
  <entry>
    <title>工作</title>
    <url>/2023/07/04/notion/%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>[[Nexperia]]</p>
]]></content>
      <categories>
        <category>notion</category>
      </categories>
  </entry>
  <entry>
    <title>一级市场与二级市场</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E4%B8%80%E7%BA%A7%E5%B8%82%E5%9C%BA%E4%B8%8E%E4%BA%8C%E7%BA%A7%E5%B8%82%E5%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一级市场：投资者与上市公司交易的地方<br>二级市场：投资者与投资者交易的地方</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>A股，B股，H股</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/A%E8%82%A1%EF%BC%8CB%E8%82%A1%EF%BC%8CH%E8%82%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A股：注册地在大陆境内，上海或深圳交易所，人民币买卖股票<br>B股：注册地在大陆境内，上海或深圳交易所，美元或港币交易<br>H股：注册地在大陆境内，香港交易所，港币进行交易</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>上市公司与IPO</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E4%B8%8A%E5%B8%82%E5%85%AC%E5%8F%B8%E4%B8%8EIPO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IPO(首次公开募股)<br>IPO之后才是上市公司</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>公募基金与私募基金</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E5%85%AC%E5%8B%9F%E5%9F%BA%E9%87%91%E4%B8%8E%E7%A7%81%E5%8B%9F%E5%9F%BA%E9%87%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>私募基金只对指定人</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>基金的投资方向</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E5%9F%BA%E9%87%91%E7%9A%84%E6%8A%95%E8%B5%84%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>股票型基金<br>债券型基金<br>混合型基金<br>货币型基金</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>开放基金、封闭基金、ETF基金</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E5%BC%80%E6%94%BE%E5%9F%BA%E9%87%91%E3%80%81%E5%B0%81%E9%97%AD%E5%9F%BA%E9%87%91%E3%80%81ETF%E5%9F%BA%E9%87%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开放基金申购赎回不受时间限制<br>封闭基金在封闭期间无法赎回</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>炒股最小单位</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E7%82%92%E8%82%A1%E6%9C%80%E5%B0%8F%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一手：100股</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>注册制和核准制</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E6%B3%A8%E5%86%8C%E5%88%B6%E5%92%8C%E6%A0%B8%E5%87%86%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>核准制更严格，需要对公司价值做出评估</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>@media</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/@media/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>@media</strong> 规则在媒体查询中用于为不同的媒体类型/设备应用不同的样式。<br>媒体查询可用于检查许多事情，诸如：</p>
<blockquote>
<p>视口的宽度和高度<br>设备的宽度和高度<br>方向（手机或平板电脑处于横屏还是竖屏模式？）<br>分辨率</p>
</blockquote>
<h2 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h2><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>默认。用于所有媒体类型设备。</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机。</td>
</tr>
<tr>
<td>screen</td>
<td>用于计算机屏幕、平板电脑、智能手机等。</td>
</tr>
<tr>
<td>speech</td>
<td>用于朗读页面的屏幕阅读器。</td>
</tr>
</tbody></table>
<h2 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h2><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>any-hover</td>
<td>是否有任何可用的输入机制允许用户（将鼠标等）悬停在元素上？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>any-pointer</td>
<td>可用的输入机制中是否有任何指针设备，如果有，它的精度如何？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>aspect-ratio</td>
<td>视口（viewport）的宽高比。</td>
</tr>
<tr>
<td>color</td>
<td>输出设备每个像素的比特值，常见的有 8、16、32 位。如果设备不支持输出彩色，则该值为 0。</td>
</tr>
<tr>
<td>color-gamut</td>
<td>用户代理和输出设备大致程度上支持的色域。在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>color-index</td>
<td>输出设备的颜色查询表（color lookup table）中的条目数量。如果设备不使用颜色查询表，则该值为 0。</td>
</tr>
<tr>
<td>device-aspect-ratio</td>
<td>输出设备的宽高比。已在 Media Queries Level 4 中被弃用。</td>
</tr>
<tr>
<td>device-height</td>
<td>输出设备渲染表面（如屏幕）的高度。已在 Media Queries Level 4 中被弃用。</td>
</tr>
<tr>
<td>device-width</td>
<td>输出设备渲染表面（如屏幕）的宽度。已在 Media Queries Level 4 中被弃用。</td>
</tr>
<tr>
<td>display-mode</td>
<td>应用程序的显示模式，如 web app 的 manifest 中的 display 成员所指定在 Web App Manifest spec 被定义。</td>
</tr>
<tr>
<td>forced-colors</td>
<td>检测是用户代理否限制调色板。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>grid</td>
<td>输出设备使用网格屏幕还是点阵屏幕？</td>
</tr>
<tr>
<td>height</td>
<td>视口（viewport）的高度。</td>
</tr>
<tr>
<td>hover</td>
<td>主输入机制是否允许用户将鼠标悬停在元素上？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>inverted-colors</td>
<td>浏览器或者底层操作系统是否反转了颜色。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>light-level</td>
<td>当前环境光水平。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>max-aspect-ratio</td>
<td>显示区域的宽度和高度之间的最大比例。</td>
</tr>
<tr>
<td>max-color</td>
<td>输出设备每个颜色分量的最大位数。</td>
</tr>
<tr>
<td>max-color-index</td>
<td>设备可以显示的最大颜色数。</td>
</tr>
<tr>
<td>max-height</td>
<td>显示区域的最大高度，例如浏览器窗口。</td>
</tr>
<tr>
<td>max-monochrome</td>
<td>单色（灰度）设备上每种“颜色”的最大位数。</td>
</tr>
<tr>
<td>max-resolution</td>
<td>设备的最大分辨率，使用 dpi 或 dpcm。</td>
</tr>
<tr>
<td>max-width</td>
<td>显示区域的最大宽度，例如浏览器窗口。</td>
</tr>
<tr>
<td>min-aspect-ratio</td>
<td>显示区域的宽度和高度之间的最小比例。</td>
</tr>
<tr>
<td>min-color</td>
<td>输出设备每个颜色分量的最小位数。</td>
</tr>
<tr>
<td>min-color-index</td>
<td>设备可以显示的最小颜色数。</td>
</tr>
<tr>
<td>min-height</td>
<td>显示区域的最小高度，例如浏览器窗口。</td>
</tr>
<tr>
<td>min-monochrome</td>
<td>单色（灰度）设备上每种“颜色”的最小位数。</td>
</tr>
<tr>
<td>min-resolution</td>
<td>设备的最低分辨率，使用 dpi 或 dpcm。</td>
</tr>
<tr>
<td>min-width</td>
<td>显示区域的最小宽度，例如浏览器窗口。</td>
</tr>
<tr>
<td>monochrome</td>
<td>输出设备单色帧缓冲区中每个像素的位深度。如果设备并非黑白屏幕，则该值为 0。</td>
</tr>
<tr>
<td>orientation</td>
<td>视窗（viewport）的旋转方向（横屏还是竖屏模式）。</td>
</tr>
<tr>
<td>overflow-block</td>
<td>输出设备如何处理沿块轴溢出视口(viewport)的内容。在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>overflow-inline</td>
<td>沿内联轴溢出视口(viewport)的内容是否可以滚动？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>pointer</td>
<td>主要输入机制是一个指针设备吗？如果是，它的精度如何？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>prefers-color-scheme</td>
<td>探测用户倾向于选择亮色还是暗色的配色方案。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-contrast</td>
<td>探测用户是否有向系统要求提高或降低相近颜色之间的对比度。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-reduced-motion</td>
<td>用户是否希望页面上出现更少的动态效果。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-reduced-transparency</td>
<td>用户是否倾向于选择更低的透明度。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>resolution</td>
<td>输出设备的分辨率，使用 dpi 或 dpcm。</td>
</tr>
<tr>
<td>scan</td>
<td>输出设备的扫描过程（适用于电视等）。</td>
</tr>
<tr>
<td>scripting</td>
<td>探测脚本（例如 JavaScript）是否可用。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>update</td>
<td>输出设备更新内容的渲染结果的频率。在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>width</td>
<td>视窗（viewport）的宽度。</td>
</tr>
</tbody></table>
<h2 id="not、only-和-and-关键字的含义："><a href="#not、only-和-and-关键字的含义：" class="headerlink" title="not、only 和 and 关键字的含义："></a>not、only 和 and 关键字的含义：</h2><ol>
<li><strong>not</strong>：not 关键字反正整个媒体查询的含义。</li>
<li><strong>only</strong>：only 关键字可防止旧版浏览器应用指定的样式，这些浏览器不支持带媒体特性的媒体查询。它对现代浏览器没有影响。</li>
<li><strong>and</strong>：and 关键字将媒体特性与媒体类型或其他媒体特性组合在一起。</li>
</ol>
<p>它们都是可选的。但是，如果使用 not 或 only，则还必须指定媒体类型。</p>
<p>您还可以针对不同的媒体使用不同的样式表，就像这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width: 900px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;widescreen.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (max-width: 600px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;smallscreen.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-class">.example</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>@property</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/@property/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>@property是一个新增的CSS @规则(CSS at-rule)，它是<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini">CSS Houdini</a> API的一部分, 它允许开发者显式地定义css自定义属性，并允许进行属性类型检查、设定默认值以及定义该自定义属性是否可以被继承。@property可以直接在样式表中注册自定义属性，无需运行任何JS代码；同时也配备相应的JS语法注册自定义属性。@property自定义属性，是CSS变量(CSS variables)声明变量的升级版本，比CSS变量更加规范和严谨。</p>
<h2 id="基础语法规则"><a href="#基础语法规则" class="headerlink" title="基础语法规则"></a>基础语法规则</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> &lt;custom-property-name&gt; &#123;</span><br><span class="line">  &lt;declaration-list&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="declaration-list"><a href="#declaration-list" class="headerlink" title="declaration-list"></a>declaration-list</h3><p>声明字段包括 syntax 、inherits 和 initial-value</p>
<ol>
<li><strong>syntax</strong> ：类型string。定义自定义属性的类型。例如，number，color，percentage等</li>
<li><strong>inherits</strong>：类型boolean。定义自定义属性是否允许继承</li>
<li><strong>initial-value</strong>：类型符合 syntax 定义的类型，定义初始值</li>
<li><strong>syntax</strong> 和 <strong>inherits</strong> 描述符是必需的，其中任何一项缺失, 整条规则都将失效并且会被忽略</li>
<li><strong>initial-value</strong> 描述符仅在 syntax 描述符为通用syntax定义时是可选的，否则也是必需的</li>
</ol>
<h3 id="syntax-可用有效字段"><a href="#syntax-可用有效字段" class="headerlink" title="syntax 可用有效字段"></a>syntax 可用有效字段</h3><p>注册自定义属性时，可以使用CSS值和单位规范中的许多受支持的语法 - &lt; length &gt; - &lt; number &gt; - &lt; percentage &gt; - &lt; length-percentage &gt; - &lt; color &gt; - &lt; image &gt; - &lt; url &gt; - &lt; integer &gt; - &lt; angle &gt; - &lt; time &gt; - &lt; resolution &gt; - &lt; transform-list &gt; - &lt; transform-function &gt; - &lt; custom-ident &gt; (a custom identifier string)</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> --primary-color &#123;</span><br><span class="line">  syntax: <span class="string">&#x27;&lt;color&gt;&#x27;</span>;</span><br><span class="line">  inherits: false;</span><br><span class="line">  <span class="attribute">initial</span>-value: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    --primary-<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--primary-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/409933240">一起了解一下css新特性@property - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>@font-face</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/@font-face/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 单位</title>
    <url>/2023/07/22/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/CSS%20%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p><code>rem(root em)</code>是相对单位；rem单位是相对于HTML标签的字号计算结果；<code>1rem = 1HTML字号大小</code>。</p>
<p>如果<span style="background:#ff4d4f">html标签</span>的<strong>font-size是20px，那么1rem就是20</strong>。</p>
<h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p><strong>em(相对长度单位，相对于当前对象内文本的字体尺寸)<strong>：是一个相对长度单位，最初是指<code>字母M的宽度</code>，故名em。现指的是</strong>字符宽度的倍数</strong>，用法类似百分比，如：0.8em, 1.2em,2em等。通常1em=16px。em单位的大小是相对于<code>父元素</code>字体大小计算的，因此当父元素的字体大小设置改变时，em单位的值也会跟着变化。</p>
<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>**px (pixel，像素)**：是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果px要换算成物理长度，需要指定精度DPI(Dots Per Inch，每英寸像素数)，在扫描打印时一般都有DPI可选。Windows系统默认是96dpi，Apple系统默认是72dpi。</p>
<p><strong>px=1/dpi(英寸)</strong></p>
<h2 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h2><p>**pt (point，磅)**：是一个物理长度单位，指的是72分之一英寸。<code>pt=1/72(英寸), px=1/dpi(英寸)</code></p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>align-content,justify-content,align-items,justify-items</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/align-content,justify-content,align-items,justify-items/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>![[Pasted image 20230404194422.png]]</p>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><h2 id="Some-Questions"><a href="#Some-Questions" class="headerlink" title="Some Questions"></a>Some Questions</h2><h4 id="align-items-既能控制-flex-布局又能控制-grid-布局的对齐方向吗"><a href="#align-items-既能控制-flex-布局又能控制-grid-布局的对齐方向吗" class="headerlink" title="align-items 既能控制 flex 布局又能控制 grid 布局的对齐方向吗?"></a>align-items 既能控制 flex 布局又能控制 grid 布局的对齐方向吗?</h4><p><strong>答</strong>：是的，align-items 属性可以用于 flex 布局和 grid 布局，它们的作用是类似的，都是用来控制容器中的项目在交叉轴方向上的对齐方式。不过，它们也有一些区别，比如：</p>
<p>•  在 flex 布局中，交叉轴是与主轴垂直的轴，它的方向取决于 flex-direction 的值。在 grid 布局中，交叉轴是与网格行平行的轴，它的方向取决于 writing-mode 和 direction 的值。</p>
<p>•  在 flex 布局中，align-items 只能对齐单行或单列的 flex 项目，如果要对齐多行或多列的 flex 项目，需要使用 align-content 属性。在 grid 布局中，align-items 可以对齐任意数量的网格项，不需要使用 align-content 属性。</p>
<p>•  在 flex 布局中，align-items 的默认值是 stretch ，在 grid 布局中，align-items 的默认值是 normal </p>
<h4 id="什么是交叉轴？"><a href="#什么是交叉轴？" class="headerlink" title="什么是交叉轴？"></a>什么是交叉轴？</h4><p><strong>答</strong>：交叉轴是与主轴垂直的轴，它的方向取决于主轴的方向。在 flex 布局和 grid 布局中，交叉轴可以用来控制容器中的项目在垂直于主轴的方向上的对齐方式。(developer.mozilla.org)(developer.mozilla.org)</p>
<p>在 flex 布局中，如果主轴是水平方向（flex-direction: row 或 row-reverse），那么交叉轴就是从上至下地垂直走向的。如果主轴是垂直方向（flex-direction: column 或 column-reverse），那么交叉轴就是水平走向的。(developer.mozilla.org)(developer.mozilla.org)</p>
<p>在 grid 布局中，交叉轴是与网格行平行的轴，它的方向取决于 writing-mode 和 direction 的值。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>SVG</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/SVG/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是SVG"><a href="#什么是SVG" class="headerlink" title="什么是SVG"></a>什么是SVG</h2><p><strong>SVG（Scalable Vector Graphics）是一种基于 XML 的标记语言，用于描述二维矢量图形</strong>。简单地说，<font color="#76923c">SVG 之于图像就像 HTML 之于文本</font>。顾名思义，与光栅图像（JPG、GIF 和 PNG）不同，SVG 允许您在不损失图像质量的情况下任意放大或缩小矢量图像。</p>
<blockquote>
<ul>
<li>  SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
<li>  SVG 用来定义用于网络的基于矢量的图形</li>
<li>  SVG 使用 XML 格式定义图形</li>
<li>  SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li>
<li>  SVG 是万维网联盟的标准</li>
<li>  SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li>
</ul>
</blockquote>
<hr>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><blockquote>
<ul>
<li>  [[SVG]] 可被非常多的工具读取和修改（比如记事本）</li>
<li>  SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。</li>
<li>  SVG 是可伸缩的</li>
<li>  SVG 图像可在任何的分辨率下被高质量地打印</li>
<li>  SVG 可在图像质量不下降的情况下被放大</li>
<li>  SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）</li>
<li>  SVG 可以与 JavaScript 技术一起运行</li>
<li>  SVG 是开放的标准</li>
<li>  SVG 文件是纯粹的 XML</li>
</ul>
</blockquote>
<hr>
<h2 id="svg在html中"><a href="#svg在html中" class="headerlink" title="svg在html中"></a>svg在html中</h2><p>通过以下标签嵌入 HTML 文档：<code>&lt;embed&gt;</code>、<code>&lt;object&gt;</code> 或者 <code>&lt;iframe&gt;</code><br>也可以直接嵌入到HTML页面中，或您可以直接链接到SVG文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;circle1.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;circle1.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;circle1.svg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;40&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;red&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;circle1.svg&quot;</span>&gt;</span>查看 SVG 文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SVG矩形"><a href="#SVG矩形" class="headerlink" title="SVG矩形"></a>SVG矩形</h2><p><code>&lt;rect&gt;</code> 标签可用来创建矩形，以及矩形的变种</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  rect 元素的 width 和 height 属性可定义矩形的高度和宽度</li>
<li>  style 属性用来定义 CSS 属性</li>
<li>  CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）</li>
<li>  CSS 的 stroke-width 属性定义矩形边框的宽度</li>
<li>  CSS 的 stroke 属性定义矩形边框的颜色</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;fill:blue; stroke :pink;stroke-width:5;fill-opacity:0.1;  </span></span></span><br><span class="line"><span class="string"><span class="tag">  stroke-opacity:0.9&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  x 属性定义矩形的左侧位置（例如，x=”0” 定义矩形到浏览器窗口左侧的距离是 0px）</li>
<li>  y 属性定义矩形的顶端位置（例如，y=”0” 定义矩形到浏览器窗口顶端的距离是 0px）</li>
<li>  CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1）</li>
<li>  CSS 的 stroke-opacity 属性定义轮廓颜色的透明度（合法的范围是：0 - 1）</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;fill:blue; stroke :pink;stroke-width:5;opacity:0.5&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  CSS opacity 属性用于定义了元素的透明值 (范围: 0 到 1)。</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;20&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;20&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;fill:red; stroke :black;stroke-width:5;opacity:0.5&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  rx 和 ry 属性可使矩形产生圆角。</li>
</ul>
</blockquote>
<h2 id="SVG圆形"><a href="#SVG圆形" class="headerlink" title="SVG圆形"></a>SVG圆形</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;40&quot;</span> <span class="attr">stroke</span> =<span class="string">&quot;black&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;red&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  cx和cy属性定义圆点的x和y坐标。如果省略cx和cy，圆的中心会被设置为(0, 0)</li>
<li>  r属性定义圆的半径</li>
</ul>
</blockquote>
<h2 id="SVG椭圆"><a href="#SVG椭圆" class="headerlink" title="SVG椭圆"></a>SVG椭圆</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;300&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;80&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;50&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:yellow; stroke :purple;stroke-width:2&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  CX属性定义的椭圆中心的x坐标</li>
<li>  CY属性定义的椭圆中心的y坐标</li>
<li>  RX属性定义的水平半径</li>
<li>  RY属性定义的垂直半径</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;240&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;100&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;220&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;30&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:purple&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;220&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;70&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;190&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;20&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:lime&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;210&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;45&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;170&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;15&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:yellow&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;240&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;220&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;30&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:yellow&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;220&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;190&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;20&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:white&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SVG直线"><a href="#SVG直线" class="headerlink" title="SVG直线"></a>SVG直线</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;200&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot; stroke :rgb(255,0,0);stroke-width:2&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  x1 属性在 x 轴定义线条的开始</li>
<li>  y1 属性在 y 轴定义线条的开始</li>
<li>  x2 属性在 x 轴定义线条的结束</li>
<li>  y2 属性在 y 轴定义线条的结束</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>hsl()和hsla()</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/hsl()%E5%92%8Chsla()/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="hsl"><a href="#hsl" class="headerlink" title="hsl()"></a>hsl()</h2><p><strong>HSL</strong> 即：<strong>色相</strong>（Hue）、<strong>饱和度</strong>（ Saturation ）、<strong>亮度</strong>（ Lightness ）。</p>
<blockquote>
<p>色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。<br>饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取0 ~ 100%的数值。<br>亮度（L），取0 ~ 100%，增加亮度，颜色会向白色变化；减少亮度，颜色会像黑色变化。</p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hue - 色相</td>
<td>定义色相（0到360）-0（或360）为红色，120为绿色，240为蓝色</td>
</tr>
<tr>
<td>saturation - 饱和度</td>
<td>定义饱和度；0%为灰色，100%全白</td>
</tr>
<tr>
<td>lightness - 亮度</td>
<td>定义亮度0%为暗，50%为普通，100%为白</td>
</tr>
</tbody></table>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hsl(hue, saturation , lightness); </span><br></pre></td></tr></table></figure>

<h2 id="hsla"><a href="#hsla" class="headerlink" title="hsla()"></a>hsla()</h2><p><strong>HSLA</strong> 即：色相、饱和度、亮度、<strong>透明度</strong>（英语：Hue, Saturation , Lightness , Alpha ）。</p>
<blockquote>
<p>透明度（A） 取值 0~1 之间， 代表透明度。</p>
</blockquote>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hsla(hue, saturation , lightness ,alpha)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>focus-visible 和 focus</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/focus-visible%20%E5%92%8C%20focus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>focus-visible</strong>用于使用键盘获得焦点时显示的样式</p>
<p><strong>focus</strong>用于使用鼠标时获得焦点显示的样式</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>inherited和initial</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/inherited%E5%92%8Cinitial/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>任何样式都有两种值，一种加 inherited ，一种叫initial</p>
<h2 id="inherited"><a href="#inherited" class="headerlink" title="inherited"></a>inherited</h2><p>有些样式会被子元素继承但是有些样式无法被默认继承，则可以通过inherited自动要求继承，如<code>border</code><br>![[Pasted image 20230402203738.png]]<br>![[Pasted image 20230402203657.png]]</p>
<h2 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h2><p>采用浏览器默认样式，不接受被动继承来的样式</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>可变字体</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8F%AF%E5%8F%98%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>-</p>
<h2 id="什么是可变字体"><a href="#什么是可变字体" class="headerlink" title="什么是可变字体"></a>什么是可变字体</h2><p><a href="https://new.qq.com/rain/a/20220304A04WFS00">突破限制，CSS font-variation 可变字体的魅力_腾讯新闻 (qq.com)</a></p>
<p>根据 MDN – Variable fonts，可变字体（Variable fonts）是 OpenType 字体规范上的演进，它允许将同一字体的多个变体统合进单独的字体文件中。从而无需再将不同字宽、字重或不同样式的字体分割成不同的字体文件。<strong>我们只需通过CSS与一行 @font-face 引用，即可获取包含在这个单一文件中的各种字体变体。</strong><br>与可变字体对应的，是标准（静态）字体。</p>
<p><strong>标准（静态）字体就是只代表字体的某一特定的宽度/字重/样式的组合的字体文件</strong>，通常我们在页面引入的字体文件都是这种，只代表这个字体的某一特定的宽度/字重/样式的组合。</p>
<p>而如果我们想引入一个字体家族（譬如 Roboto 字体族），它可能包含了 “Roboto Regular”(常规字重)、“Roboto Bold”（粗体），或是 “Roboto Bold Italic”（粗体+斜体） 等一系列字体文件。这意味着我们可能需要 20 或 30 个不同的字体文件才能算是有了一整个字体家族（对于有着不同宽度的大型字体来说，这个数量还要翻上几倍）。</p>
<p>而可变字体 —— font-variation，可以将它理解为 all in one，通过使用可变字体，所有字重、字宽、斜体等情况的排列组合都可以被装进一个文件中。当然，这个文件可能比常规的单个字体文件大一些。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>font-variation 的可变轴 —— <font color="#76923c">注册轴与自定义轴</font></p>
<p>回归到可变字体本身。上面提到了可变轴这个概念，它们分为注册轴与自定义轴，英文是：</p>
<ol>
<li>注册轴 - registered axes</li>
<li>自定义轴 - custom axes</li>
</ol>
<p>可变字体新格式的核心是可变轴的概念，其描述了字体设计中某一特性的允许变化范围。</p>
<blockquote>
<p>例如:<br>‘<strong>字重轴</strong>’描述了字体的粗细；<br>“<strong>宽度轴</strong>” 描述了字体的宽窄；<br>“<strong>斜体轴</strong>” 描述是否使用斜体字形并且可相应地开关等。<br>请注意，轴既可以是范围选择又可以是开关选择。字重可能在 1-999 之间，而斜体可能只是简单的 0 或 1（关闭或打开）。</p>
</blockquote>
<p>如规范中所定义，存在两种变形轴，注册轴和自定义轴：<br>注册轴最为常见，常见到制定规范的作者认为有必要进行标准化。<br>目前注册的五个轴是<strong>字重，宽度，倾斜度，斜体和光学尺寸</strong>。</p>
<p>上文其实已经罗列了 5 个注册轴，并且简单介绍了它们的使用。再罗列一次：</p>
<blockquote>
<p>**字重轴 “wght”**：对应 font-weight，控制字体的粗细<br>**宽度轴 “wdth”**：对应 font-stretch，控制字体的伸缩<br>**斜度轴 “slnt” (slant)**：对应字体的 font-style: oblique + angle，控制字体的倾斜<br>**斜体轴 “ital”**：对应字体的 font-style: italic，控制字体的倾斜（注意，和 font-style: oblique 是不一样的倾斜）<br>**光学尺寸轴 “opsz”**：对应字体的 font-optical-sizing，控制字体的光学尺寸</p>
</blockquote>
<hr>
<p>自定义轴实际上是无限的：字体设计师可以定义和界定他们喜欢的任何轴，并且只需要给它一个四个字母的标签以在字体文件格式本身中识别它。<br>我们来看一个 自定义轴 的例子：</p>
<p>上述 font-family: “Amstelvar VF” 是一个可变字体，而’GRAD’ 属于自定义轴的一个，意为等级轴。<br>等级轴’GRAD’：“等级”一词指的是字体设计的相对重量或密度，但与传统的 “重量” 不同之处在于文本占据的物理空间不会改变，因此改变文本等级并不会改变文本或其周围元素的整体布局。这使得等级成为有用的变化轴，因为它可以变化或动画而不会引起文本本身的回流。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>place-items</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/place-items/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 中的 <strong><code>place-items</code></strong> 是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties">简写属性</a> ，它允许你在相关的布局（如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout">Grid</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">Flexbox</a>）中可以同时沿着块级和内联方向对齐元素 (例如：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-items"><code>justify-items</code></a> 属性) 。如果未提供第二个值，则第一个值作为第二个值的默认值。</p>
<blockquote>
<p><strong>先竖后横</strong></p>
</blockquote>
<h2 id="构成属性"><a href="#构成属性" class="headerlink" title="构成属性"></a>构成属性</h2><p>该属性是以下两个 CSS 属性的简写：</p>
<ul>
<li>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a></li>
<li>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-items"><code>justify-items</code></a></li>
</ul>
<h2 id="形式语法"><a href="#形式语法" class="headerlink" title="形式语法"></a>形式语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items =   </span><br><span class="line">  &lt;&#x27;<span class="attribute">align-items</span>&#x27;&gt; &lt;&#x27;justify-items&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><ul>
<li><code>auto</code></li>
</ul>
<p><code>auto</code> 实际的值继承父自元素的 <code>justify-items</code> 值，除非该元素没有父元素或是用了绝对定位。在这些示例中，<code>auto</code> 表示 <code>normal</code> 。</p>
<ul>
<li><code>normal</code></li>
</ul>
<p><code>normal</code> 的效果取决于我们使用哪种布局方式：</p>
<p>  在块级布局中，<code>normal</code> 和 <code>start</code> 一样。<br>  在绝对定位布局中，关键字在_被替换的_绝对定位元素上的行为类似于 <code>start</code>，在_所有其他_绝对定位的元素上表现类似 <code>stretch</code>。<br>  在表格单元格布局中，此关键字没有意义，因为该属性_被忽略_。<br>  在 flexbox 布局中，此关键字没有意义，因为该属性_被忽略_。<br>  在 grid 布局中，此关键字和 <code>stretch</code> 的行为相似，但是具有宽高比和固有尺寸的元素行为和 <code>start</code> 相似。</p>
<ul>
<li><code>start</code></li>
</ul>
<p>在适当的轴线上，元素块沿着对齐容器的起始边缘对齐。</p>
<ul>
<li><code>end</code></li>
</ul>
<p>在适当的轴线上，元素块沿着对齐容器的结束边缘对齐。</p>
<ul>
<li><code>flex-start</code></li>
</ul>
<p>对齐方式取决于 flex 容器的的开始方向。（水平和垂直两个方向） 这只对 flex 布局元素生效，对于不是 flex 容器的子元素，它被视为 <code>start</code> 。</p>
<ul>
<li><code>flex-end</code></li>
</ul>
<p>对齐方式取决于 flex 容器的的结束方向。（水平和垂直两个方向） 这只对 flex 布局元素生效，对于不是 flex 容器的子元素，它被视为 end。</p>
<ul>
<li><code>self-start</code></li>
</ul>
<p>沿着轴线的头部对齐。</p>
<ul>
<li><code>self-end</code></li>
</ul>
<p>沿着轴线的尾部对齐。</p>
<ul>
<li><code>center</code></li>
</ul>
<p>沿着对齐容器的中心对齐。</p>
<ul>
<li><code>left</code></li>
</ul>
<p>沿着对齐容器的左侧对齐，如果属性的轴不与内联轴平行，则该值的行为和 <code>start</code> 类似。</p>
<ul>
<li><code>right</code></li>
</ul>
<p>沿着对齐容器的右侧对齐，如果属性的轴不与内联轴平行，则该值的行为和 <code>start</code> 类似。</p>
<ul>
<li><code>baseline first baseline</code> <code>last baseline</code></li>
</ul>
<p>指定参与第一个或最后一个基线对齐：元素的第一个或最后一个基线集的对齐基线与基线共享组中所有框共享的第一个或最后一个基线集中相应的基线对齐。 <code>first baseline</code> 的回退对齐方式为 <code>start</code> ，<code>last baseline</code> 则为 <code>end</code>。</p>
<ul>
<li><code>stretch</code></li>
</ul>
<p>如果子项加起来的尺寸小于对齐容器的尺寸，则任何未尺寸为 <code>auto</code> 的项将增加同等的大小（不是按比例），但也会受到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-height"><code>max-height</code></a>/<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a> （或等同的功能）的限制，因此所有项刚好能填满对齐容器。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>自定义属性</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是自定义变量"><a href="#什么是自定义变量" class="headerlink" title="什么是自定义变量"></a>什么是自定义变量</h2><p>自定义属性（有时也被称作CSS变量或者级联变量）是由CSS作者定义的，它包含的值可以在整个文档中重复使用。<br>由自定义属性标记设定值（比如： –main-color: black;），由 var() 函数来获取值（比如： color: var(–main-color);）<br>复杂的网站都会有大量的CSS代码，通常也会有许多重复的值。<br>举例：同样一个颜色值可能在成千上百个地方被使用到，如果这个值发生了变化，需要全局搜索并且一个一个替换。<br>自定义属性在某个地方存储一个值，然后在其他许多地方引用它。另一个好处是语义化的标识。<br>如：–main-text-color 会比 <code>#00ff00</code> 更易理解，尤其是这个颜色值在其他上下文中也被使用到。<br>自定义属性受级联的约束，并从其父级继承其值。</p>
<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>声明一个自定义属性，属性名需要以两个减号（–）开始，属性值则可以是任何有效的CSS值。<br>和其他属性一样，自定义属性也是写在规则集之内的，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">element &#123;</span><br><span class="line">  --<span class="selector-tag">main</span>-bg-<span class="attribute">color</span>: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：规则集所指定的选择器定义了自定义属性的可见作用域。<br>通常的最佳实践是定义在根伪类 :root 下，这样就可以在HTML文档的任何地方访问到它了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --<span class="selector-tag">main</span>-<span class="attribute">color</span>: red;</span><br><span class="line">  --bg-<span class="attribute">color</span>: pink;</span><br><span class="line">  --<span class="selector-tag">main</span>-<span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这条规则不是绝对的，如果有理由去限制你的自定义属性，那么就应该限制。</p>
<blockquote>
<p>注意：自定义属性名是大小写敏感的。 –my-color 和 –My-color 会被认为是两个不同的自定义属性。</p>
</blockquote>
<h2 id="var-函数"><a href="#var-函数" class="headerlink" title="var() 函数"></a>var() 函数</h2><p>读取变量</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。<br>==第二个参数不处理内部的逗号或空格，都视作参数的一部分。==</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">var</span>(--el-height,<span class="number">400px</span>);</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="built_in">var</span>(--font-stack, <span class="string">&quot;Roboto&quot;</span>, <span class="string">&quot;Helvetica&quot;</span>);</span><br><span class="line">  <span class="attribute">padding</span>:<span class="built_in">var</span>(--pad, <span class="number">10px</span> <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的声明</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --length: <span class="number">400px</span>;</span><br><span class="line">  --mian-<span class="attribute">width</span>:<span class="built_in">var</span>(--length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：变量值只能用作属性值，不能用作属性名。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  --side: margin-top;</span><br><span class="line">  <span class="selector-tag">var</span>(--side): <span class="number">20px</span>;  <span class="comment">/* 无效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>rm</title>
    <url>/2023/06/24/Linux/%E5%91%BD%E4%BB%A4/rm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.runoob.com/linux/linux-command-manual.html"><img src="https://www.runoob.com/images/up.gif" alt="Linux 命令大全"> Linux 命令大全</a></p>
<p>Linux rm（英文全拼：remove）命令用于删除一个文件或者目录。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [options] name...</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong>：</p>
<ul>
<li>  -i 删除前逐一询问确认。</li>
<li>  -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li>
<li>  -r 将目录及以下之档案亦逐一删除。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  test.txt </span><br></pre></td></tr></table></figure>
<p>rm：是否删除 一般文件 “test.txt”? y  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  homework</span><br></pre></td></tr></table></figure>
<p>rm: 无法删除目录”homework”: 是一个目录  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -r  homework  </span><br></pre></td></tr></table></figure>
<p>rm：是否删除 目录 “homework”? y </p>
<p>删除当前目录下的所有文件及目录，命令行为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -r  * </span><br></pre></td></tr></table></figure>
<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>删除当前目录下的所有文件及目录，并且是直接删除，无需逐一确认命令行为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -rf  要删除的文件名或目录</span><br></pre></td></tr></table></figure>
<p>删除文件名 test.txt:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -rf   test.txt</span><br></pre></td></tr></table></figure>
<p>删除目录 test，不管该目录下是否有子目录或文件，都直接删除:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -rf   test/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>命令</category>
      </categories>
  </entry>
  <entry>
    <title>2. 第一步</title>
    <url>/2023/07/19/Node/NestJS/2.%20%E7%AC%AC%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>在这组文章中，您将学习Nest的核心基础知识。为了熟悉Nest应用程序的基本构建块，我们将构建一个基本的CRUD应用程序，其功能涵盖了入门级的许多基础知识。</p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>Nest利用了最新的语言特性，所以要在普通JavaScript中使用它，我们需要一个Babel编译器。</p>
<p>在我们提供的示例中，我们将主要使用TypeScript，但你也可以将代码片段切换为普通的JavaScript语法(只需单击每个代码片段右上角的语言按钮即可)。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>请确保在您的操作系统上安装了Node.js(<strong>版本&gt;= 16</strong>)。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Nest CLI设置新项目非常简单。安装npm后，你可以在你的操作系统终端上用下面的命令创建一个新的Nest项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i -g @nestjs/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nest new project-name</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>要用TypeScript更严格的特性集创建一个新项目，把<code>--strict</code>标志传递给<code>nest new</code>命令。</p>
</blockquote>
<p>将创建<code>project-name</code>目录，安装节点模块和其他一些样板文件，并创建一个<code>src/</code>目录并填充几个核心文件。</p>
<blockquote>
<p>src<br>|——app.controller.spec.ts<br>|——app.controller.ts<br>|——app.module.ts<br>|——app.service.ts<br>|——main.ts</p>
</blockquote>
<p>以下是这些核心文件的简要概述:</p>
<p><code>app.controller.ts</code></p>
<p>具有单个路由的基本控制器。</p>
<hr>
<p><code>app.controller.spec.ts</code></p>
<p>控制器的单元测试。</p>
<hr>
<p><code>app.module.ts</code></p>
<p>应用程序的根模块。</p>
<hr>
<p><code>app.service.ts</code></p>
<p>使用单一方法的基本服务。</p>
<hr>
<p><code>main.ts</code></p>
<p>应用程序的入口文件，它使用核心函数<code>NestFactory</code>来创建一个Nest应用程序实例。</p>
<hr>
<p><code>main.ts</code>包含一个<code>async</code>函数，它将引导我们的应用程序:</p>
<figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure>

<p>要创建一个Nest应用程序实例，我们使用核心的<code>NestFactory</code>类。<code>NestFactory</code>公开了一些允许创建应用程序实例的静态方法。<code>create()</code>方法返回一个应用程序对象，该对象满足<code>INestApplication</code>接口。这个对象提供了一组方法，这些方法将在后面的章节中描述。基本上。在上面的例子中，我们只需启动HTTP侦听器，让应用程序等待入站HTTP请求。</p>
<p>请注意，使用 <code>Nest CLI</code> 搭建的项目会创建一个初始项目结构，鼓励开发人员遵循将每个模块保留在其自己的专用目录中的约定。</p>
<blockquote>
<p>[!hint]<br>默认情况下，如果在创建应用程序时发生任何错误，应用程序将以代码<code>1</code>退出。如果你想让它抛出一个错误，那就不能禁用选项<code>abortOnError</code>(例如，<code>NestFactory.create(AppModule， &#123;abortOnError: false&#125;)</code>)。</p>
</blockquote>
<h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>Nest的目标是成为一个平台无关的框架。平台独立性使得创建可重用的逻辑部分成为可能，开发人员可以跨几种不同类型的应用程序利用这些逻辑部分。从技术上讲，一旦创建了适配器，Nest就能够与任何Node HTTP框架一起工作。有两种开箱即用的HTTP平台:express和fastify。你可以选择一个最适合你需要的。</p>
<p><code>platform-express</code></p>
<p><a href="https://expressjs.com/">Express</a>是一个著名的node极简web框架。它是一个经过实战测试的、可用于生产的库，其中包含许多由社区实现的资源。默认情况下使用<code>@nestjs/platform-express</code>包。许多用户都可以很好地使用Express，并且不需要采取任何操作来启用它。</p>
<hr>
<p><code>platform-fastify</code></p>
<p><a href="https://www.fastify.io/">Fastify</a>是一个高性能和低开销的框架，高度专注于提供最大的效率和速度。点击<a href="https://docs.nestjs.com/techniques/performance">这里</a>阅读如何使用它。</p>
<p>无论使用哪种平台，它都公开自己的应用程序接口。它们分别被看作是<code>NestExpressApplication</code>和<code>NestFastifyApplication</code>。</p>
<p>当你将一个类型传递给<code>NestFactory.create()</code>方法时，如下面的例子所示，应用对象将拥有专门用于该特定平台的方法。但是请注意，除非您确实想要访问底层平台API，否则您不需要指定类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>安装过程完成后，您可以在操作系统命令提示符下运行以下命令，启动侦听入站HTTP请求的应用程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm run start</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]+<br>为了加快开发过程(构建速度提高20倍)，您可以通过向启动脚本传递<code>-b swc</code>标志来使用<a href="https://docs.nestjs.com/recipes/swc">SWC构建器</a>，如下所示:<code>npm run start -- -b swc</code>。</p>
</blockquote>
<p>该命令启动应用时，HTTP服务器监听<code>src/main.ts</code>中定义的端口。应用程序运行后，打开浏览器并导航到<a href="http://localhost:3000/">http://localhost:3000/</a>。您应该看到<code>Hello World!</code>消息。</p>
<p>要观察文件中的变化，可以运行以下命令来启动应用程序:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run start:dev</span><br></pre></td></tr></table></figure>

<p>该命令将监视您的文件，自动重新编译并重新加载服务器(<strong>热重载</strong>)。</p>
<h2 id="Linting-和-formatting"><a href="#Linting-和-formatting" class="headerlink" title="Linting 和 formatting"></a>Linting 和 formatting</h2><p><a href="https://docs.nestjs.com/cli/overview">CLI</a>尽最大努力构建可靠的大规模开发工作流。因此，生成的Nest项目附带了预安装的代码检查器和格式化器(分别是<a href="https://eslint.org/">eslint</a><a href="https://prettier.io/">和prettier</a>)。</p>
<blockquote>
<p>[!hint]+<br>不确定formatters和linters的作用?在<a href="https://prettier.io/docs/en/comparison.html">这里</a>了解它们的区别。</p>
</blockquote>
<p>为了确保最大的稳定性和可扩展性，我们使用了基本的<code>eslint</code>和<code>prettier</code>的cli包。这种设置允许通过设计将IDE与官方扩展集成在一起。</p>
<p>对于没有IDE的环境(持续集成、Git钩子等)，Nest项目提供了现成的npm脚本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Lint and autofix with eslint</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run lint</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Format with prettier</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run format</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>new Date()</title>
    <url>/2023/06/24/JS/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/new%20Date()/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>![[Pasted image 20230619221916.png]]<br><a href="https://juejin.cn/post/7221884988492382267">new Date() 我忍你很久了！ - 掘金 (juejin.cn)</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>小知识点</category>
      </categories>
  </entry>
  <entry>
    <title>1. 介绍</title>
    <url>/2023/07/19/Node/NestJS/1.%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Nest (NestJS)是一个用于构建高效、可扩展的Node.js服务器端应用程序的框架。它使用渐进式JavaScript，构建并完全支持TypeScript(但仍然允许开发人员使用纯JavaScript编写代码)，并结合了OOP(面向对象编程)，FP(函数式编程)和FRP(函数式响应式编程)的元素。</p>
<p>在底层，Nest使用了健壮的HTTP服务器框架，比如<code>Express</code>(默认的)，也可以选择配置使用<code>fasttify</code> !</p>
<p>Nest在这些常见的Node.js框架(Express/ fasttify)之上提供了一个抽象层次，但也直接向开发人员公开了它们的api。这使得开发人员可以自由地使用底层平台可用的无数第三方模块。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>近年来，由于Node.js, JavaScript已经成为web前端和后端应用程序的“通用语言”。这催生了像<code>Angular、React和Vue</code>这样令人敬畏的项目，它们提高了开发人员的生产力，并使创建快速、可测试和可扩展的前端应用成为可能。然而，尽管有大量优秀的库、助手和工具用于Node(和服务器端JavaScript)，但它们都没有有效地解决架构的主要问题。</p>
<p>Nest提供了一种开箱即用的应用程序架构，允许开发人员和团队创建高度可测试、可扩展、松耦合和易于维护的应用程序。架构很大程度上受到了Angular的启发。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，您可以使用<a href="https://docs.nestjs.com/cli/overview">Nest CLI</a>构建项目，也可以克隆一个初始项目(两者都会产生相同的结果)。</p>
<p>要使用Nest CLI构建项目，请运行以下命令。这将创建一个新的项目目录，并用初始核心Nest文件和支持模块填充该目录，为您的项目创建一个常规的基本结构。建议首次使用Nest CLI创建新项目。我们将在第一步中继续使用这种方法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i -g @nestjs/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nest new project-name</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>要创建一个具有更严格特性集的新TypeScript项目，将——strict标志传递给下一个新命令。</p>
</blockquote>
<h2 id="替代选择"><a href="#替代选择" class="headerlink" title="替代选择"></a>替代选择</h2><p>或者，用Git安装TypeScript starter项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/nestjs/typescript-starter.git project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run start</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>如果想克隆没有git历史记录的存储库，可以使用degit。</p>
</blockquote>
<p>打开浏览器并导航到<a href="http://localhost:3000/">http://localhost:3000/</a>。</p>
<p>要安装启动器项目的JavaScript版本，请使用<code>javascript-starter.git</code>在上面的命令序列中。</p>
<p>你也可以用npm(或yarn)安装核心和支持文件，从头开始手动创建一个新项目。当然，在这种情况下，您将负责自己创建项目样板文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i --save @nestjs/core @nestjs/common rxjs reflect-metadata</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>3. Controller</title>
    <url>/2023/07/20/Node/NestJS/3.%20Controller/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>控制器负责处理传入的请求并向客户端返回响应。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250926656.png" alt="image.png"></p>
<p>控制器的目的是接收应用程序的特定请求。路由机制控制哪个控制器接收哪些请求。通常情况下，每个控制器都有多条路由，不同的路由可以执行不同的动作。</p>
<p>为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据关联起来，并使Nest能够创建路由映射(将请求绑定到相应的控制器)。</p>
<p>为了快速创建带有内置验证的CRUD控制器，您可以使用CLI的CRUD生成器:<code>nest g resource [name]</code>。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在下面的示例中，我们将使用<code>@Controller()</code>装饰器，它是定义基本控制器所必需的。我们将指定一个可选的路由路径前缀<code>cats</code>。在<code>@Controller()</code>装饰器中使用路径前缀可以让我们轻松地对一组相关的路由进行分组，并尽量减少重复的代码。例如，我们可以选择将一组管理与cat实体交互的路由分组在路由<code>/cats</code>下。在这种情况下，我们可以在<code>@Controller()</code>装饰器中指定路径前缀<code>cats</code>，这样我们就不必为文件中的每个路由重复路径的那一部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  findAll(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action returns all cats&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>使用命令行创建控制器，只需执行<code>$ nest g controller [name]</code>命令。</p>
</blockquote>
<p><code>findAll()</code>方法之前的<code>@Get()</code> HTTP请求方法装饰器告诉Nest为HTTP请求的特定端点创建处理程序。端点对应于HTTP请求方法(在本例中为GET)和路由路径。路线是什么?处理程序的路由路径是通过连接为控制器声明的(可选的)前缀和方法装饰器中指定的任何路径来确定的。因为我们已经为每个路由声明了一个前缀(cats)，并且没有在装饰器中添加任何路径信息，所以Nest会将GET <code>/cats</code>请求映射到这个处理程序。如前所述，该路径既包括可选的控制器路径前缀，也包括在请求方法装饰器中声明的任何路径字符串。例如，一个由cats组成的路径前缀加上装饰器<code>@Get(&#39;breed&#39;)</code>，就会为GET <code>/cats/breed</code>这样的请求生成一个路由映射。</p>
<p>在上面的示例中，当向该端点发出GET请求时，Nest将请求路由到用户定义的<code>findAll()</code>方法。注意，我们在这里选择的方法名是完全任意的。显然，我们必须声明一个方法来绑定路由，但是Nest对所选择的方法名不在意。</p>
<p>该方法将返回一个200状态码和相关的响应，在本例中只是一个字符串。为什么会这样呢?为了解释这一点，我们将首先介绍Nest使用两种不同选项来操纵响应的概念:</p>
<hr>
<p><code>Standard (recommended)</code></p>
<p>使用这个内置方法，当请求处理程序返回JavaScript对象或数组时，它将自动序列化为JSON。然而，当它返回一个JavaScript基本类型(例如，字符串，数字，布尔值)时，Nest将只发送值而不尝试序列化它。这使得响应处理变得简单:只返回值，Nest负责其余的工作。</p>
<p>此外，响应的状态码默认总是<code>200</code>，除了使用<code>201</code>的POST请求。我们可以通过在处理程序级别添加<code>@HttpCode(…)</code>装饰器来轻松改变这种行为(参见<a href="https://docs.nestjs.com/controllers#status-code">状态代码</a>)。</p>
<hr>
<p><code>Library-specific</code></p>
<p>我们可以使用特定于库的(例如Express)响应对象，它可以使用方法处理程序签名中的@Res()装饰器注入(例如findAll(@Res() response))。通过这种方法，您可以使用该对象公开的本机响应处理方法。例如，对于Express，您可以使用<code>response.status(200).send()</code>这样的代码来构造响应。</p>
<hr>
<blockquote>
<p>[!warning]<br>Nest检测处理程序何时使用@Res()或@Next()，指示您选择了<code>library-specific</code>选项。如果同时使用这两种方法，标准方法将自动对这条路由禁用，并且不再像预期的那样工作。要同时使用这两种方法(例如，通过注入响应对象来只设置cookie /headers，而将其余部分留给框架)，你必须在<code>@Res(&#123;passthrough: true&#125;)</code>装饰器中将<code>passthrough</code>选项设置为true。</p>
</blockquote>
<h2 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h2><p>处理程序通常需要访问客户端请求的详细信息。Nest提供对底层平台(默认情况下是Express)的请求对象的访问。我们可以通过在处理器的签名中添加<code>@Req()</code>装饰器来指示Nest注入请求对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Req &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  findAll(@Req() request: Request): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action returns all cats&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>为了利用express类型(如上面的<code>request: Request</code>参数示例)，安装<code>@types/express</code>包。</p>
</blockquote>
<p>请求对象表示HTTP请求，并具有请求查询字符串、参数、HTTP头和正文的属性(在这里阅读更多内容)。在大多数情况下，不需要手动获取这些属性。我们可以使用专门的装饰器，比如<code>@Body()</code>或<code>@Query()</code>，它们都是现成的。下面是所提供的装饰器和它们所代表的平台特定对象的列表。</p>
<table>
<thead>
<tr>
<th>decorator</th>
<th>object</th>
</tr>
</thead>
<tbody><tr>
<td>@Request(),@Req()</td>
<td>req</td>
</tr>
<tr>
<td>@Response(),@Res()*</td>
<td>res</td>
</tr>
<tr>
<td>@Next</td>
<td>next</td>
</tr>
<tr>
<td>@Session</td>
<td>req.session</td>
</tr>
<tr>
<td>@Param(key?:string)</td>
<td>req.params / req.params[key]</td>
</tr>
<tr>
<td>@Body(key?:string)</td>
<td>req.body / req.body[key]</td>
</tr>
<tr>
<td>@Query(key?:string)</td>
<td>req.query / req.query[key]</td>
</tr>
<tr>
<td>@Header(name?:string)</td>
<td>req.ip</td>
</tr>
<tr>
<td>@HostParam()</td>
<td>req.hosts</td>
</tr>
</tbody></table>
<p>为了兼容底层HTTP平台(例如Express和fasttify)的类型，Nest提供了<code>@Res()</code>和<code>@Response()</code>装饰器。<code>@Res()</code>只是<code>@Response()</code>的别名。两者都直接公开底层的本机平台响应对象接口。在使用它们时，您还应该导入底层库的类型(例如，<code>@types/express</code>)以充分利用它们。请注意，当您在方法处理程序中注入<code>@Res()</code>或<code>@Response()</code>时，您将为该处理程序将Nest置于<code>Library-specific</code>模式，并且您将负责管理响应。当这样做时，你必须通过调用响应对象(例如，<code>res.json(…)</code>或<code>res.send(…)</code>)发出某种响应，否则HTTP服务器将挂起。</p>
<blockquote>
<p>[!hint]<br>要了解如何创建自己的自定义装饰器，请访问<a href="https://docs.nestjs.com/custom-decorators">本章</a>。</p>
</blockquote>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>前面，我们定义了一个端点来获取cat资源(GET路由)。我们通常还希望提供一个端点来创建新记录。为此，让我们创建POST处理程序:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Post()</span><br><span class="line">  create(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  findAll(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action returns all cats&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是这么简单。Nest为所有标准HTTP方法提供了装饰器:<code>@Get()、@Post()、@Put()、@Delete()、@Patch()、@Options()和@Head()</code>。此外，<code>@All()</code>定义了一个端点来处理它们全部。</p>
<h2 id="路由通配符"><a href="#路由通配符" class="headerlink" title="路由通配符"></a>路由通配符</h2><p>也支持基于模式的路由。例如，星号用作通配符，可以匹配任何字符组合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">&#x27;ab*cd&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">findAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This route uses a wildcard&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&#39;ab*cd&#39;</code>路由路径将匹配<code>abcd, ab_cd, abecd</code>，等等。字符<code>?</code>、<code>+</code>、<code>*</code>和<code>()</code>可以在路由路径中使用，它们是对应正则表达式的子集。连字符(-)和点(.)由基于字符串的路径逐字解释。</p>
<blockquote>
<p>[!warning]<br>路由中间的通配符只有<code>express</code>支持</p>
</blockquote>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>如上所述，响应状态码在默认情况下总是200，除了POST请求是201。通过在处理程序级别添加<code>@HttpCode(…)</code>装饰器，我们可以很容易地改变这种行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Post()</span><br><span class="line">@HttpCode(<span class="number">204</span>)</span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>从<code>@nestjs/common</code>包中导入<code>HttpCode</code>。</p>
</blockquote>
<p>通常，您的状态码不是静态的，而是取决于各种因素。在这种情况下，您可以使用<code>library-specific</code>的响应(使用@Res()注入)对象(或者，在出现错误的情况下，抛出异常)。</p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>去指定一个自定义的相应头，你可以使用<code>@Header</code>或者特定库的响应对象（直接调用<code>res.header()</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Post()</span><br><span class="line">@Header(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>从<code>@nestjs/common</code>导入<code>Header</code></p>
</blockquote>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>要将响应重定向到特定的URL，您可以使用<code>@Redirect()</code>装饰器或特定于库的响应对象(并直接调用<code>res.redirect()</code>)。<br><code>@Redirect()</code>有两个参数，<code>url</code>和<code>statusCode</code>，它们都是可选的。如果省略，statusCode的默认值是<code>302</code> (Found)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line">@Redirect(<span class="string">&#x27;https://nestjs.com&#x27;</span>, <span class="number">301</span>)</span><br></pre></td></tr></table></figure>

<p>有时，您可能希望动态地确定HTTP状态码或重定向URL。要做到这一点，可以从路由处理程序方法中返回一个具有如下形状的对象:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;url&quot;</span>: string,</span><br><span class="line">  <span class="string">&quot;statusCode&quot;</span>: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的值将覆盖传递给@Redirect()装饰器的任何参数。例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">&#x27;docs&#x27;</span>)</span><br><span class="line">@Redirect(<span class="string">&#x27;https://docs.nestjs.com&#x27;</span>, <span class="number">302</span>)</span><br><span class="line"><span class="function"><span class="title">getDocs</span>(<span class="params">@Query(<span class="string">&#x27;version&#x27;</span>) version</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (version &amp;&amp; version === <span class="string">&#x27;5&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">url</span>: <span class="string">&#x27;https://docs.nestjs.com/v5/&#x27;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h2><p>当你需要接受动态数据作为请求的一部分时，带有静态路径的路由将无法工作(例如，GET <code>/cats/1</code>获取id为1的cat)。为了定义带有参数的路由，我们可以在路由的路径中添加路由参数令牌，以捕获请求URL中该位置的动态值。下面<code>@Get()</code>装饰器示例中的路由参数令牌演示了这种用法。以这种方式声明的路由参数可以使用<code>@Param()</code>装饰器访问，该装饰器应该添加到方法签名中。</p>
<blockquote>
<p>[!hint]<br>带参数的路由应该在任何静态路径之后声明。这可以防止参数化路径拦截发往静态路径的流量。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">findOne(@Param() params: any): string &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(params.id);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;params.id&#125;</span> cat`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Param()</code>用于修饰方法参数(在上面的例子中是<code>params</code>)，并使路由参数在方法体中作为修饰过的方法参数的属性可用。如上面的代码所示，我们可以通过引用<code>params.id</code>来访问id形参。你也可以将一个特定的参数标记传递给装饰器，然后在方法体中直接通过名称引用路由参数</p>
<blockquote>
<p>[!hint]<br>从@nestjs/common包中导入Param。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">findOne(@Param(<span class="string">&#x27;id&#x27;</span>) id: string): string &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子域路由"><a href="#子域路由" class="headerlink" title="子域路由"></a>子域路由</h2><p><code>@Controller</code>装饰器可以使用一个<code>host</code>选项来要求传入请求的HTTP主机匹配某个特定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Controller(&#123; <span class="attr">host</span>: <span class="string">&#x27;admin.example.com&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  index(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Admin page&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>由于<strong>Fastify</strong>缺乏对嵌套路由器的支持，所以在使用子域路由时，应该使用(默认的)Express适配器。</p>
</blockquote>
<p>与路由路径类似，<code>hosts</code>选项可以使用令牌来捕获主机名中该位置的动态值。下面的<code>@Controller()</code>装饰器示例中的主机参数令牌演示了这种用法。以这种方式声明的主机参数可以使用<code>@HostParam()</code>装饰器访问，该装饰器应该添加到方法签名中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Controller(&#123; <span class="attr">host</span>: <span class="string">&#x27;:account.example.com&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  <span class="function"><span class="title">getInfo</span>(<span class="params">@HostParam(<span class="string">&#x27;account&#x27;</span>) account: string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>对于来自不同编程语言背景的人来说，可能会惊讶地发现，在Nest中，几乎所有内容都是在传入请求之间共享的。我们有一个连接到数据库的连接池，具有全局状态的单例服务等等。请记住，Node.js不遵循请求/响应多线程无状态模型，在这种模型中，每个请求都由一个单独的线程处理。因此，使用单例实例对我们的应用程序是完全安全的。</p>
<p>然而，在某些特殊情况下，基于请求的控制器生命周期可能是期望的行为，例如GraphQL应用程序中的每个请求缓存、请求跟踪或多租户。在<a href="https://docs.nestjs.com/fundamentals/injection-scopes">这里</a>了解如何控制作用域。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>我们喜欢现代JavaScript，我们知道数据提取大多是异步的。这就是为什么Nest支持并能很好地使用异步函数的原因。</p>
<blockquote>
<p>[!hint]<br>Learn more about <code>async / await</code> feature <a href="https://kamilmysliwiec.com/typescript-2-1-introduction-async-await">here</a></p>
</blockquote>
<p>每个async函数都必须返回一个<code>Promise</code>。这意味着您可以返回一个延迟的值，Nest将能够自己解析该值。让我们来看一个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line"><span class="keyword">async</span> findAll(): <span class="built_in">Promise</span>&lt;any[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是完全有效的。此外，通过能够返回<strong>RxJS</strong><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html">可观察流</a>，Nest路由处理程序甚至更加强大。Nest将自动订阅下面的源并获取最后发出的值(一旦流完成)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line">findAll(): Observable&lt;any[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两种方法都有效，您可以使用任何适合您需求的方法。</p>
<h2 id="请求载荷"><a href="#请求载荷" class="headerlink" title="请求载荷"></a>请求载荷</h2><p>我们前面的POST路由处理程序示例不接受任何客户端参数。让我们通过在这里添加<code>@Body()</code>装饰器来修复这个问题。</p>
<p>但首先(如果你使用TypeScript)，我们需要确定DTO(数据传输对象)模式。DTO是定义如何通过网络发送数据的对象。我们可以通过使用TypeScript接口或简单的类来确定DTO模式。有趣的是，我们建议在这里使用类。为什么?类是JavaScript ES6标准的一部分，因此它们在编译后的JavaScript中被保存为真实的实体。另一方面，由于TypeScript接口在编译过程中被删除，所以Nest不能在运行时引用它们。这一点很重要，因为<code>Pipes</code>等特性为在运行时访问变量的元类型时启用了其他可能性。</p>
<p>让我们创建CreateCatDto类:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateCatDto</span> </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">  breed: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只有三个基本性质。之后，我们可以在CatsController中使用新创建的DTO:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Post()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">@Body() createCatDto: CreateCatDto</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>我们的<code>ValidationPipe</code>可以过滤掉不应该被方法处理程序接收的属性。在这种情况下，我们可以将可接受的属性列入白名单，并且任何未包含在白名单中的属性都会自动从结果对象中删除。在<code>CreateCatDto</code>示例中，我们的白名单是name、age和breed属性。点击<a href="https://docs.nestjs.com/techniques/validation#stripping-properties">这里</a>了解更多。</p>
</blockquote>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>这里有一个关于处理错误(即处理异常)的单独<a href="https://docs.nestjs.com/exception-filters">章节</a>。</p>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Query, Post, Body, Put, Param, Delete &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateCatDto, UpdateCatDto, ListAllEntities &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Post()</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params">@Body() createCatDto: CreateCatDto</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="function"><span class="title">findAll</span>(<span class="params">@Query() query: ListAllEntities</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action returns all cats (limit: <span class="subst">$&#123;query.limit&#125;</span> items)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">findOne</span>(<span class="params">@Param(<span class="string">&#x27;id&#x27;</span>) id: string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Put(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">@Param(<span class="string">&#x27;id&#x27;</span>) id: string, @Body() updateCatDto: UpdateCatDto</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action updates a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Delete(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">@Param(<span class="string">&#x27;id&#x27;</span>) id: string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action removes a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>Nest CLI提供了一个生成器(示意图)，它自动生成所有样板代码，以帮助我们避免做所有这些事情，并使开发人员的体验更简单。在<a href="https://docs.nestjs.com/recipes/crud-generator">这里</a>阅读有关此功能的更多信息。</p>
</blockquote>
<h2 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h2><p>在完全定义了上述控制器之后，Nest仍然不知道CatsController存在，因此不会创建该类的实例。</p>
<p>控制器总是属于一个模块，这就是为什么我们在<code>@Module()</code>装饰器中包含了<code>controllers</code>数组。因为除了根模块<code>AppModule</code>之外，我们还没有定义任何其他模块，所以我们将用它来引入<code>CatsController</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.controller&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>@Module()</code>装饰器将元数据附加到模块类中，Nest现在可以很容易地反映出哪些控制器必须被挂载。</p>
<h2 id="特定库方法"><a href="#特定库方法" class="headerlink" title="特定库方法"></a>特定库方法</h2><p>到目前为止，我们已经讨论了操作响应的Nest标准方法。操纵响应的第二种方法是使用特定于库的响应对象。为了注入特定的响应对象，我们需要使用<code>@Res()</code>装饰器。为了显示不同之处，让我们重写CatsController如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post, Res, HttpStatus &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Response &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Post()</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params">@Res() res: Response</span>)</span> &#123;</span><br><span class="line">    res.status(HttpStatus.CREATED).send();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="function"><span class="title">findAll</span>(<span class="params">@Res() res: Response</span>)</span> &#123;</span><br><span class="line">     res.status(HttpStatus.OK).json([]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这种方法是有效的，并且实际上通过提供对响应对象的完全控制(头文件操作、库特定的特性等)在某些方面提供了更大的灵活性，但是应该谨慎使用。一般来说，这种方法不太明确，而且确实有一些缺点。主要的缺点是，您的代码变得依赖于平台(因为底层库可能在响应对象上具有不同的api)，并且更难测试(您必须模拟响应对象，等等)。</p>
<p>此外，在上面的例子中，你失去了与依赖于Nest标准响应处理的Nest特性的兼容性，比如拦截器和<code>@HttpCode()</code> / <code>@Header()</code>装饰器。要解决这个问题，你可以将<code>passthrough</code>选项设置为<code>true</code>，如下所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line"><span class="function"><span class="title">findAll</span>(<span class="params">@Res(&#123; passthrough: <span class="literal">true</span> &#125;) res: Response</span>)</span> &#123;</span><br><span class="line">  res.status(HttpStatus.OK);</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，您可以与原生响应对象进行交互(例如，根据特定条件设置cookie或header)，但将其余部分留给框架。</p>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>Nest命令</title>
    <url>/2023/07/21/Node/NestJS/Nest%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装Nest"><a href="#安装Nest" class="headerlink" title="安装Nest"></a>安装Nest</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g @nestjs/cli</span><br></pre></td></tr></table></figure>

<h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest new project-name</span><br></pre></td></tr></table></figure>

<h2 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器"></a>创建控制器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest g controller [name]</span><br></pre></td></tr></table></figure>

<h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest g service [name]</span><br></pre></td></tr></table></figure>

<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest g module [name]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>4. Providers</title>
    <url>/2023/07/20/Node/NestJS/4.%20Providers/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Providers是Nest中的一个基本概念。许多基本的Nest类可以被视为提供者——服务、存储库、工厂、助手等等。提供者的主要思想是它可以作为依赖注入;这意味着对象可以创建彼此之间的各种关系，并且“连接”对象实例的功能可以在很大程度上委托给Nest运行时系统。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250927115.png" alt="image.png"></p>
<p>在前一章中，我们构建了一个简单的<code>CatsController</code>。控制器应该处理HTTP请求，并将更复杂的任务委托给提供商。提供程序是在模块中声明为提供程序的普通JavaScript类。</p>
<blockquote>
<p>[!hint]<br>由于Nest允许以更面向对象的方式设计和组织依赖项，因此我们强烈建议遵循<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a>原则([[SOLID]])。</p>
</blockquote>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>让我们从创建一个简单的<code>CatsService</code>开始。该服务将负责数据存储和检索，并被设计为由<code>CatsController</code>使用，因此将其定义为提供者是一个很好的候选者。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Cat &#125; <span class="keyword">from</span> <span class="string">&#x27;./interfaces/cat.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsService</span> </span>&#123;</span><br><span class="line">  private readonly cats: Cat[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params">cat: Cat</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cats.push(cat);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findAll(): Cat[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.cats;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>要使用CLI创建服务，只需执行<code>$ nest g service cats</code>命令。</p>
</blockquote>
<p>我们的<code>CatsService</code>是一个具有一个属性和两个方法的基本类。唯一的新特性是它使用了<code>@Injectable()</code>装饰器。<code>@Injectable()</code>装饰器附加了元数据，它声明<code>CatsService</code>是一个可以由Nest IoC容器管理的类。顺便说一下，这个例子也使用了一个<code>Cat</code>接口，它看起来可能是这样的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface Cat &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">  breed: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们有了一个检索猫的服务类，让我们在<code>CatsController</code>中使用它:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post, Body &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateCatDto &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto/create-cat.dto&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Cat &#125; <span class="keyword">from</span> <span class="string">&#x27;./interfaces/cat.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private catsService: CatsService</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Post()</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">@Body() createCatDto: CreateCatDto</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.catsService.create(createCatDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="keyword">async</span> findAll(): <span class="built_in">Promise</span>&lt;Cat[]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.catsService.findAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CatsService</code>是通过类构造函数注入的。注意这里使用了私有语法。这种简写允许我们在同一位置立即声明和初始化<code>catsService</code>成员。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>Nest是围绕通常称为依赖注入的强大设计模式构建的。我们建议在Angular官方文档中阅读一篇关于这个概念的<a href="https://angular.io/guide/dependency-injection">好文章</a>([[理解依赖注入]])。</p>
<p>在Nest中，由于TypeScript的功能，管理依赖非常容易，因为它们只按类型解析。在下面的示例中，Nest将通过创建和返回<code>catsService</code>的实例来解析<code>catsService</code>(或者，在单例的正常情况下，如果已经在其他地方请求了它，则返回现有的实例)。这个依赖被解析并传递给你的控制器的构造函数(或分配给指定的属性):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">private catsService: CatsService</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>Providers通常有一个与应用程序生命周期同步的生命周期(“作用域”)。当应用程序被引导时，必须解析每个依赖项，因此必须实例化每个提供者。类似地，当应用程序关闭时，每个提供程序都将被销毁。然而，也有一些方法可以使您的提供者生命周期限定在<code>request-scoped</code>内。你可以在<a href="https://docs.nestjs.com/fundamentals/injection-scopes">这里</a>阅读更多关于这些技术的内容。</p>
<h2 id="自定义-Providers"><a href="#自定义-Providers" class="headerlink" title="自定义 Providers"></a>自定义 Providers</h2><p>Nest有一个内置的控制反转(IoC)容器来解析providers之间的关系。这个特性是上述依赖注入特性的基础，但实际上比我们目前所描述的要强大得多。有几种方法可以定义提供程序:您可以使用普通值、类以及异步或同步工厂。这里提供了更多<a href="https://docs.nestjs.com/fundamentals/dependency-injection">示例</a>。</p>
<h2 id="Optional-providers"><a href="#Optional-providers" class="headerlink" title="Optional providers"></a>Optional providers</h2><p>偶尔，您可能会有不需要解析的依赖项。例如，您的类可能依赖于配置对象，但如果没有传递，则应使用默认值。在这种情况下，依赖项成为可选的，因为缺少配置提供程序不会导致错误。</p>
<p>要指出一个提供程序是可选的，可以在构造函数的签名中使用<code>@Optional()</code>装饰器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, Optional, Inject &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">@Optional() @Inject(<span class="string">&#x27;HTTP_OPTIONS&#x27;</span>) private httpClient: T</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在上面的示例中，我们使用的是自定义provider，这就是我们包含<code>HTTP_OPTIONS</code>自定义令牌的原因。前面的例子展示了基于构造函数的注入，通过构造函数中的类 表示 依赖项。在<a href="https://docs.nestjs.com/fundamentals/custom-providers">这里</a>阅读有关自定义提供程序及其相关令牌的更多信息。</p>
<h2 id="基于属性的注入"><a href="#基于属性的注入" class="headerlink" title="基于属性的注入"></a>基于属性的注入</h2><p>到目前为止，我们使用的技术被称为基于构造函数的注入，因为提供程序是通过构造函数方法注入的。在一些非常特殊的情况下，基于属性的注入可能很有用。例如，如果您的顶级类依赖于一个或多个提供程序，那么通过从构造函数调用子类中的<code>super()</code>来传递它们可能非常繁琐。为了避免这种情况，你可以在属性级别使用<code>@Inject()</code>装饰器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, Inject &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  @Inject(<span class="string">&#x27;HTTP_OPTIONS&#x27;</span>)</span><br><span class="line">  private readonly httpClient: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>如果你的类没有扩展其他providers，你应该总是使用基于构造函数的注入。</p>
</blockquote>
<h2 id="Provider-registration"><a href="#Provider-registration" class="headerlink" title="Provider registration"></a>Provider registration</h2><p>现在我们已经定义了一个<code>provider(CatsService)</code>，并且有了该服务的消费者(<code>CatsController</code>)，我们需要向Nest注册该服务，以便它可以执行注入。我们通过编辑模块文件(<code>app.module.ts</code>)并将服务添加到<code>@Module()</code>装饰器的<code>provider</code>s数组中来实现这一点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Nest现在可以解析<code>CatsController</code>类的依赖关系了。</p>
<p>现在我们的目录结构应该是这样的:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250928067.png" alt="image.png"></p>
<h2 id="手动实例化"><a href="#手动实例化" class="headerlink" title="手动实例化"></a>手动实例化</h2><p>到目前为止，我们已经讨论了Nest如何自动处理解析依赖项的大部分细节。在某些情况下，你可能需要走出内置的依赖注入系统，手动检索或实例化提供商。下面我们将简要讨论两个这样的主题。</p>
<ul>
<li>要获取现有实例或动态实例化提供程序，可以使用 <a href="https://docs.nestjs.com/fundamentals/module-ref">Module reference</a>.</li>
<li>要在<code>bootstrap()</code>函数中获取提供商(例如，对于没有控制器的独立应用程序，或在引导期间使用配置服务)，请参阅<a href="https://docs.nestjs.com/standalone-applications">独立应用程序</a>。</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2023/07/23/Node/NestJS/test/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5
  </pre></div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Key elements in Product X</span><br><span class="line">    &quot;Calcium&quot; : 42.96</span><br><span class="line">    &quot;Potassium&quot; : 50.05</span><br><span class="line">    &quot;Magnesium&quot; : 10.01</span><br><span class="line">    &quot;Iron&quot; :  5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>5. Modules</title>
    <url>/2023/07/20/Node/NestJS/5.%20Modules/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Module是一个带有<code>@Module()</code>装饰器的类。<code>@Module()</code>装饰器提供了Nest用来组织应用程序结构的元数据。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250928592.png" alt="image.png"></p>
<p><code>@Module()</code>装饰器接受一个对象，该对象的属性描述了该模块:</p>
<table>
<thead>
<tr>
<th>Properties</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Providers</td>
<td>这些提供商将被Nest注入器实例化，并且至少可以在整个模块中共享</td>
</tr>
<tr>
<td>controllers</td>
<td>在此模块中定义的控制器集，必须实例化</td>
</tr>
<tr>
<td>imports</td>
<td>导出该模块中所需的provider的导入模块列表</td>
</tr>
<tr>
<td>exports</td>
<td>提供程序的子集，由该模块提供，并且应该在导入该模块的其他模块中可用。您既可以使用提供者本身，也可以只使用它的令牌(提供值)</td>
</tr>
</tbody></table>
<p>该模块默认封装provider。这意味着不可能注入既不是当前模块的直接组成部分，也不是从导入模块导出的provider。因此，您可以将从模块导出的provider视为模块的公共接口或API。</p>
<h2 id="Feature-modules"><a href="#Feature-modules" class="headerlink" title="Feature modules"></a>Feature modules</h2><p><code>CatsController</code>和<code>CatsService</code>属于同一个应用程序域。由于它们密切相关，因此将它们移到特性模块中是有意义的。功能模块只是组织与特定功能相关的代码，保持代码的组织性并建立清晰的边界。这有助于我们管理复杂性，并使用<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a>原则进行开发，特别是当应用程序和/或团队的规模增长时。</p>
<p>为了演示这一点，我们将创建<code>CatsModule</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>要使用CLI创建一个模块，只需执行<code>$ nest g module cats</code>命令。</p>
</blockquote>
<p>上面，我们在<code>cats.module.ts</code>文件中定义了<code>CatsModule</code>，并将与该模块相关的所有内容移动到<code>cats</code>目录中。我们需要做的最后一件事是将这个模块导入根模块(<code>AppModule</code>，定义在<code>app.module.ts</code>文件中)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们的目录结构:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250928069.png" alt="image.png"></p>
<h2 id="Shared-modules"><a href="#Shared-modules" class="headerlink" title="Shared modules"></a>Shared modules</h2><p>在Nest中，模块默认是单例的，因此你可以毫不费力地在多个模块之间共享任何提供者的相同实例。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250929399.png" alt="image.png"></p>
<p>每个模块自动成为一个共享模块。一旦创建，它就可以被任何模块重用。假设我们想要在其他几个模块之间共享<code>CatsService</code>的一个实例。为了做到这一点，我们首先需要通过将其添加到模块的<code>exports</code>数组中来导出<code>CatsService</code>提供商，如下所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">  <span class="attr">exports</span>: [CatsService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，任何导入<code>CatsModule</code>的模块都可以访问<code>CatsService</code>，并将与导入它的所有其他模块共享同一个实例。</p>
<h2 id="Module-re-exporting"><a href="#Module-re-exporting" class="headerlink" title="Module re-exporting"></a>Module re-exporting</h2><p>如上所述，模块可以导出它们的内部provider。此外，它们还可以重新导出它们导入的模块。在下面的例子中，<code>CommonModule</code>被导入<code>CoreModule</code>并从<code>CoreModule</code>中导出，使得它可以被其他导入这个模块的模块使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CommonModule],</span><br><span class="line">  <span class="attr">exports</span>: [CommonModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dependency-injection"><a href="#Dependency-injection" class="headerlink" title="Dependency injection"></a>Dependency injection</h2><p>模块类也可以注入provider(例如，用于配置目的):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private catsService: CatsService</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，由于循环依赖，模块类本身不能作为provider注入。</p>
<h2 id="Global-modules"><a href="#Global-modules" class="headerlink" title="Global modules"></a>Global modules</h2><p>如果必须在任何地方导入相同的模块集，就会变得很繁琐。与Nest不同，angular的providers是在全局作用域中注册的。一旦定义，它们就随处可见。然而，Nest将提供程序封装在模块作用域中。如果不先导入封装模块，就不能在其他地方使用模块的提供程序。</p>
<p>当你想要提供一组在任何地方都可以使用的提供程序(例如，帮助程序、数据库连接等)时，使用<code>@Global()</code>装饰器将模块设置为全局。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, Global &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Global()</span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">  <span class="attr">exports</span>: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Global()</code>装饰器使模块成为全局作用域。全局模块应该只注册一次，通常由根模块或核心模块注册。在上面的例子中，<code>CatsService</code>提供者将是无处不在的，并且希望注入该服务的模块将不需要在其imports数组中导入<code>CatsModule</code>。</p>
<blockquote>
<p>[!hint]<br>让所有东西都是全局的并不是一个好的设计决策。可以使用全局模块来减少必要的样板文件的数量。<code>imports</code>数组通常是让消费者可以使用模块API的首选方式。</p>
</blockquote>
<h2 id="Dynamic-modules"><a href="#Dynamic-modules" class="headerlink" title="Dynamic modules"></a>Dynamic modules</h2><p>Nest模块系统包括一个强大的功能，称为动态模块。此特性使您能够轻松地创建可定制的模块，这些模块可以动态地注册和配置提供程序。动态模块在<a href="https://docs.nestjs.com/fundamentals/dynamic-modules">这里</a>有广泛的介绍。在本章中，我们将给出一个简短的概述来完成对模块的介绍。</p>
<p>下面是一个<code>DatabaseModule</code>动态模块定义的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, DynamicModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createDatabaseProviders &#125; <span class="keyword">from</span> <span class="string">&#x27;./database.providers&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Connection &#125; <span class="keyword">from</span> <span class="string">&#x27;./connection.provider&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">providers</span>: [Connection],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> forRoot(entities = [], options?): DynamicModule &#123;</span><br><span class="line">    <span class="keyword">const</span> providers = createDatabaseProviders(options, entities);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">module</span>: DatabaseModule,</span><br><span class="line">      <span class="attr">providers</span>: providers,</span><br><span class="line">      <span class="attr">exports</span>: providers,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br><code>forRoot()</code>方法可以同步或异步(即通过<code>Promise</code>)返回一个动态模块。</p>
</blockquote>
<p>该模块在默认情况下定义了<code>Connection</code> provider(在<code>@Module()</code>装饰器元数据中)，但另外——取决于传递给<code>forRoot()</code>方法的<code>entities</code>和<code>options</code>对象——还公开了一个提供程序集合，例如存储库。注意，动态模块返回的属性扩展(而不是覆盖)了在<code>@Module()</code>装饰器中定义的基本模块元数据。这就是从模块导出静态声明的<code>Connection</code>提供程序和动态生成的存储库提供程序的方式。</p>
<p>如果要在全局作用域中注册一个动态模块，请将<code>global</code>属性设置为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">global</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">module</span>: DatabaseModule,</span><br><span class="line">  <span class="attr">providers</span>: providers,</span><br><span class="line">  <span class="attr">exports</span>: providers,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>正如上面所提到的，让所有东西都是全局的并不是一个好的设计决策。</p>
</blockquote>
<p>DatabaseModule可以通过以下方式导入和配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DatabaseModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./database/database.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;./users/entities/user.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [DatabaseModule.forRoot([User])],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想反过来重新导出一个动态模块，你可以忽略exports数组中的forRoot()方法调用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DatabaseModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./database/database.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;./users/entities/user.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [DatabaseModule.forRoot([User])],</span><br><span class="line">  <span class="attr">exports</span>: [DatabaseModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.nestjs.com/fundamentals/dynamic-modules">动态模块</a>一章更详细地介绍了这个主题，并包括一个<a href="https://github.com/nestjs/nest/tree/master/sample/25-dynamic-modules">工作示例</a></p>
<blockquote>
<p>[!hint]<br>在<a href="https://docs.nestjs.com/fundamentals/dynamic-modules#configurable-module-builder">本章</a>中，学习如何使用<code>ConfigurableModuleBuilder</code>构建高度可定制的动态模块。</p>
</blockquote>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>6. 中间件</title>
    <url>/2023/07/23/Node/NestJS/6.%20%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>中间件是一个在路由处理程序之前被调用的函数。中间件函数可以访问请求和响应对象，以及应用程序请求-响应周期中的<code>next()</code>中间件函数。next中间件函数通常由一个名为next的变量表示。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250929639.png" alt="image.png"></p>
<p>默认情况下，Nest中间件相当于<a href="https://expressjs.com/en/guide/using-middleware.html">express</a>中间件。以下来自官方快速文档的描述描述了中间件的功能:</p>
<blockquote>
<p>中间件函数可以执行以下任务:</p>
<ul>
<li>执行任何代码。</li>
<li>对请求和响应对象进行更改。</li>
<li>调用堆栈中的下一个中间件函数。</li>
<li>如果当前中间件函数没有结束<code>请求-响应周期</code>，它必须调用next()将控制传递给下一个中间件函数。否则，请求将被挂起。</li>
</ul>
</blockquote>
<blockquote>
<p>[!warning]<br><code>Express</code>和<code>fastify</code>以不同的方式表达和处理中间件，并提供不同的方法签名。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, NestMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request, Response, NextFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerMiddleware</span> <span class="title">implements</span> <span class="title">NestMiddleware</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">use</span>(<span class="params">req: Request, res: Response, next: NextFunction</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Request...&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>Nest中间件完全支持依赖注入。与提供程序和控制器一样，它们能够注入在同一模块中可用的依赖项。像往常一样，这是通过<code>constructor</code>完成的。</p>
<h2 id="应用中间件"><a href="#应用中间件" class="headerlink" title="应用中间件"></a>应用中间件</h2><p>在<code>@Module()</code>装饰器中没有中间件的位置。相反，我们使用模块类的<code>configure()</code>方法来设置它们。包含中间件的模块必须实现<code>NestModule</code>接口。让我们在<code>AppModule</code>级别设置<code>LoggerMiddleware</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>)</span> &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(<span class="string">&#x27;cats&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们已经为之前在<code>CatsController</code>中定义的<code>/cats</code>路由处理程序设置了<code>LoggerMiddleware</code>。我们还可以在配置中间件时将包含路由路径和请求方法的对象传递给<code>forRoutes()</code>方法，从而进一步将中间件限制为特定的请求方法。在下面的示例中，请注意我们导入了<code>RequestMethod</code> enum来引用所需的请求方法类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, RequestMethod, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>)</span> &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(&#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: RequestMethod.GET &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br><code>configure()</code>方法可以使用<code>async/await</code>实现异步(例如，你可以在<code>configure()</code>方法体中等待异步操作的完成)。</p>
</blockquote>
<blockquote>
<p>[!warning]<br>当使用<code>express</code>适配器时，默认情况下，NestJS应用会从包体解析器中注册<code>json</code>和<code>urlencoded</code>。这意味着，如果您想通过<code>MiddlewareConsumer</code>定制中间件，那么在使用<code>NestFactory.create()</code>创建应用程序时，需要通过将<code>bodyParser</code>标志设置为<code>false</code>来关闭全局中间件。</p>
</blockquote>
<h2 id="路由通配符"><a href="#路由通配符" class="headerlink" title="路由通配符"></a>路由通配符</h2><p>Nest也支持基于模式的路由。例如，星号用作通配符，并将匹配任何字符组合:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">forRoutes(&#123; <span class="attr">path</span>: <span class="string">&#x27;ab*cd&#x27;</span>, <span class="attr">method</span>: RequestMethod.ALL &#125;);</span><br></pre></td></tr></table></figure>

<p><code>&#39;ab*cd&#39;</code>路由路径将匹配<code>abcd, ab_cd, abecd</code>，等等。字符<code>?、+、*和()</code>可以在路由路径中使用，它们是对应正则表达式的子集。连字符(-)和点(.)由基于字符串的路径逐字解释。</p>
<blockquote>
<p>[!warning]<br><code>fastify</code>包使用最新版本的<code>path-to-regexp</code>包，它不再支持通配符<em>。相反，您必须使用参数(例如，(.</em>)，:splat*)。</p>
</blockquote>
<h2 id="中间件消费者"><a href="#中间件消费者" class="headerlink" title="中间件消费者"></a>中间件消费者</h2><p><code>MiddlewareConsumer</code>是一个helper类。它提供了几个内置的方法来管理中间件。所有这些都可以用流畅的样式简单地链接起来。<code>forRoutes()</code>方法可以接受一个字符串、多个字符串、一个<code>RouteInfo</code>对象、一个控制器类，甚至多个控制器类。在大多数情况下，您可能只是传递一个以逗号分隔的控制器列表。下面是单个控制器的示例:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.controller&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>)</span> &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(CatsController);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br><code>apply()</code>方法可以接受单个中间件，也可以接受多个参数来指定多个中间件。</p>
</blockquote>
<h2 id="排除路由"><a href="#排除路由" class="headerlink" title="排除路由"></a>排除路由</h2><p>有时，我们希望从应用中间件中排除某些路由。我们可以使用<code>exclude()</code>方法轻松地排除某些路由。这个方法可以接受一个字符串、多个字符串或一个<code>RouteInfo</code>对象来标识要排除的路由，如下所示:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">consumer</span><br><span class="line">  .apply(LoggerMiddleware)</span><br><span class="line">  .exclude(</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: RequestMethod.GET &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: RequestMethod.POST &#125;,</span><br><span class="line">    <span class="string">&#x27;cats/(.*)&#x27;</span>,</span><br><span class="line">  )</span><br><span class="line">  .forRoutes(CatsController);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>exclude()方法使用path-to-regexp包支持通配符参数。</p>
</blockquote>
<p>在上面的例子中，<code>LoggerMiddleware</code>将被绑定到<code>Catscontroller</code>内部定义的所有路由，除了传递给<code>exclude()</code>方法的三个路由。</p>
<h2 id="功能性中间件"><a href="#功能性中间件" class="headerlink" title="功能性中间件"></a>功能性中间件</h2>]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>SOLID</title>
    <url>/2023/07/21/Others/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/SOLID/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式中的SOLID原则，分别是<code>单一原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则</code>。前辈们总结出来的，遵循五大原则可以使程序解决紧耦合，更加健壮。</p>
<p>SOLID原则是由5个设计原则组成，SOLID对应每个原则英文字母的开头：</p>
<ul>
<li>单一职责原则（<strong>S</strong>ingle Responsiblity Principle）</li>
<li>开闭原则(<strong>O</strong>pen Close Principle)</li>
<li>里式替换原则(<strong>L</strong>iskov Substitution Principle)</li>
<li>接口隔离原则(<strong>I</strong>nterface Segregation Principle)</li>
<li>依赖反转原则(<strong>D</strong>ependency Inversion Principle)</li>
</ul>
<table>
<thead>
<tr>
<th>缩写</th>
<th>原则</th>
</tr>
</thead>
<tbody><tr>
<td>SRP</td>
<td>单一责任原则</td>
</tr>
<tr>
<td>OCP</td>
<td>开放封闭原则</td>
</tr>
<tr>
<td>LSP</td>
<td>里氏替换原则</td>
</tr>
<tr>
<td>ISP</td>
<td>接口隔离原则</td>
</tr>
<tr>
<td>DIP</td>
<td>依赖倒置原则</td>
</tr>
</tbody></table>
<h2 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h2><p>指的是一个类或者一个方法只做一件事。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能抑制或者削弱这个类完成其他职责的能力。例如餐厅服务员负责把订单给厨师去做，而不是服务员又要订单又要炒菜。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250946787.png" alt="image.png"></p>
<p>一个协议翻译类，在协议翻译的过程中如果出现了异常，则把异常写入文件日志中。粗略看来这个类没有问题，但是如果我们需要把日志写入数据库，那么我么就需要改变代码。按照单一职责原则，这个类的设计就没有达到要求，因为日志规范的修改，确需要修改协议翻译类。为此我们可以引入专门的日志类来解决这个问题。如果再遇到日志相关的需求变更，我们只需要修改日志类就好了。</p>
<h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p>对扩展开放，对修改关闭。意为一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。例如一开始做了普通计算器程序，突然添加新需求，要再做一个程序员计算器，这时不应该修改普通计算器内部，应该使用面向接口编程，组合实现扩展。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250946406.png" alt="image.png"></p>
<p>程序 AnimalCounter 负责统计动物的腿数，如果我们要增加一种新动物比如 Sheep，我们就需要给 AnimalCounter 的 countFeet 函数增加一个判断，判断数组中是不是有 Sheep 实例，这就是说当有新的需求来的时候，我们得修改 AnimalCounter 代码，而不是扩展它。</p>
<p>下面的代码可以解决这个问题。我们使用了一个接口，鸡类和狗类都继承了这个接口，在 AnimalCounter 中我们只要调用这个接口就可以知道动物有多少只脚了。无论是再有绵羊类或者是昆虫类，它们只要继承了这个接口，AnimalCounter 都可以计算出动物的总脚数。也就是我们通过扩展 IAnimal 接口就可以满足需求，而不用修改 AnimalCounter 类。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。例如机动车必须有轮胎和发动机，子类宝马和奔驰不应该改写没轮胎或者没发动机。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250946407.png" alt="image.png"></p>
<p>我们定义了一个类叫 Bird，这个接口有四个方法，然后我们有一个天鹅类，一个鸡类。可以看到，Bird 的四个方法用 Swan 类来代替是没有问题的，但是用 Chicken 类来代替当调用到 fly 方法的时候就会抛出异常。这个就不符合 Liskov 原则，因为作为 Bird 类的子类的 Chicken 类没有做到替换父类 Bird 类而不影响程序运行。解决方法是拆分Bird类的功能，因为家禽是不会飞的。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>类不应该依赖不需要的接口，知道越少越好。例如电话接口只约束接电话和挂电话，不需要让依赖者知道还有通讯录。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250947802.png" alt="image.png"></p>
<p>类不应该被强迫去依赖它用不到的方法。大的原则是很多小而精的接口，要好于一个大一统的接口。比如下面的 ICar 接口，我们不应该为了大一统把加油 (fuel) 和 (Charge) 充电都放在里面，因为烧汽油的汽车才需要加油，使用电池驱动的电动车才需要充电。如果子类继承了父类中用不到的方法，子类也会打破上面的 Liskov 原则，也不利于将来的重构和优化。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖反转说了两点：</p>
<p>高层模块不应该依赖低层模块，双方应该依赖抽象。<br>抽象不应该依赖细节，而细节应该依赖抽象。<br>听起来很绕口，不过这个确实是面向对象编程里解决紧耦合问题最重要的原则之一。通常的解决方案就是大名鼎鼎的依赖注入！</p>
<p>指的是高级模块不应该依赖低级模块，而是依赖抽象。抽象不能依赖细节，细节要依赖抽象。比如类A内有类B对象，称为类A依赖类B，但是不应该这样做，而是选择类A去依赖抽象。例如垃圾收集器不管垃圾是什么类型，要是垃圾就行。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250947239.png" alt="image.png"></p>
<p>比如 物品交易，我有牛，你有羊， 以物换物，相互依赖， 如果改为统一用货币来交易，则彼此不依赖，而是都依赖于各自的物品抽象–货币。</p>
<p>下面的代码的任务是打印一个指定路径的文件，打印完成后发出 email。这个代码就违反了依赖反转原则，所有的 new 语句处都表示高层模块需要知道低层模块的细节，比如 <code>Program</code> 类就需要如何生成 <code>PrinterService</code> 和 <code>EMailService</code>，<code>PrinterService</code> 和 <code>EMailService</code> 的功能也没有被抽象出来。这样程序的功能在需要重构、扩展或者替换时高层模块和低层模块都需要知道对方的细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Program &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> filePath = args[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">var</span> printerService = <span class="keyword">new</span> PrinterService();</span><br><span class="line">		printerService.print(filePath);</span><br><span class="line">		<span class="keyword">var</span> emailService = <span class="keyword">new</span> EMailService();</span><br><span class="line">		emailService.send(<span class="string">&quot;surfirst@example.com&quot;</span>, <span class="string">&quot;File printed&quot;</span>, filePath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Logger logger;</span><br><span class="line">	PrinterService()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.logger = <span class="keyword">new</span> Logger();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// process print task</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">this</span>.logger.log(filePath + <span class="string">&quot; printed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">log</span><span class="params">(String content)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(String email, String subject, String content)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Email %s has been sent to %s. &quot;</span>, subject, email);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决上面的方法可以是依赖注入，也可以通过类工厂的方法来解决。由于篇幅有限，我们在这里使用类工厂来展示解决方案。首先我们抽象出我们用到的组件的接口，然后我们通过类工厂来实现这些接口，最后通过类工厂来解决依赖问题。</p>
<p>下面是我们抽象出来的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inteface IPrinterService &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String filePath)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILogger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEmailService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String email, String subject, String content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是类工厂的代码，虽然看上去很简单，但是通过类工厂，我们就解决了抽象到实现细节的问题，这使我们的业务逻辑独立于我们的依赖项。依赖项可以来自外部文件，对 Java 来说就是不同的 JAR 文件，对 .Net 来说可以是不同的 DLL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPrinterService <span class="title">CreatePrinterService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PrinterService();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILogger <span class="title">CreateLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Logger();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEmailService <span class="title">CreateEmailService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EmailService();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用了类工厂以后的业务逻辑代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Program &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> filePath = args[<span class="number">0</span>];</span><br><span class="line">		IPrinterService printerService = Factory.CreatePrinterService();</span><br><span class="line">		printerService.print(filePath);</span><br><span class="line">		IEmailService emailService = Factory.CreateEmailService();</span><br><span class="line">		emailService.send(<span class="string">&quot;surfirst@example.com&quot;</span>, <span class="string">&quot;File printed&quot;</span>, filePath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterService</span> <span class="keyword">implements</span> <span class="title">IPrinterService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Logger logger;</span><br><span class="line">	PrinterService()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.logger = Factory.CreateLogger();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// process print task</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">this</span>.logger.log(filePath + <span class="string">&quot; printed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> <span class="keyword">implements</span> <span class="title">ILogger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">log</span><span class="params">(String content)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(String email, String subject, String content)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Email %s has been sent to %s. &quot;</span>, subject, email);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>没人写一款程序能完全遵守SOLID原则，甚至有些设计模式是违反SOLID原则。如何权衡就要看利是否大于弊。不足之处望指教。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「Peter_Gao_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_42672770/article/details/117650871">https://blog.csdn.net/qq_42672770/article/details/117650871</a></p>
]]></content>
      <categories>
        <category>Others</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>4. Next.js怎么工作</title>
    <url>/2023/07/16/React/NextJS/4.%20Next.js%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学习更高级的Next.js特性之前，了解Next.js的基本工作原理会有所帮助。</p>
<p>在本课程开始时，我们讨论了React如何相对不受您如何构建和构建应用程序的影响-有多种方法可以使用React构建应用程序。js提供了一个框架来构建您的应用程序，以及有助于加快开发过程和最终应用程序的优化。</p>
<p>在接下来的部分中，我们将看看在这些不同的阶段中应用程序代码发生了什么:</p>
<ul>
<li>代码运行的环境:<strong>开发</strong>与<strong>生产</strong></li>
<li>代码何时运行:<strong>构建时</strong>与<strong>运行时</strong></li>
<li>渲染发生在哪里:<strong>客户机</strong>还是<strong>服务器</strong></li>
</ul>
<p>现在让我们更深入地了解这些概念，并讨论Next.js在幕后执行的一些过程。</p>
<h2 id="开发和生产环境"><a href="#开发和生产环境" class="headerlink" title="开发和生产环境"></a>开发和生产环境</h2><p>你可以把环境当成代码运行的上下文。</p>
<p>在开发过程中，你在本地机器上构建和运行你的应用程序，进入生产环境是使应用程序准备好被用户部署和使用的过程。</p>
<h2 id="怎么应用到-Next-js-？"><a href="#怎么应用到-Next-js-？" class="headerlink" title="怎么应用到 Next.js ？"></a>怎么应用到 Next.js ？</h2><p>js为应用程序的开发和生产阶段提供了特性。例如:</p>
<ul>
<li>在开发阶段，Next.js针对开发人员及其构建应用程序的经验进行了优化。它附带了一些旨在改善开发者体验的特性，比如TypeScript和ESLint的集成、快速刷新等等。</li>
<li>在生产阶段，Next.js针对最终用户及其使用应用程序的体验进行了优化。它的目标是转换代码，使其具有高性能和可访问性。</li>
</ul>
<p>由于每个环境都有不同的考虑因素和目标，因此将应用程序从开发转移到生产需要做很多工作。需要编译应用程序代码，捆绑代码，缩小代码，以及拆分代码。</p>
<h2 id="Next-js-编译器"><a href="#Next-js-编译器" class="headerlink" title="Next.js 编译器"></a>Next.js 编译器</h2><p>js处理这些代码转换和底层基础设施，使您的应用程序更容易进入生产环境。</p>
<p>这之所以可能是因为Next.js有一个用Rust(一种底层编程语言)和SWC(一种可用于编译、最小化、绑定等的平台)编写的编译器。</p>
<h2 id="什么是-Compiling-？"><a href="#什么是-Compiling-？" class="headerlink" title="什么是 Compiling ？"></a>什么是 Compiling ？</h2><p>开发人员使用对开发人员更友好的语言(如JSX、TypeScript和现代版本的JavaScript)编写代码。虽然这些语言提高了开发人员的效率和信心，但在浏览器能够理解它们之前，它们需要被编译成JavaScript。</p>
<p>编译是指用一种语言获取代码，然后用另一种语言或该语言的另一种版本输出代码的过程。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250937850.png" alt="image.png"></p>
<p>在Next.js中，编译是在开发阶段编辑代码时进行的，并且是构建步骤的一部分，以便为应用程序的生产做好准备。</p>
<h2 id="什么是-Minifying-？"><a href="#什么是-Minifying-？" class="headerlink" title="什么是 Minifying ？"></a>什么是 Minifying ？</h2><p>开发人员编写的代码是针对可读性进行优化过的，此代码可能包含代码运行不需要的额外信息，例如注释、空格、缩进和多行。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250937964.png" alt="image.png"></p>
<p>最小化是在不改变代码功能的情况下删除不必要的代码格式和注释的过程。目标是通过减小文件大小来提高应用程序的性能。</p>
<p>在Next.js中，JavaScript和CSS文件会在生产环境中自动缩小。</p>
<h2 id="什么是-Bundling"><a href="#什么是-Bundling" class="headerlink" title="什么是 Bundling ?"></a>什么是 Bundling ?</h2><p>开发人员将应用程序分解为模块、组件和功能，这些模块、组件和功能可用于构建应用程序的更大部分。导出和导入这些内部模块以及外部第三方包会创建一个复杂的文件依赖关系网络。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250937437.png" alt="image.png"></p>
<p>捆绑是解决网络依赖并合并(或“打包”)文件(或模块)为浏览器优化的捆绑包的过程，目标是减少用户访问网页时对文件的请求数量。</p>
<h2 id="什么是-Code-Splitting-？"><a href="#什么是-Code-Splitting-？" class="headerlink" title="什么是 Code Splitting ？"></a>什么是 Code Splitting ？</h2><p>开发人员通常将他们的应用程序分成多个页面，这些页面可以从不同的url访问。这些页面中的每个都成为进入应用程序的唯一入口点。</p>
<p>代码拆分是将应用程序包拆分为每个入口点所需的更小块的过程。目标是通过只加载运行该页面所需的代码来改善应用程序的初始加载时间。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250938946.png" alt="image.png"></p>
<p>js内置了对代码分割的支持。在构建步骤中，<code>pages/</code>目录中的每个文件都将被自动代码拆分为自己的JavaScript包。</p>
<p>深入：</p>
<ul>
<li>页面之间共享的任何代码也被拆分到另一个bundle中，以避免在进一步导航时重新下载相同的代码。</li>
<li>在初始页面加载之后，Next.js可以开始预加载用户可能浏览到的其他页面的代码。</li>
<li>动态导入是手动分割初始加载代码的另一种方法。</li>
</ul>
<h2 id="构建时和运行时"><a href="#构建时和运行时" class="headerlink" title="构建时和运行时"></a>构建时和运行时</h2><p>构建时(或构建步骤)是为生产准备应用程序代码的一系列步骤的名称。</p>
<p>在构建应用程序时，Next.js将把代码转换为生产优化的文件，准备部署到服务器并供用户使用。这些文件包括:</p>
<ul>
<li>用于静态生成页面的HTML文件</li>
<li>在服务器上呈现页面的JavaScript代码</li>
<li>用于在客户端上实现页面交互的JavaScript代码</li>
<li>CSS文件</li>
</ul>
<p>运行时(或请求时间)是指在构建和部署应用程序之后，应用程序响应用户请求而运行的时间段。</p>
<h2 id="客户端和服务端"><a href="#客户端和服务端" class="headerlink" title="客户端和服务端"></a>客户端和服务端</h2><p>在web应用程序的上下文中，客户端指的是用户设备上的浏览器，它向服务器发送应用程序代码的请求。然后，它将从服务器接收到的响应转换为用户可以与之交互的界面。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250938882.png" alt="image.png"></p>
<p>服务器是指数据中心中的计算机，它存储应用程序代码，接收来自客户机的请求，进行一些计算，并发回适当的响应。</p>
<h2 id="什么是渲染？"><a href="#什么是渲染？" class="headerlink" title="什么是渲染？"></a>什么是渲染？</h2><p>将用React编写的代码转换成UI的HTML表示是不可避免的工作单元。这个过程称为渲染。</p>
<p>呈现可以在服务器或客户机上进行。它可以在构建时提前发生，也可以在运行时的每个请求中发生。</p>
<p>使用Next.js，有三种类型的呈现方法可用:服务器端呈现、静态站点生成和客户端呈现。</p>
<h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>服务器端渲染和静态站点生成也被称为预渲染，因为获取外部数据和将React组件转换为HTML发生在结果发送到客户端之前。</p>
<h3 id="客户端渲染与预渲染"><a href="#客户端渲染与预渲染" class="headerlink" title="客户端渲染与预渲染"></a>客户端渲染与预渲染</h3><p>在标准的React应用程序中，浏览器从服务器接收一个空的HTML 外壳以及构造UI的JavaScript指令。这被称为客户端呈现，因为初始呈现工作发生在用户的设备上。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250938511.png" alt="image.png"></p>
<blockquote>
<p>[!note]+<br>你可以选择在Next.js应用中为特定组件使用客户端渲染，方法是使用React的useEffect()或数据获取钩子(如useSWR)来获取数据。</p>
</blockquote>
<p>相比之下，Next.js默认情况下预呈现每个页面。预渲染意味着HTML是提前在服务器上生成的，而不是在用户的设备上用JavaScript完成。</p>
<p>在实践中，这意味着对于一个完全客户端渲染的应用程序，当渲染工作完成时，用户将看到一个空白页面。与预渲染的应用程序相比，用户将看到构建好的HTML:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250938630.png" alt="image.png"></p>
<p>让我们讨论两种类型的预渲染:</p>
<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>通过服务器端呈现，为每个请求在服务器上生成页面的HTML。然后将生成的HTML、JSON数据和JavaScript指令发送到客户机，以使页面具有交互性。</p>
<p>在客户端，HTML用于显示快速的非交互式页面，而React使用JSON数据和JavaScript指令使组件具有交互性(例如，将事件处理程序附加到按钮上)。这个过程叫做水合作用。</p>
<p>在Next.js中，你可以通过使用<code>getServerSideProps</code>来选择服务器端渲染页面。</p>
<blockquote>
<p>[!note]+<br>React 18和Next 12引入了React服务器组件的alpha版本。服务器组件完全在服务器上呈现，不需要客户端JavaScript来呈现。此外，服务器组件允许开发人员在服务器上保留一些逻辑，并且只将该逻辑的结果发送给客户端。这减少了发送到客户端的包大小，并提高了客户端呈现性能。在这里了解有关React服务器组件的更多信息。</p>
</blockquote>
<h3 id="静态站点生成"><a href="#静态站点生成" class="headerlink" title="静态站点生成"></a>静态站点生成</h3><p>使用静态站点生成，HTML是在服务器上生成的，但与服务器端呈现不同的是，在运行时没有服务器。相反，内容只在构建时部署应用程序时生成一次，HTML存储在CDN中，并为每个请求重用。</p>
<p>在Next.js中，您可以选择使用<code>getStaticProps</code>静态生成页面。</p>
<blockquote>
<p>[!note]+<br>您可以在构建站点后使用增量静态再生成来创建或更新静态页面。这意味着如果数据发生变化，您不必重新构建整个站点。</p>
</blockquote>
<p>js的美妙之处在于，您可以为每个页面的用例选择最合适的呈现方法，无论是静态站点生成、服务器端呈现还是客户端呈现。要了解更多关于哪种呈现方法适合您的特定用例的信息，请参阅<a href="https://nextjs.org/docs/basic-features/data-fetching/overview">数据获取文档</a>。</p>
<h2 id="CDNs-和-Edge"><a href="#CDNs-和-Edge" class="headerlink" title="CDNs 和 Edge"></a>CDNs 和 Edge</h2><h3 id="什么是网络？"><a href="#什么是网络？" class="headerlink" title="什么是网络？"></a>什么是网络？</h3><p>了解应用程序代码的存储位置和部署到网络后的运行位置是很有帮助的。您可以将网络想象成能够共享资源的连接计算机(或服务器)。在Next.js应用程序的情况下，您的应用程序代码可以分发到<code>origin severs、内容交付网络(cdn)和Edge</code>。让我们看看它们分别是什么:</p>
<h4 id="Origin-Servers"><a href="#Origin-Servers" class="headerlink" title="Origin Servers"></a>Origin Servers</h4><p>正如我们前面所讨论的，服务器是指存储和运行应用程序代码原始版本的主计算机。</p>
<p>我们使用<code>origin</code>这个术语是为了将这个服务器与应用程序代码可以分发到的其他地方(比如CDN服务器和Edge服务器)区分开来。</p>
<p>当原始服务器接收到请求时，它在发送响应之前进行一些计算。计算工作的结果可以转移到CDN(内容分发网络)。</p>
<h4 id="Content-Delivery-Network"><a href="#Content-Delivery-Network" class="headerlink" title="Content Delivery Network"></a>Content Delivery Network</h4><p><code>CDN</code>将静态内容(如HTML和图像文件)存储在世界各地的多个位置，并放置在客户机和原始服务器之间。当新请求进入时，距离用户最近的<code>CDN</code>位置可以使用缓存的结果进行响应。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250939414.png" alt="image.png"></p>
<p>这减少了<code>origin</code>上的负载，因为计算不必发生在每个请求上。这也使用户更快，因为响应来自地理上更接近他们的位置。</p>
<p>在Next.js中，由于预渲染可以提前完成，cdn非常适合存储工作的静态结果-使内容交付更快。</p>
<h4 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h4><p>Edge是网络边缘(或边缘)的一个广义概念，最接近用户。cdn可以被认为是“边缘”的一部分，因为它们将静态内容存储在网络的边缘。</p>
<p>与cdn类似，边缘服务器分布在世界各地的多个位置。但与存储静态内容的cdn不同，一些Edge服务器可以运行一小段代码。</p>
<p>这意味着缓存和代码执行都可以在离用户更近的Edge上完成。</p>
<p>通过将一些传统上在客户端或服务器端完成的工作转移到Edge，您可以使应用程序性能更高，因为它减少了发送到客户端的代码量，并且部分用户请求不必一直返回到原始服务器，从而减少了延迟。在这里查看<a href="https://vercel.com/features/edge-functions#:~:text=Unlock%20the%20potential%20of%20edge%20computing">Next.js的Edge示例</a>。</p>
<p>在Next.js中，你可以使用中间件在Edge上运行代码，很快就可以使用React Server组件了。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>祝贺你完成了Next.js基础课程!</p>
<p>为了继续学习Next.js，我们建议您使用我们的教程创建您的<a href="https://nextjs.org/learn/basics/create-nextjs-app?utm_source=next-site&utm_medium=homepage-cta&utm_campaign=next-website">第一个Next.js应用程序</a>，该教程将向您介绍主要功能。</p>
<p>您还可以查看我们的<a href="https://nextjs.org/docs">文档</a>并探索我们广泛的<a href="https://nextjs.org/examples">示例列表</a>。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>3. 从 React 到 Next.js</title>
    <url>/2023/07/13/React/NextJS/3.%20%E4%BB%8E%20React%20%E5%88%B0%20Next.js/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在上一课中，我们讨论了如何开始使用React。这是最终代码的样子。如果从这里开始，请将此代码粘贴到代码编辑器中的index.html文件中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &quot;Default title&quot;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> names = [<span class="string">&quot;Ada Lovelace&quot;</span>, <span class="string">&quot;Grace Hopper&quot;</span>, <span class="string">&quot;Margaret Hamilton&quot;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          setLikes(likes + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> (</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">              &#123;names.map((name) =&gt; (</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">              ))&#125;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like (&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        )</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span>, app)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>现在，让我们看看如何从一个简单的React应用转移到Next.js。</p>
<h2 id="入门-Next-js"><a href="#入门-Next-js" class="headerlink" title="入门 Next.js"></a>入门 Next.js</h2><p>要将Next.js添加到项目中，您将不再需要从unpkg.com加载react和react-dom脚本。相反，你可以使用Node Package Manager: npm在本地安装这些包。</p>
<blockquote>
<p>[!note]+<br>你需要在你的机器上安装Node.js(<a href="https://nextjs.org/docs/upgrading#minimum-nodejs-version">最低版本要求</a>)，你可以在<a href="https://nodejs.org/en/">这里</a>下载它。</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在你的终端中，运行<code>npm install react react-dom next</code>。安装完成后，您应该能够看到包中列出的项目依赖项<code>package.json</code>文件:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;next&quot;</span>: <span class="string">&quot;^12.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还会注意到一个名为<code>node_modules</code>的新文件夹，其中包含了我们的依赖项的实际文件。<br>回到<code>index.html</code>文件，你可以删除以下代码:</p>
<ol>
<li><code>react</code>和<code>react-dom</code>脚本，因为你已经用NPM安装了它们。</li>
<li><code>&lt;html&gt;</code>和<code>&lt;body&gt;</code>标签，因为Next.js将为您创建这些标签。</li>
<li>与<code>app</code>元素和<code>ReactDom.render()</code>方法交互的代码。</li>
<li>Babel脚本，因为Next.js有一个编译器，可以将JSX转换为有效的浏览器可以理解的JavaScript。</li>
<li> <code>&lt;script type=&quot;text/jsx&quot;&gt;</code> 标签。</li>
<li> <code>React.useState(0)</code> 方法的 <code>React.</code>部分</li>
</ol>
<p>HTML文件中剩下的代码叫<code>JSX</code>，所以你可以把文件类型从<code>.html</code>改到<code>.js</code>或者<code>.jsx</code>。</p>
<p>要完全转移到一个Next.js应用这里有三件事情你需要去做。</p>
<ol>
<li>移动<code>index.js</code>文件去一个新的叫做<code>pages</code>文件夹。</li>
<li>给你的主组件添加一个默认的导出去帮助Next.js区分哪个组件应该作为这个页面的主组件去渲染。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//  ...</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加一个<code>scripts</code>到你的<code>package.json</code>文件去运行Next.js的开发服务器当你开发的时候。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;next dev&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">   <span class="comment">// &quot;dependencies&quot;: &#123;</span></span><br><span class="line">   <span class="comment">//   &quot;next&quot;: &quot;^11.1.0&quot;,</span></span><br><span class="line">   <span class="comment">//   &quot;react&quot;: &quot;^17.0.2&quot;,</span></span><br><span class="line">   <span class="comment">//   &quot;react-dom&quot;: &quot;^17.0.2&quot;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行开发服务器"><a href="#运行开发服务器" class="headerlink" title="运行开发服务器"></a>运行开发服务器</h2><p>为了确认一切正常，你可以在终端中运行<code>npm run dev</code>，并在浏览器中导航到localhost:3000来查看你的应用。然后，对代码做一个小的修改并保存。</p>
<p>保存文件后，您应该注意到浏览器会自动更新以反映更改。</p>
<p>这个特性被称为<code>Fast Refresh</code>，它能够在你进行任何编辑的时候，都给予你实时的反馈，并且这个功能是Next.js默认就配置好的。</p>
<p>回顾一下，你的代码从</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &quot;Default title&quot;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> names = [<span class="string">&quot;Ada Lovelace&quot;</span>, <span class="string">&quot;Grace Hopper&quot;</span>, <span class="string">&quot;Margaret Hamilton&quot;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          setLikes(likes + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> (</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">              &#123;names.map((name) =&gt; (</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">              ))&#125;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like (&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        )</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span>, app)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default title&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setLikes(likes + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like (&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从表面上看，这只是代码行数的一小部分减少，但它确实有助于突出一些东西:React是一个库，为构建现代交互式UI提供了必要的原语。但是将创建的UI合并到应用程序中仍然需要做一些工作。</p>
<p>查看迁移过程，您可能已经感受到使用Next.js的好处。您删除了babel脚本，体验了不再需要考虑的复杂工具配置。你还看到了快速刷新功能，这只是Next.js众多开发者体验功能之一。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>祝贺您创建了第一个Next.js应用。</p>
<p>总而言之，您探索了React和Next.js的基础知识，并从简单的React应用程序迁移到Next.js应用程序。</p>
<p>现在可以选择next .js旅程的下一步了。您可以:</p>
<ol>
<li>通过创建您的第一个应用程序来学习如何使用Next.js -本课程将向您介绍Next.js的主要功能，并通过构建更复杂的项目让您练习。</li>
<li>通过继续本课程，深入了解Next.js的工作原理。</li>
</ol>
<p>在下一课中，我们将通过介绍一些相关的web开发概念来探索next .js是如何工作的。熟悉这些概念将有助于扩展您的基础，并使学习更高级的Next.js特性变得更容易。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/2023/06/24/Java/Springboot/AOP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>AOP</strong>为<font color="#4f81bd">Aspect Oriented Programming</font>的缩写，意为：面向切面编程。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ol>
<li><strong>Aspect</strong>（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li>
<li><strong>Joint point</strong>（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li>
<li><strong>Pointcut</strong>（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li>
<li><strong>Advice</strong>（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li>
<li><strong>Target</strong>（目标对象）：织入 Advice 的目标对象.。</li>
<li><strong>Weaving</strong>（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在 Spring AOP 中 Joint point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 Joint point, 通过 point cut, 我们就可以确定哪些 Joint point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问.<br>为什么可以这样类比呢?</p>
<ul>
<li><p>Joint point ： 爪哇的小县城里的百姓: 因为根据定义, Joint point 是所有可能被织入 Advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 Joint point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.</p>
</li>
<li><p>Pointcut ：男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 Advice, 但是我们并不希望在所有方法上都织入 Advice, 而 Pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里 凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.</p>
</li>
<li><p>Advice ：抓过来审问, Advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.</p>
</li>
<li><p>Aspect:：Aspect 是 point cut 与 Advice 的组合, 因此在这里我们就可以类比: “根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问” 这一整个动作可以被认为是一个 Aspect.<br>![[Pasted image 20230403133722.png]]</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Springboot</category>
      </categories>
  </entry>
  <entry>
    <title>1. 什么是 Next.js</title>
    <url>/2023/07/08/React/NextJS/1.%20%E4%BB%80%E4%B9%88%E6%98%AF%20Next.js/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Next.js是一个灵活的React框架可以给你提供构建块快速创建Web应用程序。<br>但是我们实际上的意思是什么呢？让我花时间拓展一下什么是React和Next.js以及它们能提供什么帮助？</p>
<h2 id="Web应用程序的构建块"><a href="#Web应用程序的构建块" class="headerlink" title="Web应用程序的构建块"></a>Web应用程序的构建块</h2><p>这里有一些事情是你需要去考虑的，当你在构建一个现代的应用程序的时候，例如：</p>
<ul>
<li>User Interface - 用户怎么使用应用程序并与之交互</li>
<li>Routing - 用户如何在应用程序的不同部分之间导航</li>
<li>Data Fetching - 你的数据在哪以及怎么获取它们</li>
<li>Rendering - 在何时何处渲染你的静态的或者动态的内容</li>
<li>Integrations - 你使用了哪些第三方服务以及你如何连接它们</li>
<li>Infrastructure - 你在哪里部署、存储和运行你的应用程序代码</li>
<li>Performance - 怎么去为最终用户优化你的应用</li>
<li>Scalability(可扩展性、可伸缩性) -  应用程序怎么适应你的团队、数据和流量的增长</li>
<li>Developer Experience - 你的团队构建和维护你的应用程序时的体验</li>
</ul>
<p>对于你的应用程序的每一部分，你需要去决定是否需要去构建你的自己的解决方案或者使用其它的工具，例如库或者框架。</p>
<h2 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React ?"></a>什么是 React ?</h2><p>React 是一个用于构建交互式用户界面的 Javascript 库。</p>
<p>用户界面，即用户在屏幕上看到和交互的元素。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250932287.png" alt="image.png"></p>
<p>库，即 React 提供的有用的功能来构建用户界面，但是让开发人员来决定要在哪里使用这些功能。</p>
<p>React成功的部分原因是它在构建应用程序时相对的不太容易受到其他方面的影响，这导致了它第三方工具个解决方案的生态环境的繁荣。</p>
<p>然而，这也意味着从零开始构建一个完整的 React 的应用程序需要开发人员的一些努力，开发人员需要花时间去配置工具和改造那些通用的应用程序的解决方案。</p>
<h2 id="什么是-Next-js"><a href="#什么是-Next-js" class="headerlink" title="什么是 Next.js ?"></a>什么是 Next.js ?</h2><p>Next.js 是一个提供构建块去创建应用程序的React的框架。</p>
<p>通过框架，Next可以处理React所需的工具和配置，并且为你的程序提供额外的架构、特性、和优化。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250933657.png" alt="image.png"></p>
<p>你可以使用React 去构建你的用户界面，然后逐步采用Next.js的特性来解决常见的应用需求，比如路由、数据获取、集成——所有这些都可以改善开发者和最终用户的体验。</p>
<p>无论你是个人开发人员还是大型团队的一员，你都可以利用React和Next.js来构建完全交互式的、高度动态的、高性能的web应用程序。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>5. 创建你的第一个应用</title>
    <url>/2023/07/18/React/NextJS/5.%20%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要用React从头开始构建一个完整的web应用程序，你需要考虑很多重要的细节:</p>
<ul>
<li>代码必须使用像webpack这样的捆绑器进行捆绑，并使用像Babel这样的编译器进行转换。</li>
<li>您需要进行生产优化，比如代码分割。</li>
<li>您可能希望静态地预渲染一些页面以提高性能和SEO。您可能还希望使用服务器端渲染或客户端渲染。</li>
<li>您可能需要编写一些服务器端代码来将React应用程序连接到数据存储。</li>
</ul>
<p>框架可以解决这些问题。但是这样的框架必须具有适当的抽象级别——否则它将不会非常有用。它还需要拥有出色的“开发者体验”，确保你和你的团队在编写代码时拥有惊人的体验。</p>
<h2 id="Next-js-React-框架"><a href="#Next-js-React-框架" class="headerlink" title="Next.js: React 框架"></a>Next.js: React 框架</h2><p>在Next.js, React框架中。Next.js为上述所有问题提供了解决方案。但更重要的是，它会让你和你的团队在构建React应用程序时获得成功。</p>
<p>js旨在提供一流的开发人员体验和许多内置功能，例如:</p>
<ul>
<li>一个直观的基于页面的路由系统(支持动态路由)</li>
<li>静态生成（SSG）和服务器端渲染（SSR）的预渲染，都支持在每个页面上进行。</li>
<li>为了更快页面加载的自动代码分割</li>
<li>具有优化预取的客户端路由</li>
<li>内置CSS和Sass支持，并支持任何CSS-in- js库</li>
<li>支持快速刷新的开发环境</li>
<li>API路由，用于通过<code>serverless</code>函数构建API端点</li>
<li>完全可扩展的。</li>
</ul>
<p>Next.js被用于成千上万的面向生产的网站和web应用程序，包括许多世界上最大的品牌。</p>
<h2 id="关于教程"><a href="#关于教程" class="headerlink" title="关于教程"></a>关于教程</h2><p>这个免费的互动课程将指导您如何开始使用Next.js。</p>
<p>在本教程中，您将通过创建一个非常简单的博客应用程序来学习Next.js基础知识。以下是最终结果的示例:</p>
<p><a href="https://next-learn-starter.vercel.app/">https://next-learn-starter.vercel.app</a> (source)</p>
<blockquote>
<p>本教程假定具有JavaScript和React的基本知识。如果你从来没有写过React代码，你应该先阅读<a href="https://react.dev/learn/tutorial-tic-tac-toe">官方的React教程</a>。<br>如果您正在寻找文档，请访问<a href="https://nextjs.org/docs/getting-started">Next.js文档</a></p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，让我们确保您的开发环境已经准备好。</p>
<ul>
<li>如果你没有安装Node.js，从<a href="https://nodejs.org/en/">这里</a>安装。需要Node.js 10.13或更高版本。</li>
<li>在本教程中，您将使用自己的文本编辑器和终端应用程序。</li>
</ul>
<blockquote>
<p>如果您使用的是Windows，我们建议您下载Windows版本的Git，并使用它附带的Git Bash，它支持本教程中特定于unix的命令。Linux的Windows子系统(<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL</a>)是另一种选择。</p>
</blockquote>
<h2 id="创建一个-Next-js-应用"><a href="#创建一个-Next-js-应用" class="headerlink" title="创建一个 Next.js 应用"></a>创建一个 Next.js 应用</h2><p>要创建一个Next.js应用，打开你的终端，cd到你想要创建应用的目录，然后运行以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest nextjs-blog --use-npm --example &quot;https://github.com/vercel/next-learn/tree/master/basics/learn-starter&quot;</span><br></pre></td></tr></table></figure>

<p>在底层，它使用了一个名为<code>create-next-app</code>的工具，它会为你引导一个Next.js应用。它通过–<code>example</code>标志使用这个模板。</p>
<p>如果它不能工作，请看看这个页面。</p>
<h2 id="运行开发服务器"><a href="#运行开发服务器" class="headerlink" title="运行开发服务器"></a>运行开发服务器</h2><p>现在有了一个名为nextjs-blog的新目录。让我们深入了解一下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd nextjs-blog</span><br></pre></td></tr></table></figure>

<p>然后，执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>这会在端口3000上启动Next.js应用程序的“开发服务器”(稍后会详细介绍)。<br>让我们检查一下它是否有效。从浏览器打开<code>http://localhost:3000</code>。</p>
<h2 id="欢迎来到-Next-js"><a href="#欢迎来到-Next-js" class="headerlink" title="欢迎来到 Next.js"></a>欢迎来到 Next.js</h2><p>当您访问<a href="http://localhost:3000时，应该会看到这样一个页面。这是一个入门模板页面，展示了一些关于Next.js的有用信息。">http://localhost:3000时，应该会看到这样一个页面。这是一个入门模板页面，展示了一些关于Next.js的有用信息。</a></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250939260.png" alt="image.png"></p>
<blockquote>
<p>[!note]+ 帮助<br>如果你遇到了困难，你可以在GitHub讨论上联系社区。</p>
</blockquote>
<h2 id="编辑页面"><a href="#编辑页面" class="headerlink" title="编辑页面"></a>编辑页面</h2><p>让我们尝试编辑起始页。</p>
<ul>
<li>确保Next.js开发服务器仍在运行。</li>
<li>用文本编辑器打开<code>pages/index.js</code>。</li>
<li>在<code>&lt;h1&gt;</code>标签下找到“Welcome to”的文本，并将其更改为“Learn”。</li>
<li>保存文件</li>
</ul>
<p>一旦你保存了文件，浏览器就会自动用新的文本更新页面:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250939681.png" alt="image.png"></p>
<p>Next.js开发服务器启用了快速刷新功能。当您对文件进行更改时，Next.js几乎立即自动将更改应用到浏览器中。不需要刷新!这将帮助你快速迭代应用。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>2. 从Javascript到React</title>
    <url>/2023/07/09/React/NextJS/2.%20%E4%BB%8EJavascript%E5%88%B0React/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="渲染用户界面"><a href="#渲染用户界面" class="headerlink" title="渲染用户界面"></a>渲染用户界面</h2><p>为了理解React是怎么工作，我们首先需要对浏览器怎么解释你的代码去创建交互式的界面有一个基础的理解。</p>
<p>当一个用户访问网页，服务器返回给浏览器的HTML文件可能看上去是这样的：</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250933168.png" alt="image.png"></p>
<p>然后浏览器开始阅读HTML并构建文档对象模型（DOM）。</p>
<h2 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM ?"></a>什么是 DOM ?</h2><p>DOM是HTML元素的对象表现形式，它扮演了你代码和用户界面之间的桥梁，具有父级和子级关系的树形结构。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250933484.png" alt="image.png"></p>
<p>你可以使用DOM方法和编程语言，例如Javascript，去监听用户时间和操作DOM通过选择、添加、更新和删除用户界面上的指定的元素。DOM操作不仅仅只是指定元素而且允许你改变它们的样式和内容。</p>
<h2 id="更新-UI-通过-Javascript-和-DOM-方法"><a href="#更新-UI-通过-Javascript-和-DOM-方法" class="headerlink" title="更新 UI 通过 Javascript 和 DOM 方法"></a>更新 UI 通过 Javascript 和 DOM 方法</h2><p>让我们看看你怎么使用Javascript和DOM方法通过在你的项目中添加一个<code>h1</code>标签。<br>打开你的代码编辑器并且创建一个新的<code>index.html</code>文件。在htm文件中添加下面的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后给<code>div</code>元素一个唯一的<code>id</code>，以便你后面可以定位到它。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在html内部编写Javascript，添加一个<code>script</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，在<code>script</code>标签内部，你可以使用DOM方法，<code>getElementById()</code>，选中<code>div</code>元素通过<code>id</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以继续使用DOM方法来创建一个新的<code>h1</code>元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Select the div element with &#x27;app&#x27; id</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Create a new H1 element</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Create a new text node for the H1 element</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> headerContent = <span class="built_in">document</span>.createTextNode(</span></span><br><span class="line"><span class="javascript">        <span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      );</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Append the text to the H1 element</span></span></span><br><span class="line"><span class="javascript">      header.appendChild(headerContent);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Place the H1 element inside the div</span></span></span><br><span class="line"><span class="javascript">      app.appendChild(header);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了确保所有东西都能运作，在你选择的浏览器内部打开你选择的HTML文件，你会看到一个“Develop. Preview. Ship 🚀”的<code>h1</code>标签。</p>
<h2 id="HTML-vs-DOM"><a href="#HTML-vs-DOM" class="headerlink" title="HTML vs DOM"></a>HTML vs DOM</h2><p>如果你观察你的浏览器开发工具内部的DOM元素，你会注意到包括<code>h1</code>标签的DOM元素。这个页面的DOM不同于源代码或者换种说话，你创建的源HTML文件。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250934833.png" alt="image.png"></p>
<p>这是因为HTML代表的是初始页面内容，而DOM代表了被你写的Javascript代码更改后的页面内容。</p>
<p>使用原生js更新DOM是非常有力的，但是繁琐的。你已经编写了所有的代码来添加一个<code>h1</code>元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> headerContent = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  header.appendChild(headerContent);</span></span><br><span class="line"><span class="javascript">  app.appendChild(header);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>随着团队或者应用规模的增长，通过这种方式构建应用的挑战是逐步增加的。</p>
<p>使用这种方法，开发者花了很多时间写说明去告诉计算机它应该怎么做事，但是，描述你想要显示的内容并且让计算机计算如何同更新DOM不是更好吗？</p>
<h2 id="命令式编程-vs-声明式编程"><a href="#命令式编程-vs-声明式编程" class="headerlink" title="命令式编程 vs 声明式编程"></a>命令式编程 vs 声明式编程</h2><p>上面的代码是命令式编程的一个好例子，你编写如何更新UI的步骤。但是对于构建UI，声明式的方法往往更好，因为它可以加速开发过程。如果开发者能声明他们想去显示的这将是有用的，而不是去写DOM方法。</p>
<p>换句话说，命令式编程就像是给一个厨师如何一步步制作披萨的说明书，声明式编程就是去买一个披萨而不用考虑制作披萨的步骤。</p>
<p>React是一个流行的帮助开发者构建用户界面的声明库。</p>
<h2 id="React-一个声明式的UI库"><a href="#React-一个声明式的UI库" class="headerlink" title="React: 一个声明式的UI库"></a>React: 一个声明式的UI库</h2><p>作为一个开发者，你可以告诉React你让要让用户界面发生什么，React会代替你弄清楚怎么更新DOM的步骤。</p>
<p>在下一个部分，我们会探索如何开始使用React。</p>
<h2 id="开始使用-React"><a href="#开始使用-React" class="headerlink" title="开始使用 React"></a>开始使用 React</h2><p>为了使用React，你可以从 unpkg.com 加载两个React脚本。</p>
<ul>
<li>react 是核心React库</li>
<li>react-dom提供了特定的方法是您能够将React与DOM一起使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以使用<code>react-dom</code>的<code>React.render()</code>来告诉React在<code>#app</code>元素中渲染<code>h1</code>,而不是直接使用原生js来操作DOM.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，如果你试图在浏览器中运行这段代码，你将会得到一个 syntax error(语法错误)。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250934175.png" alt="image.png"></p>
<p>这是因为<code>&lt;h1&gt;...&lt;/h1&gt;</code>在Javascript中是无效的，这是一段<code>JSX</code>代码。</p>
<h2 id="什么是-JSX"><a href="#什么是-JSX" class="headerlink" title="什么是 JSX ?"></a>什么是 JSX ?</h2><p>JSX 是JavaScript的语法拓展，允许你描述你的UI使用类似于HTML的语法，一件很棒的事情就是除了三条JSX的规则你需要知道以外，就没有HTML和Javascript之外的别的新的标识符或者语法需要学习了。</p>
<p>需要注意的是，浏览器不能直接理解JSX，所以你需要一个Javascript编译器，例如<code>Babel</code>，去把你的JSX代码转换成常规的Javascript。</p>
<h2 id="添加-Babel-到你的项目"><a href="#添加-Babel-到你的项目" class="headerlink" title="添加 Babel 到你的项目"></a>添加 Babel 到你的项目</h2><p>将下面的脚本复制粘贴到你的<code>index.html</code>中就将Babel添加到了你的项目中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除此之外，你需要通过改变脚本类型为<code>type=text/jsx</code>来通知Babel要转换的是什么代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Babel Script --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以在浏览器中运行你的代码去确保它是正常工作的。</p>
<p>比较你写的React的声明式代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和你在之前的部分写的命令式代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> headerContent = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  header.appendChild(headerContent);</span></span><br><span class="line"><span class="javascript">  app.appendChild(header);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用React你可以节省大量的重复代码。</p>
<p>这正是React做的，它包括一些可重复执行的代码片段，这些代码可以代替你执行任务，在这个例子中是代替你更新UI。</p>
<h2 id="React-必备的-Javascript"><a href="#React-必备的-Javascript" class="headerlink" title="React 必备的 Javascript"></a>React 必备的 Javascript</h2><p>虽然你可以同时学习Javascript和React，但是熟悉Javascript可以使你学习React的过程更简单。</p>
<p>在下一部分中，会从Javascript的角度为你介绍一些React的核心概念，这是将会提到的Javascript主题的概要。</p>
<ul>
<li>Functions and Arrow Functions</li>
<li>Objects</li>
<li>Arrays and Array methods</li>
<li>Destructuring（解构赋值）</li>
<li>Template Literals（字面量）（模板字符串）</li>
<li>Ternary Operators（三元操作符）</li>
<li>ES Modules and Import/Export Syntax</li>
</ul>
<p>虽然这个课程不会深入Javascript，使用最新的版本去联系Javascript是一种好的做法，但是如果你感觉还不精通Javascript，这不妨碍你开始使用React。</p>
<blockquote>
<p>stay up to date（与时俱进）<br>proficient adj 精通的、熟练的<br>hinder v 阻碍 </p>
</blockquote>
<h2 id="React-核心概念"><a href="#React-核心概念" class="headerlink" title="React 核心概念"></a>React 核心概念</h2><p>开始使用React你有三个核心概念需要熟悉，分别是：</p>
<ul>
<li>Components</li>
<li>Props</li>
<li>State</li>
</ul>
<p>在下一个部分，我们将会继续学习上面的概念，并且提供继续学习的资源。</p>
<h2 id="使用-Component-构建-UI"><a href="#使用-Component-构建-UI" class="headerlink" title="使用 Component 构建 UI"></a>使用 Component 构建 UI</h2><p>UI能被分解到称为Component的更小的构建块。</p>
<p>Components允许你创建自包含的、可重复使用的代码片段，如果你把component看作乐高砖块，你可以把这些独立的砖块组合成更大的结构。如果你需要去更新一部分UI，你可以更新特定的容器或砖块。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250935877.png" alt="image.png"></p>
<p>模块化使你的代码增长时的可维护性更好，因为你可以简单的添加、更新和删除component在没有改变应用的其他部分代码的情况下。</p>
<p>React Component很棒的一件事是它们只是Javascript，让我们看看从Javascript的角度如何编写React Component。</p>
<h3 id="创建Component"><a href="#创建Component" class="headerlink" title="创建Component"></a>创建Component</h3><p>在React中，component是函数。在你的<code>script</code>tag内部，写一个叫做<code>header</code>的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>一个component是一个返回UI元素的方法，在函数的返回声明中你可以编写JSX。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  ReactDOM.render(, app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>为了把component渲染成DOM，你可以把它当作第一个参数传递到<code>ReactDOM.render()</code>方法中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ReactDOM.render(header, app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>等一等，如果你尝试在浏览器中运行上面的代码，你会得到一个错误，为了使他工作，这里两件事情必须要做。</p>
<p>首先，React component应该是首字母大写的以区别于原生HTML和Javascript。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capitalize the React Component</span></span><br><span class="line">ReactDOM.render(Header, app);</span><br></pre></td></tr></table></figure>

<p>第二，你使用React component的方式应该和使用常规HTML标签一样，使用角括号<code>&lt;&gt;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<h3 id="嵌套组件"><a href="#嵌套组件" class="headerlink" title="嵌套组件"></a>嵌套组件</h3><p>应用往往有更多的内容而不止一个单独的组件，你可以嵌套使用每一个React components就像使用常规HTML标签一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<p>然后再<code>&lt;HomePage&gt;</code>中嵌套使用<code>&lt;Header&gt;</code>component。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* Nesting the Header component */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<h3 id="组件树"><a href="#组件树" class="headerlink" title="组件树"></a>组件树</h3><p>你可以通过这种方式继续嵌套component，形成组件树。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250935566.png" alt="image.png"></p>
<p>例如，您的顶级主页组件可以包含一个Header、一个Article和一个Footer组件。每个组件都可以有自己的子组件，以此类推。例如，Header组件可以包含徽标、标题和导航组件。</p>
<p>模块化的格式允许你在应用的内部的不同地方复用组件。</p>
<p>在你的项目中，因为&lt;首页&gt;现在是你的顶层组件，你可以把它传递给ReactDOM.render()方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<p>在下一部分中，我们会讨论<code>props</code>并且使用它们去在你的component中传递数据。</p>
<blockquote>
<p>break down 分解、细化<br>modularity n 模块化<br>modular adj 模块化的<br>statement n 语句、声明<br>argument n 参数<br>capitalize v 大写<br>distinguish v 区别<br>bracket n 括号、支架<br>nesting component 嵌套组件<br>and so no 以此类推、等等<br>in turn 依次、轮流<br>since conj 因为</p>
</blockquote>
<h2 id="使用-Props-展示数据"><a href="#使用-Props-展示数据" class="headerlink" title="使用 Props 展示数据"></a>使用 Props 展示数据</h2><blockquote>
<p>so far 到目前为止<br>what if 如果…会…<br>ahead of time 提前、事先<br>explictly adv 显式的<br>denote v 表示</p>
</blockquote>
<p>到目前为止，如果你复用<code>&lt;Header/&gt;</code>组件，它将会两次显示相同的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果你想传递不同的数据或者你提前不知道信息，因为你是从一个外部的数据源获取数据。</p>
<p>常规的HTML元素存在能让你传递一段改变元素行为的信息的属性。例如，改变<code>img</code>元素的<code>src</code>属性去改变显示的图片，改变<code>a</code>标签的<code>href</code>属性去改变链接的目的地址。</p>
<p>通过相同的方式，你可以传递一段信息作为属性给React组件，这叫做<code>Props</code></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250936588.png" alt="image.png"></p>
<p>类似于JavaScript函数，你可以设计组件去接受自定义的参数去改变组件的行为或者是在渲染到屏幕上的时候什么是可视的。你可以往下传递这些属性从父组件到子组件。</p>
<blockquote>
<p>[!note]+<br>在React中，数据沿着组件树往下流，这被称作单向数据流状态，将会在下一部分讨论这个，可以作为props从父组件传递到子组件。</p>
</blockquote>
<h2 id="使用-Props"><a href="#使用-Props" class="headerlink" title="使用 Props"></a>使用 Props</h2><p>在你的<code>HomePage</code>组件，你可以传递一个自定义的<code>title</code>到<code>Header</code>组件，就像你传递HTML属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function Header() &#123;</span></span><br><span class="line"><span class="comment">//   return &lt;h1&gt;Develop. Preview. Ship. 🚀&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;React 💙&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>然后<code>Header</code>组件可以接受这些props作为它的第一个函数参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="comment">//   return &lt;h1&gt;Develop. Preview. Ship. 🚀&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>如果你<code>console.log()</code>props，它是一个有着<code>title</code>属性的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props) <span class="comment">// &#123; title: &quot;React 💙&quot; &#125;</span></span><br><span class="line"><span class="comment">//   return &lt;h1&gt;React 💙&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>因为props是一个对象，你可以使用<code>object destrcuturing</code>显式地命名函数参数中的props值:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(title) <span class="comment">// &quot;React 💙&quot;</span></span><br><span class="line"><span class="comment">//  return &lt;h1&gt;React 💙&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>然后你可以使用你的<code>title</code>变量去取代你<code>h1</code>标签中的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(title);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你打开你的项目在浏览器中，你将会看到它显示的实际的单词是<code>title</code>，这是因为React认为你趋向于渲染一个纯文本字符串到DOM。</p>
<h2 id="在-JSX-中使用变量"><a href="#在-JSX-中使用变量" class="headerlink" title="在 JSX 中使用变量"></a>在 JSX 中使用变量</h2><blockquote>
<p>[!note]+<br>curly adj 卷曲的 n 卷毛<br>brace n 括号 支架 v 撑住<br>directly adv 直接地<br>markup n 标记、涨价、利润<br>evaluate v 计算、估算、评估<br>notation n 符号、记号、注释<br>account v 解释、把…视作，说明<br>generic adj 一般的、通用的<br>iterate v 迭代<br>iterating through lists 遍历数组<br>identical adj 完全一样的<br>identify v 识别、认出、确认<br>unopinionated adj 不受限制的、无强烈观点的、不固执己见的<br>weave v 编织、迂回<br>guaranteed adj 肯定的、保障的、有担保的</p>
</blockquote>
<p>为了使用你定义的变量，你可以使用花括号<code>&#123;&#125;</code>，一种特殊的JSX语法，允许你在JSX标记中直接编写常规的js。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function Header(&#123;title&#125;) &#123;</span></span><br><span class="line"><span class="comment">//  console.log(title)</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>当你在“JSX领域”时，你可以把花括号看作是进入“JavaScript领域”的一种方式。可以在花括号内添加任何JavaScript表达式(计算结果为单个值的表达式)。例如:</p>
<ol>
<li>一个带有点符号的对象属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>模板字符串</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Cool $&#123;title&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数返回值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTitle</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (title) &#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Default title&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;createTitle(title)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>三元操作符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default Title&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你现在给以传递任何字符串给你的<code>title</code>属性，因为你已经用三元操作符解释了组件中的默认情况，你甚至可以根本不传递title prop:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default title&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您的组件现在接受一个通用的<code>title</code>属性，您可以在应用程序的不同部分重用它。你所需要做的就是改变标题:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;React 💙&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;A new title&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>通常需要将数据显示为列表。您可以使用数组方法来操作数据并生成样式相同但包含不同信息的UI元素。</p>
<blockquote>
<p>[!note]+<br>当涉及到数据获取时，React是不受限制的，这意味着你可以选择最适合你需要的解决方案。稍后，我们将讨论Next.js中的数据获取选项。但是现在，您可以使用一个简单的数组来表示数据</p>
</blockquote>
<p>在你的<code>HomePage</code>组件中添加一个名字数组:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以使用<code>array.map()</code>方法迭代数组，并使用箭头函数将名称映射到列表项:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark style="background: #FF5582A6;">请注意，您是如何使用花括号在“JavaScript”和“JSX”之间来回穿梭的。</mark></p>
<p>如果你运行这段代码，React会给我们一个关于丢失的key prop的警告。这是因为React需要一些东西来唯一地标识数组中的项，以便它知道要更新DOM中的哪些元素。</p>
<p>您现在可以使用名称，因为它们目前是唯一的，但建议使用保证唯一的东西，例如项目ID。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-State-添加交互性"><a href="#使用-State-添加交互性" class="headerlink" title="使用 State 添加交互性"></a>使用 State 添加交互性</h2><p>让我们探索React怎么使用State和event handlers帮我们添加交互性。</p>
<p>举个例子，让我们创建一个<code>like</code>按钮在你的<code>HomePage</code>组件内部，首先在<code>return</code>语句里面添加一个<code>button</code>元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>为了使按钮在点击的时候能干一些事情，你可以使用点击事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;&#125;</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在React中，事件名是驼峰大小写的。<code>onClick</code>事件是可用于响应用户交互的许多可能事件之一。例如，您可以对输入字段使用<code>onChange</code>或对表单使用<code>onSubmit</code>。</p>
<h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><p>你可以定义一个函数去处理事件不管它们什么时候被触发，创建一个函数在return语句之前调用<code>handleClick()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;increment like count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;&#125;</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以调用<code>handleClick</code>函数当<code>onclick</code>事件被触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//    ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;increment like count&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="State-和-hooks"><a href="#State-和-hooks" class="headerlink" title="State 和 hooks"></a>State 和 hooks</h2><p>React有一组叫做hooks的函数。钩子允许您向组件添加额外的逻辑，例如状态。您可以将状态视为UI中随时间变化的信息，通常由用户交互触发。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250936495.png" alt="image.png"></p>
<p>您可以使用state来存储和增加用户单击like按钮的次数。实际上，<code>useState()</code>就是用于管理状态的React钩子的名称:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function HomePage() &#123;</span><br><span class="line">  React.useState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的第一项是状态值，您可以将其命名为任何值。建议给它起一个描述性的名字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [likes] = React.useState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的第二项是更新值的函数。你可以给更新函数取任何名字，但通常在它的前面加上set，后面跟着你要更新的状态变量的名字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = React.useState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以借此机会添加<code>like</code>状态的初始值:<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，您可以使用组件内部的状态变量来检查初始状态是否正常工作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like(&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，你可以在<code>HomePage</code>组件中调用状态更新函数<code>setLikes</code>，让我们把它添加到你之前定义的<code>handleClick()</code>函数中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setLikes(likes + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Likes (&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单击按钮现在将调用<code>handleClick</code>函数，该函数调用<code>setLikes</code>状态更新函数，参数为当前<code>like+ 1</code>。</p>
<blockquote>
<p>[!note]+<br>与props作为第一个函数参数传递给组件不同，状态是在组件中初始化和存储的。您可以将状态信息作为道具传递给子组件，但是更新状态的逻辑应该保留在最初创建状态的组件中。</p>
</blockquote>
<h2 id="怎么继续学习-React"><a href="#怎么继续学习-React" class="headerlink" title="怎么继续学习 React"></a>怎么继续学习 React</h2><p>你刚被介绍了三个基础的概念：components, props, state。在这些方面打下坚实的基础将有助于您开始构建React应用程序。一旦你感觉更自信了，也可以看看其他React主题:</p>
<blockquote>
<p>React怎么处理renders和怎么使用refs<br>怎么去管理state<br>怎么使用context对于深度嵌套的数据<br>怎么使用React API hooks，比如<code>useEffect()</code></p>
</blockquote>
<h2 id="React-资源"><a href="#React-资源" class="headerlink" title="React 资源"></a>React 资源</h2><p>多年来，已经创建了许多课程、视频和文章来帮助开发人员学习React。虽然很难推荐适合你学习风格的资源，但<a href="https://beta.reactjs.org/learn">React文档</a>是一个非常宝贵的参考，它包含交互式沙盒来帮助你练习这些主题。</p>
<p>说到学习React，<span style="background:#ff4d4f">最好的学习方式就是构建</span>。你可以通过使用<code>&lt;script&gt;</code>和你所学到的东西逐渐采用React，为现有的网站添加小组件。然而，许多开发人员已经发现，React提供的用户和开发人员体验足够有价值，可以直接使用React编写整个前端项目。</p>
<h2 id="从-React-到-Next-js"><a href="#从-React-到-Next-js" class="headerlink" title="从 React 到 Next.js"></a>从 React 到 Next.js</h2><p>虽然React擅长构建UI，但要独立地将UI构建成一个功能齐全的可扩展应用程序确实需要一些工作。好消息是，Next.js处理了大部分的设置和配置，并提供了额外的功能来帮助您构建React应用程序。</p>
<p>接下来，我们将把这个例子从React迁移到Next.js，讨论Next.js是如何工作的，并介绍一些web开发概念来帮助你学习更高级的Next.js功能。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>6. 页面间导航</title>
    <url>/2023/07/18/React/NextJS/6.%20%E9%A1%B5%E9%9D%A2%E9%97%B4%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>到目前为止，我们创建的Next.js应用程序只有一个页面。网站和web应用程序通常有许多不同的页面。</p>
<p>让我们探索一下如何向应用程序添加更多页面。</p>
<h2 id="我们将在课程里面学到什么"><a href="#我们将在课程里面学到什么" class="headerlink" title="我们将在课程里面学到什么"></a>我们将在课程里面学到什么</h2><p>在这门课中，你将会：</p>
<ul>
<li>使用集成的文件系统路由创建一个新页面</li>
<li>了解如何使用<code>Link</code>组件在页面之间启用客户端导航</li>
<li>了解对代码分割和预取的内置支持</li>
</ul>
<blockquote>
<p>[!note]<br>如果你正在寻找关于Next.js路由的详细文档，请查看<a href="https://nextjs.org/docs/routing/introduction">路由文档</a></p>
</blockquote>
<h2 id="Next-js-中的-Pages"><a href="#Next-js-中的-Pages" class="headerlink" title="Next.js 中的 Pages"></a>Next.js 中的 Pages</h2><p>在Next.js中，页面是从<code>pages</code>目录下的文件导出的React组件。</p>
<p>页面根据其文件名与路由相关联。例如，在开发中:</p>
<ul>
<li><code>pages/index.js</code>与/路由相关联。</li>
<li><code>pages/posts/first-post.js</code>与<code>/posts/first-post</code>路由相关联。</li>
</ul>
<p>我们已经有了<code>pages/index.js</code>文件，所以让我们创建<code>pages/posts/first-post.js</code>来看看它是如何工作的。</p>
<h2 id="创建一个新页面"><a href="#创建一个新页面" class="headerlink" title="创建一个新页面"></a>创建一个新页面</h2><p>在<code>pages</code>下创建posts目录。</p>
<p>在<code>posts</code>目录下创建一个名为<code>first-post.js</code>的文件，内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件可以有任何名称，但必须将其导出为默认导出。</p>
<p>现在，确保开发服务器正在运行并访问<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>。您应该看到以下页面:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250940702.png" alt="image.png"></p>
<p>这就是在Next.js中创建不同页面的方法。</p>
<p>只需在pages目录下创建一个JS文件，该文件的路径就变成了URL路径。</p>
<p>在某种程度上，这类似于使用HTML或PHP文件构建网站。而不是写HTML，你写JSX和使用React组件。</p>
<p>让我们添加一个指向新添加页面的链接，以便我们可以从主页导航到它。</p>
<h2 id="链接组件"><a href="#链接组件" class="headerlink" title="链接组件"></a>链接组件</h2><p>当在网站上的页面之间进行链接时，可以使用<code>&lt;a&gt;</code> HTML标签。</p>
<p>在next .js中，你可以使用链接组件<code>next/link</code>来链接应用程序中的页面。<code>&lt;Link&gt;</code>允许您进行客户端导航，并接受让您更好地控制导航行为的属性。</p>
<h2 id="使用-Link"><a href="#使用-Link" class="headerlink" title="使用 Link"></a>使用 Link</h2><p>首先，打开<code>pages/index.js</code>，从<code>next/link</code>中导入<code>Link</code>组件，在顶部添加这一行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后找到<code>h1</code>标签，看起来像这样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 className=<span class="string">&quot;title&quot;</span>&gt;</span><br><span class="line">  Welcome to &lt;a href=<span class="string">&quot;https://nextjs.org&quot;</span>&gt;Next.js!&lt;/a&gt;</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>把它改成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 className=<span class="string">&quot;title&quot;</span>&gt;</span><br><span class="line">  Read &lt;Link href=<span class="string">&quot;/posts/first-post&quot;</span>&gt;<span class="built_in">this</span> page!&lt;/Link&gt;</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，打开pages/posts/first-post.js并将其内容替换为以下内容:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，Link组件类似于使用<code>&lt;a&gt;</code>标记，但是您使用的不是<code>&lt;a href=&quot;…&quot;&gt;</code>，而是<code>&lt;Link href=&quot;…&quot;&gt;</code>。</p>
<blockquote>
<p>[!note]<br>在<code>Next.js 12.2</code>之前，Link组件需要包装一个<code>&lt;a&gt;</code>标签，但在<code>12.2</code>及以上版本中不需要这样做。</p>
</blockquote>
<p>让我们检查一下它是否有效。现在你应该在每个页面上都有一个链接，允许你来回浏览:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250940555.png" alt="image.png"></p>
<h2 id="客户端导航"><a href="#客户端导航" class="headerlink" title="客户端导航"></a>客户端导航</h2><p><code>Link</code>组件支持在同一个Next.js应用中的两个页面之间进行客户端导航。</p>
<p>客户端导航意味着使用JavaScript进行页面转换，这比浏览器的默认导航要快。</p>
<ul>
<li>使用浏览器的开发者工具将<code>&lt;html&gt;</code>的<code>background</code> CSS属性更改为黄色</li>
<li>点击链接可以在两个页面之间来回切换</li>
<li>您将看到，在页面转换之间，黄色背景仍然存在</li>
</ul>
<p>这表明浏览器没有加载整个页面，客户端导航正在工作</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250941935.png" alt="image.png"></p>
<p>如果您使用的是<code>&lt;a href=&quot;…&quot;&gt;</code>而不是<code>&lt;Link href=&quot;…&quot;&gt;</code>，那么单击链接时背景颜色将被清除，因为浏览器会进行完全刷新。</p>
<h2 id="代码分割和预取"><a href="#代码分割和预取" class="headerlink" title="代码分割和预取"></a>代码分割和预取</h2><p>Next.js会自动进行代码分割，因此每个页面只加载该页所需的内容。这意味着在呈现主页时，最初不会提供其他页面的代码。</p>
<p>这确保了即使你有数百个页面，主页也能快速加载。</p>
<p>只加载所请求页面的代码也意味着页面将被隔离。如果某个页面抛出错误，应用程序的其余部分仍然可以工作。</p>
<p>此外，在Next.js的生产构建中，每当<code>Link</code>组件出现在浏览器的视图中，Next.js都会自动在后台预取链接页面的代码。当您单击链接时，目标页面的代码将已经在后台加载，并且页面转换将几乎是即时的!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js通过代码分割、客户端导航和预取(在生产中)自动优化应用程序，以获得最佳性能。</p>
<p>您可以将路由创建为页面下的文件，并使用内置的Link组件。不需要路由库。</p>
<p>你可以在<code>next/link</code>的<a href="https://nextjs.org/docs/api-reference/next/link">API参考</a>中了解更多关于<code>Link</code>组件的信息，在路由<a href="https://nextjs.org/docs/routing/introduction">文档</a>中了解路由的一般情况。</p>
<blockquote>
<p>[!note]<br>如果你需要链接到Next.js应用程序之外的外部页面，只需使用不带link的<code>&lt;a&gt;</code>标签。</p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>8. 预渲染和数据获取</title>
    <url>/2023/07/22/React/NextJS/8.%20%E9%A2%84%E6%B8%B2%E6%9F%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们想创建一个博客(这是<a href="https://next-learn-starter.vercel.app/">期望的结果</a>)，但是到目前为止我们还没有添加任何博客内容。在本课中，我们将学习如何获取外部博客数据到我们的应用程序中。我们将在文件系统中存储博客内容，但如果内容存储在其他地方(例如数据库或<a href="https://en.wikipedia.org/wiki/Headless_content_management_system">Headless CMS</a>)，它将工作。</p>
<h2 id="你将在本课中学到什么"><a href="#你将在本课中学到什么" class="headerlink" title="你将在本课中学到什么"></a>你将在本课中学到什么</h2><p>在这门课中，你将会学到：</p>
<ul>
<li>Next.js的预渲染特性</li>
<li>两种预渲染的形式：静态生成和服务端渲染</li>
<li>有数据的静态生成和没数据的静态生成</li>
<li>怎么使用<code>getStaticProps</code>去导入外部博客的数据到首页</li>
<li>关于<code>getStaticProps</code>的一些有用的信息</li>
</ul>
<h2 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h2><p>在我们讨论数据获取之前，让我们先讨论一个Next.js最重要的数据：预渲染</p>
<p>默认情况下，Next.js会预渲染每个页面。这意味着Next.js提前为每个页面生成HTML，而不是让客户端JavaScript完成所有工作。预渲染可以带来更好的性能和<a href="https://en.wikipedia.org/wiki/Search_engine_optimization">SEO</a>。</p>
<p>每个生成的HTML都与该页所需的最少JavaScript代码相关联。当浏览器加载页面时，它的JavaScript代码运行并使页面完全交互式。(这个过程被称为水合作用)</p>
<p>你可以通过以下步骤检查预渲染是否正在发生:</p>
<ul>
<li>在浏览器中禁用JavaScript。(<a href="https://developer.chrome.com/docs/devtools/javascript/disable/">以下是在Chrome中的做法</a>)。</li>
<li>尝试访问此页面(本教程的<a href="https://next-learn-starter.vercel.app/">最终结果</a>)</li>
</ul>
<p>你应该会看到你的应用是在没有JavaScript的情况下呈现的。这是因为Next.js已经将应用程序预渲染为静态HTML，允许您在不运行JavaScript的情况下查看应用程序UI。</p>
<blockquote>
<p>[!note]<br>您也可以在本地主机上尝试上述步骤，但如果禁用JavaScript，则不会加载CSS。</p>
</blockquote>
<p>如果你的应用程序是一个纯React.js应用程序(没有Next.js)，没有预渲染，所以如果你禁用JavaScript，你将无法看到应用程序。例如:</p>
<blockquote>
<p>在浏览器中启用JavaScript并查看此页面。这是一个用Create React app构建的普通React.js应用程序。<br>现在，禁用JavaScript并再次访问同一页面。<br>你不会再看到应用程序了——相反，它会说“你需要启用JavaScript来运行这个应用程序。”这是因为应用程序没有预先渲染成静态HTML。</p>
</blockquote>
<h2 id="摘要-预渲染-vs-不预渲染"><a href="#摘要-预渲染-vs-不预渲染" class="headerlink" title="摘要: 预渲染 vs 不预渲染"></a>摘要: 预渲染 vs 不预渲染</h2><p>这里有一个快速的图形摘要:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250943273.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250944795.png" alt="image.png"></p>
<p>接下来，让我们讨论一下Next.js中的两种预渲染形式。</p>
<h2 id="预渲染的两种形式"><a href="#预渲染的两种形式" class="headerlink" title="预渲染的两种形式"></a>预渲染的两种形式</h2><p>Next.js有两种形式的预渲染:<code>静态生成和服务器端渲染</code>。不同之处在于它何时为页面生成HTML。</p>
<ul>
<li>静态生成是在构建时生成HTML的预呈现方法。然后在每个请求中重用预呈现的HTML。</li>
<li>服务器端渲染是在每个请求上生成HTML的预渲染方法。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250944022.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250944745.png" alt="image.png"></p>
<blockquote>
<p>在开发模式下(当你运行npm run dev或yarn dev时)，每个请求都会预渲染页面。这也适用于静态生成，使其更容易开发。当进入生产环境时，静态生成将在构建时发生一次，而不是在每个请求上。</p>
</blockquote>
<h2 id="Per-page-Basis"><a href="#Per-page-Basis" class="headerlink" title="Per-page Basis"></a>Per-page Basis</h2><p>重要的是，Next.js允许您选择为每个页面使用哪个预呈现表单。你可以创建一个“混合型”Next.js应用，对大多数页面使用静态生成，对其他页面使用服务器端渲染。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250944158.png" alt="image.png"></p>
<h2 id="什么时候去使用静态生成或者服务端渲染"><a href="#什么时候去使用静态生成或者服务端渲染" class="headerlink" title="什么时候去使用静态生成或者服务端渲染"></a>什么时候去使用静态生成或者服务端渲染</h2><p>我们建议<code>尽可能使用静态生成</code>(带或不带数据)，因为您的页面可以构建一次并由CDN提供服务，这比让服务器在每个请求上呈现页面要快得多。</p>
<p>您可以对许多类型的页面使用静态生成，包括:</p>
<ul>
<li>营销页面</li>
<li>博客文章</li>
<li>电子商务产品目录</li>
<li>帮助和文档</li>
</ul>
<p>你应该问自己:“我能在用户请求之前预渲染这个页面吗?”如果答案是肯定的，那么您应该选择静态生成。</p>
<p>另一方面，如果您不能在用户请求之前预渲染页面，那么静态生成就不是一个好主意。也许您的页面显示频繁更新的数据，并且页面内容在每次请求时都会更改。</p>
<p>在这种情况下，您可以使用服务器端渲染。它会慢一些，但是预渲染的页面总是最新的。或者可以跳过预渲染，使用客户端JavaScript填充频繁更新的数据。</p>
<h2 id="我们会聚焦在静态生成"><a href="#我们会聚焦在静态生成" class="headerlink" title="我们会聚焦在静态生成"></a>我们会聚焦在静态生成</h2><p>在本课中，我们将重点介绍<a href="https://nextjs.org/docs/basic-features/pages#static-generation-recommended">静态生成</a>。在下一页中，我们将讨论带数据和不带数据的静态生成。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>7. &#39;Assets, Metadata和CSS&#39;</title>
    <url>/2023/07/19/React/NextJS/7.%20Assets,%20Metadata%E5%92%8CCSS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们添加的第二个页面目前没有样式。让我们添加一些CSS来设置页面的样式。</p>
<p>js内置了对CSS和Sass的支持。在本课程中，我们将使用CSS。</p>
<p>本课还将讨论Next.js如何处理静态资产，如图像和页面元数据，如<code>&lt;title&gt;</code>标签。</p>
<h2 id="你将在这节课学到什么"><a href="#你将在这节课学到什么" class="headerlink" title="你将在这节课学到什么"></a>你将在这节课学到什么</h2><p>在这节课中，你将学习:</p>
<ul>
<li>如何添加静态文件(图像等)到Next.js。</li>
<li>如何自定义每个页面<code>&lt;head&gt;</code>中的内容。</li>
<li>如何使用CSS模块创建一个可重用的React组件。</li>
<li>如何在<code>pages/_app.js</code>中添加<a href="https://nextjs.org/docs/basic-features/built-in-css-support#adding-a-global-stylesheet">全局CSS</a>。</li>
<li>在Next.js中使用样式的一些有用提示。</li>
</ul>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul>
<li>基本的CSS知识。本课程将介绍如何在Next.js应用程序中添加CSS，但它不会涵盖CSS基础知识。</li>
</ul>
<blockquote>
<p>如果你正在寻找关于Next.js样式的详细文档，请查看<a href="https://nextjs.org/docs/basic-features/built-in-css-support">CSS文档</a>。</p>
</blockquote>
<h2 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h2><p>Next.js可以在顶级<code>public</code>目录下提供静态资产，比如图像。<code>public</code>中的文件可以从应用程序的根目录引用，类似于页面。</p>
<p><code>public</code>目录对于<code>robots.txt</code>、Google Site Verification和任何其他静态资产也很有用。请查看静态文件服务的<a href="https://nextjs.org/docs/basic-features/static-file-serving">文档</a>以了解更多信息。</p>
<h3 id="下载个人资料图片"><a href="#下载个人资料图片" class="headerlink" title="下载个人资料图片"></a>下载个人资料图片</h3><p>首先，让我们找回你的头像。</p>
<ul>
<li>下载<code>.jpg</code>格式的个人资料图片(或使用<a href="https://github.com/vercel/next-learn/blob/master/basics/basics-final/public/images/profile.jpg">此文件</a>)。</li>
<li>在<code>public</code>目录中创建一个<code>images</code>目录。</li>
<li>将图片保存为<code>profile.jpg</code>到<code>public/images</code>目录下。</li>
<li>图像大小可以在<code>400px * 400px</code>左右。</li>
<li>您可以直接在<code>public</code>目录下删除未使用的SVG徽标文件。</li>
</ul>
<h3 id="Unoptimized-Image"><a href="#Unoptimized-Image" class="headerlink" title="Unoptimized Image"></a>Unoptimized Image</h3><p>使用常规HTML，您将添加您的个人资料图片如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/profile.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Your Name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而，这意味着你必须手动处理:</p>
<ul>
<li>确保您的图像在不同的屏幕尺寸上响应</li>
<li>使用第三方工具或库优化您的图像</li>
<li>只当它们进入视口才加载图像</li>
</ul>
<p>相反，Next.js提供了一个现成的<code>Image</code>组件来为您处理这个问题。</p>
<h3 id="图像组件和图像优化"><a href="#图像组件和图像优化" class="headerlink" title="图像组件和图像优化"></a>图像组件和图像优化</h3><p><code>next/image</code>是HTML <code>&lt;img&gt;</code>元素的扩展，为现代Web而进化。</p>
<p>Next.js默认情况下也支持图像优化。这允许在浏览器支持的情况下以现代格式(如<a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types#webp">WebP</a>)调整大小、优化和提供图像。这避免了将大图像传送到具有较小视口的设备上。它还允许Next.js自动采用未来的图像格式，并将它们提供给支持这些格式的浏览器。</p>
<p>自动图像优化工程与任何图像源。即使图像由外部数据源(如CMS)托管，也可以对其进行优化。</p>
<h3 id="使用图像组件"><a href="#使用图像组件" class="headerlink" title="使用图像组件"></a>使用图像组件</h3><p>Next.js不是在构建时优化图像，而是在用户请求时按需优化图像。与静态站点生成器和纯静态解决方案不同，无论是发送10个图像还是1000万个图像，构建时间都不会增加。</p>
<p>默认情况下，图像是延迟加载的。这意味着您的页面速度不会因视窗外的图像而受到影响。图像在滚动到视窗时加载。</p>
<p>图像总是以这样一种方式呈现，以避免<a href="https://web.dev/cls/">Cumulative Layout Shift</a>，这是谷歌将在搜索排名中使用的<a href="https://web.dev/vitals/#core-web-vitals">Core Web Vital</a>。</p>
<p>下面是一个使用<code>next/image</code>来显示个人资料图片的例子。高度和宽度属性应该是所需的渲染大小，具有与源图像相同的宽高比。</p>
<p><strong>Note</strong>:我们将在后面的“Polishing Layout”中使用这个组件，现在还不需要复制它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Image <span class="keyword">from</span> <span class="string">&#x27;next/image&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YourComponent = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">src</span>=<span class="string">&quot;/images/profile.jpg&quot;</span> // <span class="attr">Route</span> <span class="attr">of</span> <span class="attr">the</span> <span class="attr">image</span> <span class="attr">file</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">height</span>=<span class="string">&#123;144&#125;</span> // <span class="attr">Desired</span> <span class="attr">size</span> <span class="attr">with</span> <span class="attr">correct</span> <span class="attr">aspect</span> <span class="attr">ratio</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">width</span>=<span class="string">&#123;144&#125;</span> // <span class="attr">Desired</span> <span class="attr">size</span> <span class="attr">with</span> <span class="attr">correct</span> <span class="attr">aspect</span> <span class="attr">ratio</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">alt</span>=<span class="string">&quot;Your Name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">  /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要了解有关自动图像优化的更多信息，请查看<a href="https://nextjs.org/docs/basic-features/image-optimization">文档</a>。<br>要了解更多关于Image组件的信息，请查看<code>next/image</code>的<a href="https://nextjs.org/docs/api-reference/next/image">API参考</a>。</p>
</blockquote>
<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>如果我们想修改页面的元数据，比如<code>&lt;title&gt;</code> HTML标记，该怎么办?</p>
<p><code>&lt;title&gt;</code>是<code>&lt;head&gt;</code> HTML标记的一部分，因此让我们深入了解如何在Next.js页面中修改<code>&lt;head&gt;</code>标记。</p>
<p>在编辑器中打开<code>pages/index.js</code>，找到以下几行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Head&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Create Next App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/Head&gt;</span><br></pre></td></tr></table></figure>

<p>注意，这里使用了<code>&lt;Head&gt;</code>而不是小写的<code>&lt;head&gt;</code>。<code>&lt;Head&gt;</code>是一个内置于Next.js中的React组件。它允许您修改页面的<code>&lt;head&gt;</code>。</p>
<p>你可以从<code>next/Head</code>模块中导入Head组件。</p>
<h2 id="将-Head-添加到-first-post-js-中"><a href="#将-Head-添加到-first-post-js-中" class="headerlink" title="将 Head 添加到 first-post.js 中"></a>将 Head 添加到 first-post.js 中</h2><p>我们没有在<code>/posts/first-post</code>路由中添加<code>&lt;title&gt;</code>，加一个。</p>
<p>打开<code>pages/posts/first-post.js</code>文件，在文件开头添加<code>next/head</code>的导入:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后，更新导出的<code>FirstPost</code>组件，使其包含Head组件。现在，我们只添加<code>title</code>标签:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>← Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试访问<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>。浏览器选项卡现在应该显示“First Post”。通过使用浏览器的开发人员工具，您应该看到标题标记被添加到<code>&lt;head&gt;</code>。</p>
<blockquote>
<p>要了解有关Head组件的更多信息，请查看<code>next/head</code>的<a href="https://nextjs.org/docs/api-reference/next/head">API参考</a>。<br>如果您想定制<code>&lt;html&gt;</code>标记，例如添加lang属性，可以通过创建<code>pages/_document.js</code>文件来实现。在<a href="https://nextjs.org/docs/advanced-features/custom-document">自定义文档文档</a>中了解更多信息。</p>
</blockquote>
<h2 id="第三方-JavaScript"><a href="#第三方-JavaScript" class="headerlink" title="第三方 JavaScript"></a>第三方 JavaScript</h2><p>第三方JavaScript是指从第三方源添加的任何脚本。通常，包含第三方脚本是为了将不需要从头编写的新功能引入站点，例如分析、广告和客户支持小部件。</p>
<h3 id="添加第三方-JavaScript"><a href="#添加第三方-JavaScript" class="headerlink" title="添加第三方 JavaScript"></a>添加第三方 JavaScript</h3><p>让我们深入了解一下如何将第三方脚本添加到Next.js页面。</p>
<p>在你的编辑器中打开<code>pages/posts/first-post.js</code>，找到以下几行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Head&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;/Head&gt;</span><br></pre></td></tr></table></figure>

<p>除了元数据之外，需要尽快加载和执行的脚本通常被添加到页面的<code>&lt;head&gt;</code>中。使用常规的HTML <code>&lt;script&gt;</code>元素，外部脚本将添加如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Head&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://connect.facebook.net/en_US/sdk.js&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/Head&gt;</span><br></pre></td></tr></table></figure>

<p>该脚本包含<a href="https://developers.facebook.com/docs/javascript/quickstart">Facebook SDK</a>，通常用于引入Facebook社交插件和其他功能。虽然这种方法是有效的，但是以这种方式包含脚本并不能清楚地告诉我们，相对于同一页面上获取的其他JavaScript代码，它将在什么时候加载。如果一个特定的脚本是呈现阻塞的，并且会延迟页面内容的加载，这可能会严重影响性能。</p>
<h3 id="使用-Script-组件"><a href="#使用-Script-组件" class="headerlink" title="使用 Script 组件"></a>使用 Script 组件</h3><p><code>next/script</code>是HTML <code>&lt;script&gt;</code>元素的扩展，并在获取和执行其他脚本时进行优化。</p>
<p>在同一个文件中，在文件的开头添加一个从<code>next/script</code>导入的脚本:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Script <span class="keyword">from</span> <span class="string">&#x27;next/script&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>现在，更新<code>FirstPost</code>组件以包含<code>Script</code>组件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Script</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">src</span>=<span class="string">&quot;https://connect.facebook.net/en_US/sdk.js&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">strategy</span>=<span class="string">&quot;lazyOnload&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onLoad</span>=<span class="string">&#123;()</span> =&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">console</span>.log(<span class="string">`script loaded correctly, window.FB has been populated`</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      /&gt;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>← Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>Script</code>组件中已经定义了一些额外的属性:</p>
<ul>
<li><code>strategy</code>控制何时加载第三方脚本。<code>lazyOnload</code>的值告诉Next.js在浏览器空闲时惰性加载这个特定的脚本</li>
<li><code>onLoad</code>用于在脚本完成加载后立即运行任何JavaScript代码。在本例中，我们将一条消息记录到控制台，该消息提到脚本已正确加载</li>
<li>尝试访问<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>。通过使用浏览器的开发人员工具，您应该在控制台面板中看到上面的消息。此外，您可以运行<code>Window.FB</code>查看脚本是否已经填充了这个全局变量。</li>
</ul>
<blockquote>
<p>[!note]<br><code>Facebook SDK</code>仅作为一个人为的示例来展示如何以高性能的方式向应用程序添加第三方脚本。现在您已经了解了在Next.js中包含第三方功能的基础知识，可以在继续之前从<code>FirstPost</code>中删除<code>Script</code>组件。<br>要了解关于Script组件的更多信息，请查看<a href="https://nextjs.org/docs/basic-features/script">文档</a>。</p>
</blockquote>
<h2 id="CSS-样式"><a href="#CSS-样式" class="headerlink" title="CSS 样式"></a>CSS 样式</h2><p>现在让我们谈谈CSS样式。</p>
<p>如您所见，我们的索引页(<a href="http://localhost:3000/">http://localhost:3000</a>)已经有了一些样式。如果查看一下文件结构，您将看到一个名为<code>styles</code>的文件夹，其中包含两个CSS文件:一个全局样式表(<code>global.css</code>)和一个CSS模块(<code>Home.module.css</code>)。<br>如果你的项目没有这些文件，你可以在这里下载启动代码:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-next-app nextjs-blog --use-npm --example &quot;https://github.com/vercel/next-learn/tree/master/basics/assets-metadata-css-starter&quot;</span><br></pre></td></tr></table></figure>

<h3 id="CSS-模块"><a href="#CSS-模块" class="headerlink" title="CSS 模块"></a>CSS 模块</h3><p><a href="https://nextjs.org/docs/basic-features/built-in-css-support">CSS模块</a>允许您通过自动创建唯一的类名来在组件级局部作用域的CSS。这允许您在不同的文件中使用相同的CSS类名，而不用担心类名冲突。</p>
<p>除了CSS模块，你还可以用多种方式为你的Next.js应用设置样式，包括:</p>
<ul>
<li>Sass允许你导入.css和.scss文件</li>
<li>PostCSS库，比如Tailwind CSS</li>
<li>CSS-in-JS库，如<code>styled-jsx</code>、<code>styled-components</code>和<code>emotion</code></li>
</ul>
<p>在本课中，我们将讨论如何在Next.js中使用CSS模块和<a href="https://nextjs.org/docs/basic-features/built-in-css-support#sass-support">Sass</a>。让我们开始吧!</p>
<h3 id="Layout-组件"><a href="#Layout-组件" class="headerlink" title="Layout 组件"></a>Layout 组件</h3><p>首先，让我们创建一个Layout组件，它将被所有页面共享。</p>
<ul>
<li>创建一个名为<code>components</code>的顶级目录。</li>
<li>在组件内部，创建一个名为<code>layout.js</code>的文件，包含以下内容:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">&#123; children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，打开<code>pages/posts/first-post.js</code>，为<code>Layout</code>组件添加一个import，并将其设置为最外层的组件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../../components/layout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>← Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-CSS"><a href="#添加-CSS" class="headerlink" title="添加 CSS"></a>添加 CSS</h3><p>现在，让我们向<code>Layout</code>组件添加一些样式。为此，我们将使用CSS模块，它允许你在React组件中导入CSS文件。</p>
<p>创建一个名为<code>components/layout.module.css</code>的文件，内容如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">36rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3rem</span> auto <span class="number">6rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要</strong>: 要使用CSS模块，CSS文件名必须以<code>.module.css</code>结尾。</p>
</blockquote>
<p>要在<code>components/layout.js</code>中使用这个容器类，你需要:</p>
<ul>
<li>导入CSS文件并为其指定一个名称，如<code>styles</code></li>
<li>使用<code>styles.container</code>作为<code>className</code></li>
</ul>
<p>打开<code>components/layout.js</code>并将其内容替换为以下内容:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./layout.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">&#123; children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你现在转到<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>，你应该看到文本现在在一个居中的容器中:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250942081.png" alt="image.png"></p>
<h3 id="自动生成唯一类名"><a href="#自动生成唯一类名" class="headerlink" title="自动生成唯一类名"></a>自动生成唯一类名</h3><p>现在，如果你在浏览器的devtools中查看一下HTML，你会注意到<code>Layout</code>组件呈现的div有一个类名，看起来像<code>layout_container__…</code> :</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250942493.png" alt="image.png"></p>
<p>这就是CSS模块所做的:它自动生成唯一的类名。只要使用CSS模块，就不必担心类名冲突。</p>
<p>此外，Next.js的代码分割功能也适用于CSS模块。它确保为每个页面加载最少的CSS。这将导致更小的包大小。</p>
<p>CSS模块在构建时从JavaScript包中提取，并生成<code>.css</code>文件，由Next.js自动加载。</p>
<h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><p>CSS模块对于组件级样式非常有用。但如果你想让每个页面都加载一些CSS, Next.js也支持。</p>
<p>要将全局CSS加载到你的应用中，创建一个名为<code>pages/_app.js</code>的文件，内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">&#123; Component, pageProps &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_app.js</code>的默认导出是一个顶级React组件，它包装了应用程序中的所有页面。你可以使用这个组件在页面间导航时保持状态，或者像我们在这里做的那样添加全局样式。了解更多关于<code>_app.js</code>文件的<a href="https://nextjs.org/docs/advanced-features/custom-app">信息</a>。</p>
<h3 id="重启开发服务器"><a href="#重启开发服务器" class="headerlink" title="重启开发服务器"></a>重启开发服务器</h3><p><strong>重要</strong>：添加<code>pages/_app.js</code>时，需要重新启动开发服务器。按“Ctrl + c”停止服务器并运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h3 id="添加全局-CSS"><a href="#添加全局-CSS" class="headerlink" title="添加全局 CSS"></a>添加全局 CSS</h3><p>在Next.js中，你只能从<code>pages/_app.js</code>中导入全局CSS文件。你不能在其他地方导入全局CSS。</p>
<p>全局CSS不能导入到<code>pages/_app.js</code>之外的原因是全局CSS会影响页面上的所有元素。</p>
<p>如果你要从主页导航到<code>/posts/first-post</code>页面，主页的全局样式会无意中影响到<code>/posts/first-pos</code>t。</p>
<p>您可以将全局CSS文件放置在任何位置并使用任何名称。那么让我们做下面的事情:</p>
<ul>
<li>创建一个顶级<code>styles</code>目录和一个<code>global.css</code>文件。</li>
<li>在<code>styles/global.css</code>中添加以下CSS。下面的代码重置了一些样式并改变了<code>a</code>标签的颜色:</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu,</span><br><span class="line">    Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0070f3</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，导入你之前创建的<code>pages/_app.js</code>文件中的CSS文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `pages/_app.js`</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../styles/global.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">&#123; Component, pageProps &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果访问<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>，您将看到样式已经应用。在<code>_app.js</code>中导入的任何样式都将全局应用于应用程序的所有页面。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250942380.png" alt="image.png"></p>
<blockquote>
<p><strong>如果它不起作用</strong>：请确保在更新<code>pages/_app.js</code>时重新启动开发服务器。</p>
</blockquote>
<h3 id="Polishing-Layout"><a href="#Polishing-Layout" class="headerlink" title="Polishing Layout"></a>Polishing Layout</h3><p>到目前为止，我们只添加了最少的React和CSS代码，只是为了说明CSS模块之类的概念。在我们继续下一课关于数据获取的内容之前，让我们来润色一下页面样式和代码。</p>
<h3 id="更新-components-layout-module-css"><a href="#更新-components-layout-module-css" class="headerlink" title="更新 components/layout.module.css"></a>更新 <code>components/layout.module.css</code></h3><p>首先，打开<code>components/layout.module.css</code>，并将其内容替换为以下更精致的布局和头像样式:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">36rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3rem</span> auto <span class="number">6rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.backToHome</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3rem</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建-styles-utils-module-css"><a href="#创建-styles-utils-module-css" class="headerlink" title="创建 styles/utils.module.css"></a>创建 <code>styles/utils.module.css</code></h3><p>其次，让我们创建一组CSS实用程序类(用于文本样式)，它们可以跨多个组件重用。</p>
<p>添加一个新的CSS文件<code>styles/utils.module.css</code>，内容如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heading2Xl</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2.5rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">800</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: -<span class="number">0.05rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.headingXl</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.3</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">800</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: -<span class="number">0.05rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.headingLg</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.4</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.headingMd</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.borderCircle</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">9999px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.colorInherit</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.padding1px</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.listItem</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.lightText</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您可以在整个应用程序中重用这些实用程序类，甚至可以在<code>global.css</code>文件中使用实用程序类。实用类指的是一种编写CSS选择器的方法，而不是方法(例如全局样式、CSS模块、Sass等)。了解更多 <a href="https://tailwindcss.com/docs/utility-first">utility-first CSS</a>.。</p>
</blockquote>
<h3 id="更新-components-layout-js"><a href="#更新-components-layout-js" class="headerlink" title="更新 components/layout.js"></a>更新 <code>components/layout.js</code></h3><p>第三，打开<code>components/layout.js</code>并将其内容替换为以下代码，将Your Name更改为实际名称:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Image <span class="keyword">from</span> <span class="string">&#x27;next/image&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./layout.module.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> utilStyles <span class="keyword">from</span> <span class="string">&#x27;../styles/utils.module.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Your Name&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> siteTitle = <span class="string">&#x27;Next.js Sample Website&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">&#123; children, home &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">content</span>=<span class="string">&quot;Learn how to build a personal website using Next.js&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">property</span>=<span class="string">&quot;og:image&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">content</span>=<span class="string">&#123;</span>`<span class="attr">https:</span>//<span class="attr">og-image.vercel.app</span>/$&#123;<span class="attr">encodeURI</span>(</span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">siteTitle</span>,</span></span></span><br><span class="line"><span class="tag"><span class="xml">          )&#125;<span class="attr">.png</span>?<span class="attr">theme</span>=<span class="string">light&amp;md</span>=<span class="string">0&amp;fontSize</span>=<span class="string">75px&amp;images</span>=<span class="string">https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg</span>`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;og:title&quot;</span> <span class="attr">content</span>=<span class="string">&#123;siteTitle&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;twitter:card&quot;</span> <span class="attr">content</span>=<span class="string">&quot;summary_large_image&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">className</span>=<span class="string">&#123;styles.header&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;home ? (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">priority</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">src</span>=<span class="string">&quot;/images/profile.jpg&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">className</span>=<span class="string">&#123;utilStyles.borderCircle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">height</span>=<span class="string">&#123;144&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">width</span>=<span class="string">&#123;144&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#123;utilStyles.heading2Xl&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">        ) : (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">priority</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">src</span>=<span class="string">&quot;/images/profile.jpg&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">className</span>=<span class="string">&#123;utilStyles.borderCircle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">height</span>=<span class="string">&#123;108&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">width</span>=<span class="string">&#123;108&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&#123;utilStyles.headingLg&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">className</span>=<span class="string">&#123;utilStyles.colorInherit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;name&#125;</span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">      &#123;!home &amp;&amp; (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.backToHome&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>← Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是新的变动:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Meta_element">meta tags</a>(如og:image)，用于描述页面的内容</li>
<li>布尔home 属性，它将调整标题和图像的大小</li>
<li>如果home为假，则底部的“Back to home”链接</li>
<li>添加了带有<code>next/image</code>的图像，这些图像预先加载了<code>priority</code>属性</li>
</ul>
<h2 id="更新-pages-index-js"><a href="#更新-pages-index-js" class="headerlink" title="更新 pages/index.js"></a>更新 <code>pages/index.js</code></h2><p>最后，让我们更新主页。</p>
<p>打开<code>pages/index.js</code>并将其内容替换为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout, &#123; siteTitle &#125; <span class="keyword">from</span> <span class="string">&#x27;../components/layout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> utilStyles <span class="keyword">from</span> <span class="string">&#x27;../styles/utils.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">home</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;siteTitle&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&#123;utilStyles.headingMd&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>[Your Self Introduction]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          (This is a sample website - you’ll be building a site like this on&#123;&#x27; &#x27;&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://nextjs.org/learn&quot;</span>&gt;</span>our Next.js tutorial<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.)</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后用你的自我介绍代替你的自我介绍。这里有一个作者简介的例子:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250943061.png" alt="image.png"></p>
<p>就是这样!现在我们有了经过优化的布局代码，我们准备继续我们的<strong>data fetching</strong>课程。</p>
<h3 id="样式技巧"><a href="#样式技巧" class="headerlink" title="样式技巧"></a>样式技巧</h3><p>这里有一些样式技巧可能会对你有所帮助。</p>
<blockquote>
<p>您可以通读下面的部分。无需更改我们的应用程序!</p>
</blockquote>
<h3 id="使用-clsx-库切换类"><a href="#使用-clsx-库切换类" class="headerlink" title="使用 clsx 库切换类"></a>使用 clsx 库切换类</h3><p><code>CLSX</code>是一个简单的库，允许您轻松切换类名。你可以使用<code>npm install clsx</code>或<code>yarn add clsx</code>来安装它。<br>请查看它的<a href="https://github.com/lukeed/clsx">文档</a>了解更多细节，但这里是基本用法:</p>
<ul>
<li>假设你想创建一个接受<code>type</code>的Alert组件，类型可以是’success’或’error’。</li>
<li>如果是success，你希望文本颜色是绿色。如果是error，你希望文本颜色是红色。</li>
</ul>
<p>你可以先像这样写一个CSS模块(比如alert.module.css):</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后像这样使用<code>clsx</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./alert.module.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; clsx &#125; <span class="keyword">from</span> <span class="string">&#x27;clsx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Alert</span>(<span class="params">&#123; children, type &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">className</span>=<span class="string">&#123;clsx(&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        [<span class="attr">styles.success</span>]<span class="attr">:</span> <span class="attr">type</span> === <span class="string">&#x27;success&#x27;</span>,</span></span></span><br><span class="line"><span class="tag"><span class="xml">        [<span class="attr">styles.error</span>]<span class="attr">:</span> <span class="attr">type</span> === <span class="string">&#x27;error&#x27;</span>,</span></span></span><br><span class="line"><span class="tag"><span class="xml">      &#125;)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">    &gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="自定义-PostCSS-配置"><a href="#自定义-PostCSS-配置" class="headerlink" title="自定义 PostCSS 配置"></a>自定义 PostCSS 配置</h3><p>无需配置，Next.js就可以使用<a href="https://postcss.org/">PostCSS</a>编译CSS。</p>
<p>要定制<code>PostCSS</code>配置，可以创建一个名为<a href="https://nextjs.org/docs/advanced-features/customizing-postcss-config#customizing-plugins">postcss.config.js</a>的顶层文件。如果你正在使用<a href="https://tailwindcss.com/">Tailwind CSS</a>之类的库，这是很有用的。</p>
<p>下面是添加Tailwind CSS的步骤。首先，安装这些软件包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss autoprefixer postcss</span><br></pre></td></tr></table></figure>

<p>然后，创建<code>postcss.config.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: &#123;</span><br><span class="line">    <span class="attr">tailwindcss</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">autoprefixer</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还建议通过在<code>tailwind.config.js</code>中指定<code>content</code>选项来<a href="https://tailwindcss.com/docs/content-configuration">配置内容源</a>:</p>
<blockquote>
<p>要了解有关自定义PostCSS配置的更多信息，请查看PostCSS的<a href="https://nextjs.org/docs/advanced-features/customizing-postcss-config">文档</a>。</p>
</blockquote>
<h3 id="使用-Sass"><a href="#使用-Sass" class="headerlink" title="使用 Sass"></a>使用 Sass</h3><p>Next.js允许您同时使用<code>.scss</code>和<code>.sass</code>扩展名导入<a href="https://nextjs.org/docs/basic-features/built-in-css-support#sass-support">Sass</a>。你可以通过CSS模块和<code>.module.scss</code>或者<code>.module.sass</code>使用组件级Sass。</p>
<p>在使用Next.js内置的Sass支持之前，请确保安装了Sass:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D sass</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>promise 是处理异步请求的特殊对象</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>Promise 有三种状态。</p>
<ol>
<li><strong>pending</strong>(进行中): 初始状态，不是成功或失败状态。处于 pending 状态时，可以使用 then() 方法指定成功和失败的回调函数，<strong>then()方法中的回调函数会统一处理fulfilled和rejected，而不是单独为这两种状态指定不同的处理函数</strong>。</li>
<li><strong>fulfilled</strong>(已完成): 意味着操作成功完成。已经处于 fulfilled 或 rejected 状态，将立即执行相应的回调函数。</li>
<li><strong>rejected</strong>(已失败): 意味着操作失败。已经处于 fulfilled 或 rejected 状态，将立即执行相应的回调函数。</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, url);  </span><br><span class="line">    xhr.onload = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;  </span><br><span class="line">        resolve(xhr.responseText);  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    xhr.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Network Error&quot;</span>));  </span><br><span class="line">    xhr.send();  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">getData(<span class="string">&quot;https://example.com/todos/1&quot;</span>)  </span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data))  </span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>并行执行多个 Promise 对象，并在所有 Promise 对象都成功时返回结果。<br>promise.all 是一个 JavaScript 的方法，它接收一个 promise 的可迭代对象（如数组或字符串）作为参数，并返回一个新的 promise 对象。这个新的 promise 对象的状态和结果取决于传入的 promise 对象的状态和结果。<br>如果传入的可迭代对象是空的，或者不包含任何 promise 对象，那么 promise.all 会同步地返回一个已完成（resolved）状态的 promise 对象，它的结果是一个空数组。<br>如果传入的可迭代对象包含至少一个 promise 对象，那么 promise.all 会异步地等待所有的 promise 对象都完成（resolved）或有一个失败（rejected）。<br>如果所有的 promise 对象都完成了，那么 promise.all 返回的 promise 对象也会完成，它的结果是一个包含所有传入的 promise 对象的结果的数组，数组中的顺序和传入的顺序一致。<br>如果有任何一个 promise 对象失败了，那么 promise.all 返回的 promise 对象也会失败，它的结果是第一个失败的 promise 对象的原因。<br>| 输入                        | 输出                                                                                                |<br>| ————————— | ————————————————————————————————— |<br>| 空数组                      | Promise { “fulfilled”, [] }                                                                         |<br>| 非 promise 值               | Promise { “fulfilled”, [输入值] }                                                                   |<br>| 已完成或已失败的 promise 值 | Promise { 第一个失败的 promise 的状态, 第一个失败的 promise 的原因或所有成功的 promise 的结果数组 } |<br>| 未完成或未失败的 promise 值 | Promise { “pending” }                                                                               |<br>|                             |                                                                                                     |<br>![[Pasted image 20230514165735.png]]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = getData(<span class="string">&quot;/api/data1&quot;</span>);  </span><br><span class="line"><span class="keyword">const</span> promise2 = getData(<span class="string">&quot;/api/data2&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2])  </span><br><span class="line">  .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(data1);  </span><br><span class="line">    <span class="built_in">console</span>.log(data2);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race() 方法可以竞速执行多个 Promise 对象，并返回第一个完成的 Promise 对象的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;result1&quot;</span>), <span class="number">1000</span>));  </span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;result2&quot;</span>), <span class="number">500</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2])  </span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))  </span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>await是一个运算符，用于等待一个表达式的结果，它只能在异步函数（async function）中使用。<br>await可以等待一个Promise对象，也可以等待一个普通的值。如果等待的是一个Promise对象，await会阻塞后面的代码，直到Promise对象被兑现（resolve）或拒绝（reject），并返回其兑现的值或抛出拒绝的原因。如果等待的是一个普通的值，await会直接返回该值。<br>await可以用于等待异步函数的返回值，也可以用于等待其他的异步操作，比如setTimeout，fetch等。</p>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then方法是Promise对象的一个方法，它可以接受两个参数，分别是onFulfilled和onRejected。onFulfilled是一个函数，它会在Promise状态变为fulfilled时被调用，onRejected是一个函数，它会在Promise状态变为rejected时被调用。如果你只传递了onFulfilled参数，那么then方法只有在Promise状态变为fulfilled时才会被调用。如果你想在Promise状态变为rejected时也有相应的处理，你可以传递第二个参数onRejected，或者使用catch方法。</p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>catch方法是then方法的一种简写形式，它相当于then(undefined, onRejected)。  catch方法返回的是一个新的Promise对象，它可以继续链式调用then方法。如果catch方法没有抛出异常或返回一个被拒绝的Promise对象，那么它返回的Promise对象会被兑现（fulfilled）。</p>
<h4 id="then和catch"><a href="#then和catch" class="headerlink" title="then和catch"></a>then和catch</h4><p>catch方法可以捕获前面then方法中抛出的异常，而then方法的第二个参数不能捕获自身的异常。</p>
<h2 id="Some-Questions"><a href="#Some-Questions" class="headerlink" title="Some Questions"></a>Some Questions</h2><h4 id="promise不管包装的是什么内容都会是异步的吗"><a href="#promise不管包装的是什么内容都会是异步的吗" class="headerlink" title="promise不管包装的是什么内容都会是异步的吗?"></a>promise不管包装的是什么内容都会是异步的吗?</h4><p>答：<br>•  promise是一种用于表示异步操作的最终完成或失败及其结果值的对象。<br>•  promise可以包装任何类型的值，无论是普通的值还是另一个promise对象。<br>•  promise本身并不是异步的，它只是一个代理，用于在未来某个时候把值交给使用者。<br>•  promise的异步性体现在它的状态转换上，它有三种状态：待定（pending），已兑现（fulfilled）和已拒绝（rejected）。<br>•  当一个promise被创建时，它处于待定状态，此时它还没有被兑现或被拒绝，也没有任何结果值。<br>•  当一个promise被兑现或被拒绝时，它就变成了已敲定（settled）状态，此时它有一个不可变的结果值，并且不能再改变状态。<br>•  promise的状态转换通常是由异步操作触发的，比如setTimeout，fetch等。当异步操作完成时，它会调用promise构造函数中传入的resolve或reject函数，从而改变promise的状态，并传递结果值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&quot;foo&quot;</span>); <span class="comment">// 异步操作完成后，调用resolve函数，将promise状态从pending变为fulfilled，并传递结果值&#x27;foo&#x27;</span></span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>•  promise的状态转换也可以由同步操作触发，比如直接在构造函数中调用resolve或reject函数。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&quot;bar&quot;</span>); <span class="comment">// 同步操作完成后，调用resolve函数，将promise状态从pending变为fulfilled，并传递结果值&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>•  但是，即使promise的状态转换是由同步操作触发的，它也不会立即执行与之关联的处理函数（then，catch等），而是会将它们放入微任务队列（microtask queue），等待当前执行栈清空后再执行。这样做的目的是为了保证promise的行为一致性和可预测性。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&quot;bar&quot;</span>); <span class="comment">// 同步操作完成后，调用resolve函数，将promise状态从pending变为fulfilled，并传递结果值&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">myPromise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 这个函数不会立即执行，而是会放入微任务队列中等待</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;baz&quot;</span>); <span class="comment">// 这个语句会先于上面的函数执行</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>•  因此，可以说<strong>promise不管包装的是什么内容都会有一定程度的异步性，但这并不意味着它们都会产生新的异步操作。这取决于promise内部如何触发状态转换和结果值传递</strong>。</p>
]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>valueOf和toString</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/valueOf%E5%92%8CtoString/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>console.log()直接打印的话中除了object直接打印、date执行两次toString,其余都toString再用valueOf,<br>alert(),String()中都只使用了toString()，<br>如果需要进行运算，都是先进行valueOf再toString<br>总而言之，<strong>与数字、运算有关的用valueOf优先,其他都是toString优先</strong></p>
]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>for of 和 for in的区别 ？</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/for%20of%20%E5%92%8C%20for%20in%E7%9A%84%E5%8C%BA%E5%88%AB%20%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>for in 遍历的是key,for of 遍历value</p>
]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>生命周期</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><h2 id="Vue-自定义指令"><a href="#Vue-自定义指令" class="headerlink" title="Vue 自定义指令"></a>Vue 自定义指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() -&gt;        -&gt; mounted() -&gt;      -&gt; updated() -&gt;            -&gt; unmounted()</span><br><span class="line">		beforeMounted()        beforeUpdated()     beforeUnmounted()       </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>闭包 ？</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/%E9%97%AD%E5%8C%85%20%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>删除配置</title>
    <url>/2023/06/24/Vim/Neovim/%E5%88%A0%E9%99%A4%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset XXXX</span><br></pre></td></tr></table></figure>

<p>XXXX的具体内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git congif -f</span><br><span class="line"></span><br><span class="line">XXXX=xxx</span><br><span class="line">aaaaa=aaa</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vim</category>
        <category>Neovim</category>
      </categories>
  </entry>
  <entry>
    <title>安装NVChad</title>
    <url>/2023/06/24/Vim/Neovim/%E5%AE%89%E8%A3%85NVChad/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>安装neovim最新版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">choco install/upgrade neovim</span><br></pre></td></tr></table></figure>
<p>删除<code>Appdata/local/nvim-data</code>和<code>Appdata/local/nvim</code>里面的文件</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/NvChad/NvChad $HOME\AppData\Local\nvim --depth 1</span><br></pre></td></tr></table></figure>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>因为网络原因可能nvim初始化可能失败，需多次尝试<br>如果有模块找不到也是网络原因<br>![[lazy.nvim-9.14.5.zip]]</p>
<h2 id="lazy-nvim安装插件"><a href="#lazy-nvim安装插件" class="headerlink" title="lazy.nvim安装插件"></a>lazy.nvim安装插件</h2><p>修改”C:\Users\lsy\AppData\Local\nvim\lua\custom\plugins.lua”中的代码<br>例如添加codeium插件，插件加载的相关配置可以查看[官方文档](<a href="https://github.com/folke/lazy.nvim#-plugin-spec">folke/lazy.nvim：💤 Neovim的现代插件管理器 (github.com)</a>)</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Exafunction/codeium.vim&quot;</span>,</span><br><span class="line">    lazy = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- event = &quot;InsertEnter&quot;,</span></span><br><span class="line">    <span class="comment">-- config = function()</span></span><br><span class="line">    <span class="comment">--   require(&quot;better_escape&quot;).setup()</span></span><br><span class="line">    <span class="comment">-- end,</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vim</category>
        <category>Neovim</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈 “交浅言深” - 简书</title>
    <url>/2023/07/04/notion/Other/%E6%B5%85%E8%B0%88%20%E2%80%9C%E4%BA%A4%E6%B5%85%E8%A8%80%E6%B7%B1%E2%80%9D%20-%20%E7%AE%80%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浅谈-“交浅言深”-简书"><a href="#浅谈-“交浅言深”-简书" class="headerlink" title="浅谈 “交浅言深” - 简书"></a>浅谈 “交浅言深” - 简书</h1><p>Created: January 4, 2022 12:18 PM</p>
<p>先说一下这个词的由来，在《后汉书 · 崔骃传》载：“骃闻，交浅而言深者，愚也。” 后来，宋代的大文豪苏轼在《上神宗皇帝书》也提到说：“交浅言深，君子所戒。情深不寿，强极则辱。”</p>
<p>交浅言深的危害有：1. 容易让人产生误会，还会尴尬，反而交不到真的朋友。2. 会被有心人利用，有被四处出卖的风险。</p>
<p>其实我就是这样的人，很容易对交情浅的人说利害攸关的恳切的话，但是自己的真心并没有换来别人的关心，反而是出卖。很是痛苦！我反复的问过自己，为什么自己会成为这样的人。认真思考过后，我觉得交浅言深的背后，其实是建立在自信缺失条件下的社交焦虑和应激反应，是心灵自残的恶性循环。</p>
<p>换言之，交浅言深的人很大部分是那些无法忍受沉默的人。由于缺乏自信，我们这类人对于社交过程中的沉默异常敏感，同时会下意识的将沉默看成是自己的过错，因此便产生了社交焦虑，希望用更多，更深入的信息来打破沉默，吸引对方的注意力，恳求对方了解自己，于是不知不觉便说了很多 “不该说” 的话。</p>
<p>我们放下了防备，献祭了自己的自尊和真诚供陌生人赏玩来打发他们无意义的时间，更意味着我们把自己的自尊和真诚标上了一个可以被陌生人肆意赏玩的价码——还有比这更不自爱的行为吗？</p>
<p>如何做到不交浅言深呢？尝试着享受寂寞孤独，另一方面要提升自己的认知和各种能力，增强自信心，学会爱自己！</p>
<p>最后送大家一句话：群居守口，独居守心！ &gt; 本文由简悦 SimpRead 转码</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title>1st Line Meeting</title>
    <url>/2023/07/04/notion/Other/1st%20Line%20Meeting/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1st-Line-Meeting"><a href="#1st-Line-Meeting" class="headerlink" title="1st Line Meeting"></a>1st Line Meeting</h1><p>Created: February 18, 2022 8:38 AM</p>
<p>这周主要是完成前两个CR的UAT修复以及日常的Support,</p>
<p>下周的主要工作内容是前两个CR的上线以及资产报废CR的开发，以及日常的support</p>
<p>这周主要是把EHSR的那个CR部署到了正式环境，然后是文具消耗品的CR的一些修改。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title>Top3 task</title>
    <url>/2023/07/04/notion/Other/Top3%20task/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Top3-task"><a href="#Top3-task" class="headerlink" title="Top3 task"></a>Top3 task</h1><p>Created: May 17, 2022 10:46 AM</p>
<ol>
<li>金点子系统：基于SharePoint平台的旧金点子系统因存在问题且不易维护将停止使用，新金点子系统整合在Eform平台，以提供更好的使用体验。</li>
<li>Eform SCM 资产报废模块：该模块减少出售申请过程纸质档签字，提高报废固定资产、非固定资产出售效率，实现报废固定资产、非固定资产出售审批透明化、提升可追溯性。</li>
<li>Eform EHSR 闭环管理模块：该模块具备完整的闭环流程，其优点是将问题分为不同等级，通过自动邮件及定期自动提醒的方式敦促负责人解决问题，不同等级的问题有对应其等级的解决方式，使得EHSR部门的工作更加规范和可追溯。</li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title>蓝色多瑙河-小约翰史特劳德</title>
    <url>/2023/07/04/notion/Other/%E8%93%9D%E8%89%B2%E5%A4%9A%E7%91%99%E6%B2%B3-%E5%B0%8F%E7%BA%A6%E7%BF%B0%E5%8F%B2%E7%89%B9%E5%8A%B3%E5%BE%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="蓝色多瑙河-小约翰史特劳德"><a href="#蓝色多瑙河-小约翰史特劳德" class="headerlink" title="蓝色多瑙河-小约翰史特劳德"></a>蓝色多瑙河-小约翰史特劳德</h1><p>Created: December 29, 2022 3:28 AM</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title>钉钉宜搭低代码平台分析报告</title>
    <url>/2023/07/04/notion/Other/%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="钉钉宜搭低代码平台分析报告"><a href="#钉钉宜搭低代码平台分析报告" class="headerlink" title="钉钉宜搭低代码平台分析报告"></a>钉钉宜搭低代码平台分析报告</h1><p>Created: June 20, 2022 11:39 AM</p>
<p><strong>钉钉宜搭低代码平台分析</strong></p>
<p><strong>小组成员： Jackson Long, Horzy Huang</strong></p>
<p><strong>编写时间： 2022年6月16日</strong></p>
<p><strong>2021 年 6月16 号</strong></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h1><p>[[1 界面 3]]</p>
<p>[[1 1拖拉拽的设计体验 3]]</p>
<p>[[1 2 所见即所得的预览效果 3]]</p>
<p>[[1 3 组件 3]]</p>
<p>[[2 数据 6]]</p>
<p>[[2 1 支持的数据源 6]]</p>
<p>[[2 2 是否支持自由设计数据库结构 7]]</p>
<p>[[2 3 连接数据源 7]]</p>
<p>[[3 逻辑 9]]</p>
<p>[[3 1 驱动模式 9]]</p>
<p>[[3 1 1 表单驱动 9]]</p>
<p>[[3 2 工作流 9]]</p>
<p>[[3 2 1 简易工作流 9]]</p>
<p>[[3 2 1 自定义复杂工作流 9]]</p>
<p>[[4 扩展与复用 9]]</p>
<p>[[4 1 扩展性 9]]</p>
<p>[[4 1 1 对用户自定义需求的满足能力 9]]</p>
<p>[[4 1 2 与外部系统的集成能力 10]]</p>
<p>[[4 2 复用性 11]]</p>
<p>[[4 2 1 页面组件复用 11]]</p>
<p>[[4 2 2 逻辑函数复用 11]]</p>
<p>[[4 2 3 应用模板复用 12]]</p>
<p>[[5 测试 调试与维护 13]]</p>
<p>[[5 1 测试 13]]</p>
<p>[[5 2 调试 13]]</p>
<p>[[5 3 维护 14]]</p>
<p>[[6 协同开发与版本管理 14]]</p>
<p>[[6 1 协同开发 14]]</p>
<p>[[6 2 版本管理 14]]</p>
<p>[[7 平台 14]]</p>
<p>[[7 1 手机应用 14]]</p>
<p>[[7 2 平板应用 14]]</p>
<p>[[7 3 Web端 14]]</p>
<p>[[8 学习资料与平台 15]]</p>
<p>[[8 1 资料 15]]</p>
<p>[[8 1 1 中文资料 15]]</p>
<p>[[8 1 2 外文资料 15]]</p>
<p>[[8 2 社区 15]]</p>
<p>[[8 2 1 社区规模和社区活跃程度 15]]</p>
<p>[[8 3 入门所需时间 15]]</p>
<p>[[9 性能 16]]</p>
<p>[[10 使用场景 16]]</p>
<p>[[10 1 普通表单 16]]</p>
<p>[[10 2 流程表单 17]]</p>
<p>[[10 3 自定义页面 18]]</p>
<p>[[10 4 报表 19]]</p>
<p>[[10 5 数据大屏 20]]</p>
<p>[[11 总结 21]]</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="1-界面"><a href="#1-界面" class="headerlink" title="1.界面"></a>1.界面</h1><h2 id="1-1拖拉拽的设计体验"><a href="#1-1拖拉拽的设计体验" class="headerlink" title="1.1拖拉拽的设计体验"></a>1.1拖拉拽的设计体验</h2><p>体验良好，控件拖拽流畅，设计页面布局合理。</p>
<h2 id="1-2-所见即所得的预览效果"><a href="#1-2-所见即所得的预览效果" class="headerlink" title="1.2 所见即所得的预览效果"></a>1.2 所见即所得的预览效果</h2><p>所见即所得，宜搭在设计界面的预览效果与实际使用过程中的显示效果没有差别。</p>
<h2 id="1-3-组件"><a href="#1-3-组件" class="headerlink" title="1.3 组件"></a>1.3 组件</h2><p>宜搭的可视化搭建界面提供了大量的组件，其中自定义页面52种组件，普通表单和流程表单26种组件，其中宜搭的高级组件提供了更强大的功能。</p>
<p>付费版本的宜搭也提供了自定义组件的功能，可以在提升组件与业务需求契合度的同时，减少组件开发及运维的成本并提高了组件的可复用性。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image1.png]]</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image2.png]]</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image3.png]]</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image4.png]]</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image5.png]]</p>
<h1 id="2-数据"><a href="#2-数据" class="headerlink" title="2.数据"></a>2.数据</h1><h2 id="2-1-支持的数据源"><a href="#2-1-支持的数据源" class="headerlink" title="2.1 支持的数据源"></a>2.1 支持的数据源</h2><p>宜搭的数据交互可通过四种方式。</p>
<p>[[Untitled Database]]</p>
<p>其中<strong>数据集、视图表、和跨应用取数</strong>的数据都是存储在宜搭所创建的表单中，<strong>数据源</strong>支持连接数据库（<strong>MySQL、SQL Server（2012版及以上）、Oracle、Postgre、Hologres</strong>）和读取<strong>Excel和CSV</strong>文件。</p>
<h2 id="2-2-是否支持自由设计数据库结构"><a href="#2-2-是否支持自由设计数据库结构" class="headerlink" title="2.2 是否支持自由设计数据库结构"></a>2.2 是否支持自由设计数据库结构</h2><p>不支持通过宜搭去设计数据库结构</p>
<h2 id="2-3-连接数据源"><a href="#2-3-连接数据源" class="headerlink" title="2.3 连接数据源"></a>2.3 连接数据源</h2><p>2.3.1通过api对表单中的数据进行增删查改</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image6.png]]</p>
<p>2.3.2 连接数据库</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image7.png]]</p>
<p>连接数据库</p>
<p>2.3.3 读取文件中数据</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image8.png]]</p>
<p>读取Excel或CSV</p>
<h1 id="3-逻辑"><a href="#3-逻辑" class="headerlink" title="3.逻辑"></a>3.逻辑</h1><h2 id="3-1-驱动模式"><a href="#3-1-驱动模式" class="headerlink" title="3.1 驱动模式"></a>3.1 驱动模式</h2><h3 id="3-1-1-表单驱动"><a href="#3-1-1-表单驱动" class="headerlink" title="3.1.1 表单驱动"></a>3.1.1 表单驱动</h3><p>宜搭为表单驱动模式</p>
<h2 id="3-2-工作流"><a href="#3-2-工作流" class="headerlink" title="3.2 工作流"></a>3.2 工作流</h2><h3 id="3-2-1-简易工作流"><a href="#3-2-1-简易工作流" class="headerlink" title="3.2.1 简易工作流"></a>3.2.1 简易工作流</h3><p>宜搭提供可视化的流程设计，能够快速实现简单的工作流</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image9.gif]]</p>
<h3 id="3-2-1-自定义复杂工作流"><a href="#3-2-1-自定义复杂工作流" class="headerlink" title="3.2.1 自定义复杂工作流"></a>3.2.1 自定义复杂工作流</h3><p>宜搭可通过自定义页面实现复杂的工作流，但是与现在eform的开发并无太大区别，需要自己通过大量编程实现。</p>
<h1 id="4-扩展与复用"><a href="#4-扩展与复用" class="headerlink" title="4.扩展与复用"></a>4.扩展与复用</h1><h2 id="4-1-扩展性"><a href="#4-1-扩展性" class="headerlink" title="4.1 扩展性"></a>4.1 扩展性</h2><h3 id="4-1-1-对用户自定义需求的满足能力"><a href="#4-1-1-对用户自定义需求的满足能力" class="headerlink" title="4.1.1 对用户自定义需求的满足能力"></a>4.1.1 对用户自定义需求的满足能力</h3><p>宜搭的自定义页面模块提供很强的自定义功能，理论上说可以满足用户几乎所有的合理需求。但是自定义页面模块无法与流程表单等其他类型模块很好的集成在一起，体验并不好。</p>
<p>自定义页面模块提供了动作面板，可通过js编程来实现一些更定制化的需求。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image10.png]]</p>
<h3 id="4-1-2-与外部系统的集成能力"><a href="#4-1-2-与外部系统的集成能力" class="headerlink" title="4.1.2 与外部系统的集成能力"></a>4.1.2 与外部系统的集成能力</h3><p>宜搭与钉钉是强关联的，能很方便的与钉钉进行集成，与其他的第三方程序的集成通过调用api实现。</p>
<p>宜搭的连接器工厂能很方便的实现外部api的调用与复用。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image11.png]]</p>
<h2 id="4-2-复用性"><a href="#4-2-复用性" class="headerlink" title="4.2 复用性"></a>4.2 复用性</h2><h3 id="4-2-1-页面组件复用"><a href="#4-2-1-页面组件复用" class="headerlink" title="4.2.1 页面组件复用"></a>4.2.1 页面组件复用</h3><p>宜搭支持页面组件的复用。</p>
<p>宜搭提供丰富的页面区块模板，合理地使用，并遵循合理的设计范式，能够有效提高日常页面设计的效率,区块模板分为<strong>公共模板和私有模板</strong>。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image12.gif]]</p>
<p>a. 私有区块指的是在<strong>同一个项目</strong>中所有私有区块是共享的，但<strong>跨项目看不到</strong>；</p>
<p>b. 私有区块的创建是通过在编辑器操作窗口中点击创建私有区块来进行创建，一个私有区块可以是一个组件或一组组件，通常我们会通过在外层创建一个容器的方法创建复杂私有区块；</p>
<p>c. 私有区块每次复用会成为独立的页面结构，不影响其他使用地方的显示；</p>
<p>d. 私有区块不光会保存区块的位置等信息，也包含组件设置、国际化、动作等所有与组件相关的信息；</p>
<p>e. 私有区块功能是为了扩展复制粘贴的使用场景，方便用户在中简单的复用。</p>
<h3 id="4-2-2-逻辑函数复用"><a href="#4-2-2-逻辑函数复用" class="headerlink" title="4.2.2 逻辑函数复用"></a>4.2.2 逻辑函数复用</h3><p>宜搭支持逻辑函数的复用。</p>
<p>在同一个项目中逻辑函数是可以复用的，在宜搭的自定义页面模块中所有的函数都是向所有组件暴露的，不同的组件可以调用同一个函数。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image13.png]]</p>
<h3 id="4-2-3-应用模板复用"><a href="#4-2-3-应用模板复用" class="headerlink" title="4.2.3 应用模板复用"></a>4.2.3 应用模板复用</h3><p>宜搭支持应用模板的复用</p>
<p>宜搭可通过模板中心使用宜搭平台提供的所有模板，也可发布模板。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image14.png]]</p>
<h1 id="5-测试、调试与维护"><a href="#5-测试、调试与维护" class="headerlink" title="5.测试、调试与维护"></a>5.测试、调试与维护</h1><h2 id="5-1-测试"><a href="#5-1-测试" class="headerlink" title="5.1 测试"></a>5.1 测试</h2><p>宜搭没有配套的测试工具，只有一个针对流程表单的流程测试功能。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image15.png]]</p>
<h2 id="5-2-调试"><a href="#5-2-调试" class="headerlink" title="5.2 调试"></a>5.2 调试</h2><p>宜搭可通过浏览器的控制台进行调试，此过程与传统开发调试过程相同。可在Js动作面板中通过debugger关键字打上断点。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image16.png]]</p>
<h2 id="5-3-维护"><a href="#5-3-维护" class="headerlink" title="5.3 维护"></a>5.3 维护</h2><p>针对普通表单和流程表单的数据维护，宜搭提供了一键生成数据管理页面的功能，提供了展示表单所有提交的数据、导入/导入记录、导出/导出记录、修改记录、下载文件/下载文件记录、打印/打印记录、新增、更多操作（修改数据、删除）、搜索、筛选、设置显示列、排序、刷新、全屏等功能。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image17.png]]</p>
<h1 id="6-协同开发与版本管理"><a href="#6-协同开发与版本管理" class="headerlink" title="6.协同开发与版本管理"></a>6.协同开发与版本管理</h1><h2 id="6-1-协同开发"><a href="#6-1-协同开发" class="headerlink" title="6.1 协同开发"></a>6.1 协同开发</h2><p>宜搭除了提供了设置项目开发成员的功能之后没有提供其他的与协同开发相关的功能。</p>
<h2 id="6-2-版本管理"><a href="#6-2-版本管理" class="headerlink" title="6.2 版本管理"></a>6.2 版本管理</h2><p>宜搭只提供了流程表单模块工作流的版本管理，我们也能通过其他途径实现简单的版本管理。</p>
<h1 id="7-平台"><a href="#7-平台" class="headerlink" title="7.平台"></a>7.平台</h1><h2 id="7-1-手机应用"><a href="#7-1-手机应用" class="headerlink" title="7.1 手机应用"></a>7.1 手机应用</h2><p>可生成手机应用或通过钉钉使用</p>
<h2 id="7-2-平板应用"><a href="#7-2-平板应用" class="headerlink" title="7.2 平板应用"></a>7.2 平板应用</h2><p>可生成平板应用或通过钉钉使用</p>
<h2 id="7-3-Web端"><a href="#7-3-Web端" class="headerlink" title="7.3 Web端"></a>7.3 Web端</h2><p>可通过浏览器直接访问</p>
<h1 id="8-学习资料与平台"><a href="#8-学习资料与平台" class="headerlink" title="8.学习资料与平台"></a>8.学习资料与平台</h1><h2 id="8-1-资料"><a href="#8-1-资料" class="headerlink" title="8.1 资料"></a>8.1 资料</h2><h3 id="8-1-1-中文资料"><a href="#8-1-1-中文资料" class="headerlink" title="8.1.1 中文资料"></a>8.1.1 中文资料</h3><p>官方提供了大量的中文资料，可通过<a href="https://www.yuque.com/yida/?spm=a2q5o.26736369.0.0">钉钉宜搭 · 语雀 (yuque.com)</a>访问。</p>
<p>通过搜索引擎也能获得大量的资料。</p>
<h3 id="8-1-2-外文资料"><a href="#8-1-2-外文资料" class="headerlink" title="8.1.2 外文资料"></a>8.1.2 外文资料</h3><p>外文资料很少</p>
<h2 id="8-2-社区"><a href="#8-2-社区" class="headerlink" title="8.2 社区"></a>8.2 社区</h2><h3 id="8-2-1-社区规模和社区活跃程度"><a href="#8-2-1-社区规模和社区活跃程度" class="headerlink" title="8.2.1 社区规模和社区活跃程度"></a>8.2.1 社区规模和社区活跃程度</h3><p>宜搭的社区目前有将近4000条帖子，每天只有几条帖子，且很多帖子都没人回复，社区活跃度很低。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image18.png]]</p>
<h2 id="8-3-入门所需时间"><a href="#8-3-入门所需时间" class="headerlink" title="8.3 入门所需时间"></a>8.3 入门所需时间</h2><p>Fulltime学习两周</p>
<h1 id="9-性能"><a href="#9-性能" class="headerlink" title="9.性能"></a>9.性能</h1><p>根据网上收集到的资料，宜搭支持海量数据高效存储查询，租户隔离，分库分表，多引擎适配自动优化保证最优性能，服务高可用，同城双备，异地多活，保证 99.9% 不中断。宜搭依托阿里云，相信在性能上可以满足我们公司的需求。</p>
<h1 id="10-使用场景"><a href="#10-使用场景" class="headerlink" title="10.使用场景"></a>10.使用场景</h1><p>宜搭的主要功能模块分为：<strong>表单、流程表单、报表、DataV数据大屏、自定义页面。</strong>不同模块的主要使用场景不同。</p>
<h2 id="10-1-普通表单"><a href="#10-1-普通表单" class="headerlink" title="10.1 普通表单"></a>10.1 普通表单</h2><p>普通表单无审批流程，可以在<strong>调查统计、在线报名、销售上报、会议预约、采购入库、订单录入、扫码签到</strong>等场景使用。 可以收集业务进展中的所有数据。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image19.png]]</p>
<h2 id="10-2-流程表单"><a href="#10-2-流程表单" class="headerlink" title="10.2 流程表单"></a>10.2 流程表单</h2><p>流程表单适用于<strong>报销审批、工作汇报、任务派单、员工请假、物品领用、维修申请、意见反馈</strong>等场景使用。 让数据自下而上层层流转，逐级审批。也可以分配权限，进一步管理流程数据。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image20.png]]</p>
<h2 id="10-3-自定义页面"><a href="#10-3-自定义页面" class="headerlink" title="10.3 自定义页面"></a>10.3 自定义页面</h2><p>面向复杂功能的实现，无具体使用场景，开发人员可通过编程和配置实现绝大部分自己想要的功能。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image21.png]]</p>
<h2 id="10-4-报表"><a href="#10-4-报表" class="headerlink" title="10.4 报表"></a>10.4 报表</h2><p>数据的分析与展示，通过柱形、折线、图形、等对数据进行处理，显示出数据的发展趋势、分类对比等结果。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image22.png]]</p>
<h2 id="10-5-数据大屏"><a href="#10-5-数据大屏" class="headerlink" title="10.5 数据大屏"></a>10.5 数据大屏</h2><p>宜搭针对付费客户，提供 10 张免费的专享模板，模板样式覆盖场景的企业数字化大屏解决方案场景。</p>
<p>[[%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/image23.png]]</p>
<h1 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h1><p><strong>优势：</strong></p>
<p><strong>①与钉钉高度集成</strong></p>
<p>a. 依托钉钉，宜搭的应用天生移动端和PC端同步完成，并且应用云化，使用起来简单方便。</p>
<p>b. 宜搭与钉钉应用数据是互通的，数据交互方便。</p>
<p>c. 钉钉提前帮宜搭完成人员信息管理，在宜搭搭建的新应用里，只需要配置角色就能完成权限系统与流程审批环节的设置。</p>
<p><strong>②生态好</strong></p>
<p>a. 用户数多，模板数量多，可参考案例多，官方文档多且都为中文。</p>
<p>b. 官方可提供的支持多。</p>
<p><strong>③可定制化程度高</strong></p>
<p>a. 对于复杂功能开发人员可自行编程实现。</p>
<p>b. 官方提供的接口多。</p>
<p>c. 组件可配置项多。</p>
<p><strong>劣势：</strong></p>
<p>a. 复杂逻辑仍需较大量的编程实现。</p>
<p>b. 无法覆盖所有的场景</p>
<p>c. <strong>与Apex相比较</strong>，缺少强大的数据分析能力</p>
<p>d. <strong>与Mendix相比较</strong>，没有配套的敏捷开发流程</p>
<p>e. <strong>与Power App相比较</strong>，与微软官方应用集成困难</p>
<p><strong>推荐使用场景：</strong></p>
<p>宜搭虽然是面向各个行业各种使用场景的，但是在使用过程中还是感觉到宜搭的使用场景更偏向日常办公，比如宜搭有面向工作审批流程的流程表单，当然宜搭的数据大屏也适合生产线的数据的展示与监控，但显然这满足不了我们开发用于生产的程序的需求。</p>
<p>a. 工作流不太复杂的场景，使用宜搭的流程表单能非常快速的实现。</p>
<p>b. 用于数据收集的场景，使用宜搭的普通表单可能十几分钟就能实现。</p>
<p>c. 复杂功能场景，宜搭的自定义页面可以实现复杂功能，虽然需要较多编程，但是因为宜搭提供了较多的具有特殊功能的组件，以及一些可配置项，所以相对于传统开发仍然是能节省不少时间。</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle获取日期</title>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/Oracle%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于经常会再oracle中获取当月的第一天/后一天/上一天/最后一天/上个月这一天，所以整理出下面的oracle获取日期大全出来，有什么更好的建议可以留言补充一下。</p>
<table>
<thead>
<tr>
<th>日期说明</th>
<th>oracle语句（假设现在是2018-11-28 11:11:11）</th>
<th>返回日期</th>
</tr>
</thead>
<tbody><tr>
<td>当月第一天</td>
<td>select trunc(sysdate, ‘mm’) from dual</td>
<td>2018-11-1</td>
</tr>
<tr>
<td>当年第一天</td>
<td>select trunc(sysdate,‘yy’) from dual</td>
<td>2018-1-1</td>
</tr>
<tr>
<td>当前年月日</td>
<td>select trunc(sysdate,‘dd’) from dual</td>
<td>2018-11-28</td>
</tr>
<tr>
<td>当年第一天</td>
<td>select trunc(sysdate,‘yyyy’) from dual</td>
<td>2018-1-1</td>
</tr>
<tr>
<td>当前星期的第一天 （也就是星期天）</td>
<td>select trunc(sysdate,‘d’) from dual</td>
<td>2018-11-28</td>
</tr>
<tr>
<td>当前日期</td>
<td>select trunc(sysdate) from dual</td>
<td>2018-11-28</td>
</tr>
<tr>
<td>当前时间（准确到小时）</td>
<td>select trunc(sysdate, ‘hh’) from dual</td>
<td>2018-11-28 11:00:00</td>
</tr>
<tr>
<td>当前时间（准确到分钟）</td>
<td>select to_char(trunc(sysdate, ‘mi’),‘yyyy-MM-dd HH:mm:ss’) from dual</td>
<td>2018-11-28 11:11:00</td>
</tr>
<tr>
<td>前一天的日期</td>
<td>select TRUNC(SYSDATE - 1) from dual</td>
<td>2018-11-27</td>
</tr>
<tr>
<td>前一个月的日期</td>
<td>select add_months(trunc(sysdate),-1) from dual</td>
<td>2018-10-28</td>
</tr>
<tr>
<td>后一个月的日期</td>
<td>select add_months(trunc(sysdate),1) from dual</td>
<td>2018-12-28</td>
</tr>
<tr>
<td>本月最后一天</td>
<td>select to_char(last_day(sysdate), ‘yyyy-mm-dd’) from dual</td>
<td>2018-11-30</td>
</tr>
</tbody></table>
<h2 id="TRUNC"><a href="#TRUNC" class="headerlink" title="TRUNC()"></a>TRUNC()</h2><p>trunc()函数返回以指定元素格式截去一部分的日期值，或者直接对数字格式的数据进行截断。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307251603421.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title>Floor()</title>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/Floor()/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>向下取整</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title>优化器</title>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/%E4%BC%98%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Oracle 优化器有两种模式：<strong>基于规则的优化器</strong>（Rule-Based Optimizer，RBO）和<strong>基于成本的优化器</strong>（Cost-Based Optimizer，CBO）。</p>
<h2 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h2><p>RBO 是 Oracle 数据库早期的查询优化器，在执行计划生成时使用固定的优化规则（如使用索引、连接方式选取等），可以保证相同查询在不同时间和环境下产生的执行计划相同。但是，由于没有考虑表数据量、索引选择等因素，可能导致性能不如 CBO。</p>
<h3 id="optimizer-mode"><a href="#optimizer-mode" class="headerlink" title="optimizer_mode"></a>optimizer_mode</h3><ul>
<li>  <strong>ALL_ROWS</strong>：代表基于成本的优化器（Cost-Based Optimizer, CBO），会尝试找到最小代价的执行计划，可以适用于查询结果集较大时的情况。</li>
<li>  **FIRST_ROWS(n)**：代表基于成本的优化器，但是该模式下优化器将尽量快地返回第一批结果，n 为表示要返回结果的行数。该模式适用于需要尽快返回结果的查询，但是可能会牺牲一部分查询性能。</li>
<li>  <strong>CHOOSE</strong>：代表 Oracle 数据库将根据统计信息和其他因素自动选择 RBO 或 CBO 中更适合具体语句的模式。<br>如果 optimizer_mode 参数没有被明确设置，则 Oracle 数据库会默认使用 CHOOSE 参数。在实际应用中，我们需要根据具体的业务场景灵活选择对应的 optimizer_mode 参数。</li>
</ul>
<h2 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h2><p>CBO 会通过收集统计信息（如表大小、数据分布、索引选择等）来计算每个可能执行计划的代价，并选择具有最小代价的执行计划。CBO 可以根据实际数据变化自动调整执行计划，提高了查询性能和可维护性。</p>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><h3 id="RULE"><a href="#RULE" class="headerlink" title="/*+ RULE */"></a><code>/*+ RULE */</code></h3><p>“<code>/*+ RULE */</code>“ 是 Oracle SQL 查询中的一个提示（hint），可以在 SQL 查询中使用，提示 Oracle 数据库使用基于规则的优化器（Rule-Based Optimizer, RBO）而不是基于成本的优化器（Cost-Based Optimizer, CBO）。</p>
<h3 id="INDEX-table-name-index-name"><a href="#INDEX-table-name-index-name" class="headerlink" title="/*+ INDEX(table_name index_name) */"></a><code>/*+ INDEX(table_name index_name) */</code></h3><p> “<code>/*+ INDEX(table_name index_name) */</code>“ 指定使用哪个索引来处理 SQL 查询结果，可以提高查询性能。</p>
<h3 id="FULL-table-name"><a href="#FULL-table-name" class="headerlink" title="/*+ FULL(table_name) */"></a><code>/*+ FULL(table_name) */</code></h3><p> “<code>/*+ FULL(table_name) */</code>“ 强制使用全表扫描来处理 SQL 查询结果，如果 Oracle 数据库自动选择索引访问来处理查询，但实际上数据量很小，全表扫描可能比使用索引访问更快。</p>
<h3 id="ORDERED"><a href="#ORDERED" class="headerlink" title="/*+ ORDERED */"></a><code>/*+ ORDERED */</code></h3><p> “<code>/*+ ORDERED */</code>“ 指定查询计划必须按照查询语句中指定的顺序逐个处理表和视图。这种提示在某些特殊场景下可以提高查询效率。</p>
<h3 id="LEADING-hint-table"><a href="#LEADING-hint-table" class="headerlink" title="/*+ LEADING(hint_table) */"></a><code>/*+ LEADING(hint_table) */</code></h3><p>“<code>/*+ LEADING(hint_table) */</code>“ 指定查询计划从 hint_table 开始处理关联表，可以影响查询执行的效率。</p>
<h3 id="USE-CONCAT"><a href="#USE-CONCAT" class="headerlink" title="/*+ USE_CONCAT */"></a><code>/*+ USE_CONCAT */</code></h3><p>“<code>/*+ USE_CONCAT */</code>“ 将多个 OR 条件正常使用的行级索引转换为连续的区段，从而避免行级索引本身的一些限制。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title>Untitled Database</title>
    <url>/2023/07/04/notion/Other/%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Untitled%20Database/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[[<a href="http://www.yuque.com/">www.yuque.com</a> yida support roe3o1]]<br>[[<a href="http://www.yuque.com/">www.yuque.com</a> yida support oim554]]<br>[[<a href="http://www.yuque.com/">www.yuque.com</a> yida support btrtnt]]<br>[[<a href="http://www.yuque.com/">www.yuque.com</a> yida support duy0wi]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
        <category>钉钉宜搭低代码平台分析报告</category>
      </categories>
  </entry>
  <entry>
    <title>all databases</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Database/all%20databases/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[[IndexedDB]]<br>[[Oracle]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Database</category>
      </categories>
  </entry>
  <entry>
    <title>(28条消息) 前台页面在具有同步ajax的function中修改样式只有在同步ajax执行完毕后才会生效的问题解决_Hatoandaburedo的博客-CSDN博客_function修改样式</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/(28%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E5%89%8D%E5%8F%B0%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%85%B7%E6%9C%89%E5%90%8C%E6%AD%A5ajax%E7%9A%84function%E4%B8%AD%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F%E5%8F%AA%E6%9C%89%E5%9C%A8%E5%90%8C%E6%AD%A5ajax%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E6%89%8D%E4%BC%9A%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3_Hatoandaburedo%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_function%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="28条消息-前台页面在具有同步ajax的function中修改样式只有在同步ajax执行完毕后才会生效的问题解决-Hatoandaburedo的博客-CSDN博客-function修改样式"><a href="#28条消息-前台页面在具有同步ajax的function中修改样式只有在同步ajax执行完毕后才会生效的问题解决-Hatoandaburedo的博客-CSDN博客-function修改样式" class="headerlink" title="(28条消息) 前台页面在具有同步ajax的function中修改样式只有在同步ajax执行完毕后才会生效的问题解决_Hatoandaburedo的博客-CSDN博客_function修改样式"></a>(28条消息) 前台页面在具有同步ajax的function中修改样式只有在同步ajax执行完毕后才会生效的问题解决_Hatoandaburedo的博客-CSDN博客_function修改样式</h1><p>Created: June 30, 2022 10:24 AM<br>Tags: #css, #js, #js引擎, #渲染引擎<br>URL: <a href="https://blog.csdn.net/qq_27607579/article/details/86308270">https://blog.csdn.net/qq_27607579/article/details/86308270</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#渲染引擎</tag>
        <tag>#css</tag>
        <tag>#js引擎</tag>
        <tag>#js</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel 配置用法解析 - 渴望成为大牛的男人</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Babel%20%E9%85%8D%E7%BD%AE%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90%20-%20%E6%B8%B4%E6%9C%9B%E6%88%90%E4%B8%BA%E5%A4%A7%E7%89%9B%E7%9A%84%E7%94%B7%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Babel-配置用法解析-渴望成为大牛的男人"><a href="#Babel-配置用法解析-渴望成为大牛的男人" class="headerlink" title="Babel 配置用法解析 - 渴望成为大牛的男人"></a>Babel 配置用法解析 - 渴望成为大牛的男人</h1><p>Created: November 16, 2021 3:46 PM<br>URL: <a href="https://www.cnblogs.com/bai1218/p/12392180.html">https://www.cnblogs.com/bai1218/p/12392180.html</a></p>
<h1 id="Babel-配置用法解析"><a href="#Babel-配置用法解析" class="headerlink" title="Babel 配置用法解析"></a><strong>Babel 配置用法解析</strong></h1><p>刚复工的时候我司业务太多了，我已不记得我们连续作战了多少天，最近算是有时间可以学习学习我的<strong>babel</strong>大宝贝了，上周末看了下<strong>babel</strong>的一些核心模块以及babel的一些配置，今天继续以博客的形式记录总结下来。</p>
<hr>
<h3 id="写前面：babel默认是只会去转义js语法的，不会去转换新的API，比如像Promise、Generator、Symbol这种全局API对象，babel是不会去编译的。在我学会了babe配置l大法之后，看我一会儿怎么把这些新的API给它编译出来就完事儿了。"><a href="#写前面：babel默认是只会去转义js语法的，不会去转换新的API，比如像Promise、Generator、Symbol这种全局API对象，babel是不会去编译的。在我学会了babe配置l大法之后，看我一会儿怎么把这些新的API给它编译出来就完事儿了。" class="headerlink" title="写前面：babel默认是只会去转义js语法的，不会去转换新的API，比如像Promise、Generator、Symbol这种全局API对象，babel是不会去编译的。在我学会了babe配置l大法之后，看我一会儿怎么把这些新的API给它编译出来就完事儿了。"></a><strong>写前面：babel默认是只会去转义js语法的，不会去转换新的API，比如像Promise、Generator、Symbol这种全局API对象，babel是不会去编译的。在我学会了babe配置l大法之后，看我一会儿怎么把这些新的API给它编译出来就完事儿了。</strong></h3><h3 id="本文基于babel7-8-0。我主要记录下babel配置需要的一些重要的模块儿包，来一步步进行babel的一个配置解析-以babel-config-js方式配置为例-。"><a href="#本文基于babel7-8-0。我主要记录下babel配置需要的一些重要的模块儿包，来一步步进行babel的一个配置解析-以babel-config-js方式配置为例-。" class="headerlink" title="本文基于babel7.8.0。我主要记录下babel配置需要的一些重要的模块儿包，来一步步进行babel的一个配置解析(以babel.config.js方式配置为例)。"></a><strong>本文基于babel7.8.0。我主要记录下babel配置需要的一些重要的模块儿包，来一步步进行babel的一个配置解析(以babel.config.js方式配置为例)。</strong></h3><h3 id="本文主要涉及到的一些babel包：-babel-core，-babel-cli，-babel-plugin-，-babel-preset-env，-babel-polyfill，-babel-runtime，-babel-plugin-transform-runtime。"><a href="#本文主要涉及到的一些babel包：-babel-core，-babel-cli，-babel-plugin-，-babel-preset-env，-babel-polyfill，-babel-runtime，-babel-plugin-transform-runtime。" class="headerlink" title="本文主要涉及到的一些babel包：@babel/core，@babel/cli，@babel/plugin*，@babel/preset-env，@babel/polyfill，@babel/runtime，@babel/plugin-transform-runtime。"></a><strong>本文主要涉及到的一些babel包：<code>@babel/core</code>，<code>@babel/cli</code>，<code>@babel/plugin*</code>，<code>@babel/preset-env</code>，<code>@babel/polyfill</code>，<code>@babel/runtime</code>，<code>@babel/plugin-transform-runtime</code>。</strong></h3><h3 id="那，话不多说，发车？"><a href="#那，话不多说，发车？" class="headerlink" title="那，话不多说，发车？"></a><strong>那，话不多说，发车？</strong></h3><h2 id="babel-core"><a href="#babel-core" class="headerlink" title="@babel/core#"></a><strong>@babel/core<a href="https://www.cnblogs.com/bai1218/p/12392180.html#1770306071">#</a></strong></h2><p><strong>@babel/core</strong> 这个包里主要都是一些去对代码进行转换的核心方法，具体里面的一些api方法我就不做介绍了；引用官网的一句话：<strong>“所有转换将使用本地配置文件”</strong>，所以待会儿我们的<strong>babel.config.js</strong>配置文件就很重要了；再一个core就是核心的意思嘛，所以我们话不多说先把它装起来，gogogo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">npm install --save-dev @babel/core</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="babel-cli"><a href="#babel-cli" class="headerlink" title="@babel/cli#"></a><strong>@babel/cli<a href="https://www.cnblogs.com/bai1218/p/12392180.html#3616714665">#</a></strong></h2><p>这个 <strong>@babel/cli</strong>就是babel带有的内置cli，可以用来让我们从命令行来编译我们的文件，有了他我们就很方便的对<strong>babel</strong>进行学习了，那话不多说，先装起来？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">npm install --save-dev @babel/cli</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>装完之后你就可以这样来编译你的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">npx babel study.js --watch --out-file study-compiled.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单介绍下上面命令用到的几个参数：<code>--out-file</code>用来把编译后的目标文件输出到对应的文件；如果希望在每次更改目标文件时都进行编译，可以加上 <code>--watch</code>选项；当然还有一些别的选项，不过在我学习<strong>babel</strong>以及配置的话，这两个选项已经够我用了。</p>
<p><strong>在操作的过程中如果改了babel配置发现编译出来的文件并没有实时编译的情况，需要注意下，如果改了配置文件那就需要重新执行这段命令，要不然babel读不到新的配置。</strong></p>
<p>如果你已经创建了study.js文件并且执行了这段命令，你会发现，对应的study-compiled.js还没发生变化，因为我们还没开始写babel的配置文件，莫慌，马上开始。</p>
<h2 id="babel-plugin-和-babel-preset-env"><a href="#babel-plugin-和-babel-preset-env" class="headerlink" title="@babel/plugin*和@babel/preset-env#"></a><strong>@babel/plugin*和@babel/preset-env<a href="https://www.cnblogs.com/bai1218/p/12392180.html#1859754284">#</a></strong></h2><p><strong>babel</strong>插件和<strong>babel</strong>预设是<strong>babel</strong>配置的两个主要模块，所以我就放在一起说了。</p>
<h3 id="babel-plugin"><a href="#babel-plugin" class="headerlink" title="@babel/plugin#*"></a><em><em>@babel/plugin</em><a href="https://www.cnblogs.com/bai1218/p/12392180.html#159263161">#</a></em>*</h3><p>首先我们先来说下<strong>babel</strong>的<strong>Plugins</strong>，<strong>babel</strong>官网也说了，人<strong>babel</strong>是基于插件化的，大概就是说全是插件，所以说我们配置文件里如果什么插件也不配的话，那输入和输出就是一样的，插件插件，你得插上我才让你用。我来编译一个最简单的箭头函数来看下这个<strong>babel</strong>的插件怎么用，来了，这波我们就需要配置文件了，以下所有的配置都是说的在<strong>babel.config.js</strong>文件里，<strong>相应的插件记得install</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* babel.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    &quot;@babel/plugin-transform-arrow-functions&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后执行我们上面那段cli的命令，就会得到这种效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">const study = () =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">const study = function () &#123;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，如果我们想要使用es6给数值新增的指数运算符怎么办，只需要添加相应的 <strong>@babel/plugin-transform-exponentiation-operator</strong> 插件即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* babel.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    &quot;@babel/plugin-transform-arrow-functions&quot;,</span><br><span class="line">    &quot;@babel/plugin-transform-exponentiation-operator&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应的es6语法就会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">const exponentiation = 2 ** 2</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">const exponentiation = Math.pow(2, 2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env#"></a><strong>@babel/preset-env<a href="https://www.cnblogs.com/bai1218/p/12392180.html#3064949419">#</a></strong></h3><p>从上面的插件化我们就知道需要哪个插件就去引入就完事儿，那么问题来了，es6新增的语法那么多，我总不能一个插件一个插件去添加吧，这样也太麻烦了，这个时候就要用到babel提供的<strong>presets</strong>了。</p>
<p><strong>presets</strong>也就是预设的意思，大概意思就是可以预先设定好一些东西，就省得我们一个个的去引入插件了。官方提供了很多<strong>presets</strong>，比如<strong>preset-env</strong>（处理es6+规范语法的插件集合）、<strong>preset-stage</strong>（一些处理尚在提案阶段的语法的插件集合，当然这种预设的方式在 <strong>babel 7+</strong> 版本已经被废弃了）、<strong>preset-react</strong>（处理react语法的插件集合）等等。</p>
<p>我们主要来介绍下<strong>preset-env</strong>：<strong>preset-env</strong>是一个<strong>智能</strong>预设，配置了它就可以让你用es6+去书写你的代码，而且他会按需去加载所需要的插件，让你的生活更加美好。。。接下来我们记得先install这个 <strong>@babel/preset-env</strong>一波，不配任何插件，然后我们再来看看效果如何：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* babel.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    &quot;@babel/preset-env&quot;</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应的es6语法就会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">const study = () =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">const arr1 = [1, 2, 33]</span><br><span class="line">const arr2 = [...arr1]</span><br><span class="line"></span><br><span class="line">const exponentiation = 2 ** 2</span><br><span class="line"></span><br><span class="line">// 新增API</span><br><span class="line">new Promise(() =&gt; &#123;&#125;)</span><br><span class="line">new Map()</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">var study = function study() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var arr1 = [1, 2, 33];</span><br><span class="line">var arr2 = [].concat(arr1);</span><br><span class="line">var exponentiation = Math.pow(2, 2);</span><br><span class="line"></span><br><span class="line">// 新增API</span><br><span class="line">new Promise(function () &#123;&#125;);</span><br><span class="line">new Map();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你会发现es6+的语法都被编译了，我们并没有设置任何插件哦，应该也看到了新增的API方法并没有被编译，在这里我们埋下伏笔，等下文讲到<strong>polyfill</strong>的时候再治他。</p>
<h3 id="Browserslist集成"><a href="#Browserslist集成" class="headerlink" title="Browserslist集成"></a><strong>Browserslist集成</strong></h3><p>关于<strong>preset-env</strong>，我们还可以提供一个<code>targets</code>配置项指定运行环境，就是我们可以配置对应目标浏览器环境，那么<strong>babel</strong>就会编译出对应目标浏览器环境可以运行的代码。相信有同学遇到过在低版本系统ios手机里自己的项目会白屏，其实是某些语法在ios低版本系统里不支持，这个时候我们可以直接配置ios 7浏览器环境都可以支持的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* babel.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/preset-env&quot;, &#123;</span><br><span class="line">        &#x27;targets&#x27;: &#123;</span><br><span class="line">          &#x27;browsers&#x27;: [&#x27;ie &gt;= 8&#x27;, &#x27;iOS 7&#x27;] // 支持ie8，直接使用iOS浏览器版本7</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然<strong>babel</strong>的<strong>Browserslist</strong>集成还支持在<strong>package.json</strong>文件里或者新建一个 <strong>.browserslistrc</strong> 文件来指定对应目标环境。<a href="https://github.com/browserslist/browserslist#queries">browserslist配置源</a></p>
<h2 id="babel-polyfill-由core-js2和regenerator-runtime组成的一个集成包"><a href="#babel-polyfill-由core-js2和regenerator-runtime组成的一个集成包" class="headerlink" title="@babel/polyfill(由core-js2和regenerator-runtime组成的一个集成包)#"></a><strong>@babel/polyfill(由core-js2和regenerator-runtime组成的一个集成包)<a href="https://www.cnblogs.com/bai1218/p/12392180.html#1822101924">#</a></strong></h2><p>上文也提到了像Promise这种API咱们的<strong>babel</strong>并没有给转义，那是因为<strong>babel</strong>默认是只会去转义js语法的，不会去转换新的API，比如像Promise、Generator、Symbol这种全局API对象，<strong>babel</strong>是不会去编译的，这个时候就要掏出 <strong>@babel/polyfill</strong> 了。用法很简单，先安装一波，然后我们只需要在入口文件顶部引入 <strong>@babel/polyfill</strong> 就可以使用新增的API了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">import &#x27;@babel/polyfill&#x27;</span><br><span class="line">// 新增API</span><br><span class="line">new Promise(function () &#123;&#125;);</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">require(&quot;@babel/polyfill&quot;);</span><br><span class="line">// 新增API</span><br><span class="line">new Promise(function () &#123;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小细节：import被编译成了require，如果想要编译出来的模块引入规范还是import，则可以在preset-env的配置项中添加”modules”: false即可。modules的options：”amd” | “umd” | “systemjs” | “commonjs” | “cjs” | “auto” | false，默认为”auto”</p>
</blockquote>
<p>但是问题又来了，有时候我们项目里并没有用到那么多的新增API，但是 <strong>@babel/polyfill</strong> 会把所有浏览器环境的的polyfill都引入，整个包的体积就会很大，我们想要对目标环境按需引入相应的polyfill应该怎么办呢，这个时候我们就可以使用 <strong>preset-env</strong> 的配置项中的<code>useBuiltIns</code>属性来按需引入polyfill。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* babel.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/preset-env&quot;, &#123;</span><br><span class="line">        &quot;modules&quot;: false,</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;entry&quot;,</span><br><span class="line">        &#x27;targets&#x27;: &#123;</span><br><span class="line">          &#x27;browsers&#x27;: [&#x27;ie &gt;= 8&#x27;, &#x27;iOS 7&#x27;] // 支持ie8，直接使用iOS浏览器版本7</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候就会在入口处只把所有ie8以上以及iOS 7浏览器不支持api的polyfill引入进来。</p>
<p>最终效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">import &#x27;@babel/polyfill&#x27;</span><br><span class="line">// 新增API</span><br><span class="line">new Promise(function () &#123;&#125;);</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">import &quot;core-js/modules/es6.array.copy-within&quot;;</span><br><span class="line">import &quot;core-js/modules/es6.array.every&quot;;</span><br><span class="line">...//省略若干</span><br><span class="line">import &quot;core-js/modules/web.immediate&quot;;</span><br><span class="line">import &quot;core-js/modules/web.dom.iterable&quot;;</span><br><span class="line">import &quot;regenerator-runtime/runtime&quot;;</span><br><span class="line">// 新增API</span><br><span class="line">new Promise(function () &#123;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时你会发现，import ‘@babel/polyfill’没有了，引入的是我们目标环境相应的polyfill。但是有没有发现引入的都是import ‘core-js/…’的内容，标题已经说啦，**@babel/polyfil**是由core-js2和regenerator-runtime组成的一个集成包。</p>
<p>这个时候你又会想，假如我的项目里面只用到了Promise这个API，能不能只给我引入Promise相应的API呢？答案是必可以！，让我们先来好好了解下<strong>preset-env</strong>的配置项中的<code>useBuiltIns</code>属性。</p>
<h3 id="useBuiltIns"><a href="#useBuiltIns" class="headerlink" title="useBuiltIns"></a><strong>useBuiltIns</strong></h3><p>选项：”usage”| “entry”| false，默认为false。</p>
<p><code>entry</code>我们已经用过了，意义就是在入口处将根据我们配置的浏览器兼容，将目标浏览器环境所有不支持的API都引入。</p>
<p><code>usage</code>就很nb了，当配置成usage的时候，babel会扫描你的每个文件，然后检查你都用到了哪些新的API，跟进我们配置的浏览器兼容，只引入相应API的polyfill，我们把<code>useBuiltIns</code>属性设置为<code>usage</code>再来看下编译效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">import &#x27;@babel/polyfill&#x27;</span><br><span class="line">// 新增API</span><br><span class="line">new Promise(function () &#123;&#125;);</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">import &quot;core-js/modules/es.object.to-string&quot;;</span><br><span class="line">import &quot;core-js/modules/es.promise&quot;;</span><br><span class="line">// 新增API</span><br><span class="line">new Promise(function () &#123;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我就问你帅不帅！完全的按需引入，牛逼了！</p>
<p>相信你也看到了一个东西，当我们使用<code>useBuiltIns</code>选项的时候，你的命令行里面是不是显示了一坨这样的警告，大概是在配置文件中未指定core-js版本时，默认会使用core-js2：</p>
<blockquote>
<p>WARNING: We noticed you’re using the useBuiltIns option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the corejs option.</p>
</blockquote>
<p>前面也说到了 <strong>@babel/polyfil</strong> 是由core-js2和regenerator-runtime组成的一个集成包，现在core-js3已经发布了，而且很稳定。但是core-js2在18年的时候已经不再维护了；**@babel/polyfil**引入的是2不是3，并且 <strong>@babel/polyfill</strong> 在babel7.4.0已经不再推荐使用了，要废掉(好像是因为@babel/polyfill不支持core-js2平滑的过渡到core-js3)。所以core-js官方现在推荐我们使用polyfill的时候直接引入core-js和regenerator-runtime/runtime这两个包完全取代 <strong>@babel/polyfil</strong> 来为了防止重大更改。</p>
<p>当然，我们需要在preset-env配置项中指定core-js版本，这样就不会再有警告⚠️了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* babel.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/preset-env&quot;, &#123;</span><br><span class="line">        &quot;modules&quot;: false,</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;entry&quot;,</span><br><span class="line">        &quot;corejs&quot;: &quot;3&quot;,</span><br><span class="line">        &#x27;targets&#x27;: &#123;</span><br><span class="line">          &#x27;browsers&#x27;: [&#x27;not ie &gt;= 8&#x27;, &#x27;iOS 7&#x27;] // 支持ie8，直接使用iOS浏览器版本7</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="babel-runtime-依赖-babel-helpers和regenerator-runtime"><a href="#babel-runtime-依赖-babel-helpers和regenerator-runtime" class="headerlink" title="@babel/runtime(依赖@babel/helpers和regenerator-runtime)#"></a><strong>@babel/runtime(依赖@babel/helpers和regenerator-runtime)<a href="https://www.cnblogs.com/bai1218/p/12392180.html#710480462">#</a></strong></h2><p>有的时候一些语法的转换会比较复杂，babel会引入一些helper函数，比如说对es6的class进行转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">class Test &#123;&#125;</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</span><br><span class="line"></span><br><span class="line">var Test = function Test() &#123;</span><br><span class="line">  _classCallCheck(this, Test);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到上面引入了helper函数来处理class的转换。但是问题又来了，如果好多文件都使用到了复杂语法的转换，这个还是简单点的，有些helper函数是很复杂代码量很多的，那岂不是每个文件都会定义一遍这些个函数，每个文件的代码会很多？如果说可以把这些helper函数都抽离到一个公共的包里，用到的地方只需要引入对应的函数即可，我们的编译出来的代码量会大大滴减少，这个时候就需要用到 <strong>@babel/plugin-transform-runtime</strong> 插件来配合@babel/runtime进行使用。记得先安装一波，然后在插件选项中加入 <strong>@babel/plugin-transform-runtime</strong> 这个插件，然后我们来看看编译后的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">class Test &#123;&#125;</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">import _classCallCheck from &quot;@babel/runtime/helpers/classCallCheck&quot;;</span><br><span class="line"></span><br><span class="line">var Test = function Test() &#123;</span><br><span class="line">  _classCallCheck(this, Test);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然如果我们只是为了减少编译出来的文件中代码量而使用这个插件的话就太小看他了，而且也没有必要。</p>
<p><strong>@babel/plugin-transform-runtime</strong>还有一个最重要的作用：比如说像上面我们说的Promise就需要提供相应的polyfill去解决，这样做会有一个副作用，就是会污染全局变量。如果我们只是在一个业务项目这样搞还好，也没别人要用到。但是如果我们是在维护一个公共的东西，比如公共组件库，我们这样搞，你的一些polyfill可能会把一些全局的api给改掉，副作用就会很明显，别人用你的组件库的时候就可能会出问题。**@babel/plugin-transform-runtime**插件为我们提供了一个配置项corejs，他可以给这些polyfill提供一个<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318?fr=aladdin">沙箱环境</a>，这样就不会污染到全局变量，无副作用你说美不美。</p>
<p>记得安装 <strong>@babel/runtime-corejs2</strong> 这个包(稳定版用2就可以)，注意如果不配置的话，是不会提供沙箱环境的。然后在 <strong>@babel/plugin-transform-runtime</strong> 插件配置corejs：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* babel.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/preset-env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;modules&quot;: false,</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</span><br><span class="line">        &quot;corejs&quot;: &quot;3&quot;,</span><br><span class="line">        &#x27;targets&#x27;: &#123;</span><br><span class="line">          &#x27;browsers&#x27;: [&quot;ie &gt;= 8&quot;, &quot;iOS 7&quot;] // 支持ie8，直接使用iOS浏览器版本7</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;corejs&quot;: 2</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们来看下编译后的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">/* study.js */</span><br><span class="line">new Promise(() =&gt; &#123;&#125;)</span><br><span class="line">class Test &#123;&#125;</span><br><span class="line"></span><br><span class="line">/* study-compiled.js */</span><br><span class="line">import _classCallCheck from &quot;@babel/runtime-corejs2/helpers/classCallCheck&quot;;</span><br><span class="line">import _Promise from &quot;@babel/runtime-corejs2/core-js/promise&quot;;</span><br><span class="line"></span><br><span class="line">new _Promise(function () &#123;&#125;);</span><br><span class="line">var Test = function Test() &#123;</span><br><span class="line">  _classCallCheck(this, Test);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小节"><a href="#小节" class="headerlink" title="小节#"></a><strong>小节<a href="https://www.cnblogs.com/bai1218/p/12392180.html#2651825425">#</a></strong></h3><ul>
<li>在你修改了babel配置项之后一定要记得重启编译命令，否则不会生效</li>
<li>维护公共组件库或者一些别的公共库推荐要使用@babel/runtime配合@babel/plugin-transform-runtime来建立沙箱环境</li>
</ul>
<blockquote>
<p>接下来本人会去继续研究babel是如何解析编译的，target：理解babel如何解析编译，能够手写一个babel插件出来。最近需求比较多，下一篇估计得等到Q2了。。。</p>
</blockquote>
<h3 id="写在最后："><a href="#写在最后：" class="headerlink" title="写在最后：#"></a><strong>写在最后：<a href="https://www.cnblogs.com/bai1218/p/12392180.html#1829814269">#</a></strong></h3><p>最近也是疫情期间，大家一定要记得尽量少出门，出门必带口罩。像白衣天使们致敬！</p>
<p>分类: <a href="https://www.cnblogs.com/bai1218/category/1626898.html">babel之旅</a></p>
<p>标签: <a href="https://www.cnblogs.com/bai1218/tag/babel/">babel</a>, <a href="https://www.cnblogs.com/bai1218/tag/babel%E9%85%8D%E7%BD%AE/">babel配置</a></p>
<p><a href="https://www.cnblogs.com/bai1218/p/12153618.html">«</a> 上一篇： <a href="https://www.cnblogs.com/bai1218/p/12153618.html">babel版本变化 - 简单理解</a><a href="https://www.cnblogs.com/bai1218/p/14164113.html">»</a> 下一篇： <a href="https://www.cnblogs.com/bai1218/p/14164113.html">IphoneX适配正确姿势</a></p>
<p>posted @ 2020-03-01 21:24  <a href="https://www.cnblogs.com/bai1218/">渴望成为大牛的男人</a>  阅读(14539)  评论(2)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=12392180">编辑</a>  收藏  举报</p>
<p>抱歉！发生了错误！麻烦反馈至<a href="mailto:&#x63;&#111;&#110;&#x74;&#97;&#99;&#x74;&#64;&#x63;&#110;&#x62;&#x6c;&#x6f;&#103;&#x73;&#46;&#x63;&#x6f;&#x6d;">&#x63;&#111;&#110;&#x74;&#97;&#99;&#x74;&#64;&#x63;&#110;&#x62;&#x6c;&#x6f;&#103;&#x73;&#46;&#x63;&#x6f;&#x6d;</a></p>
<p>登录后才能查看或发表评论，立即 登录 或者 <a href="https://www.cnblogs.com/">逛逛</a> 博客园首页</p>
<p><strong>编辑推荐：</strong>· <a href="https://www.cnblogs.com/huangxincheng/p/15554711.html">记一次 .NET 某公交卡扣费系统 程序卡死分析</a>· <a href="https://www.cnblogs.com/dotey/p/design-system.html">设计系统，设计和开发之间的“DevOps”</a>· <a href="https://www.cnblogs.com/dino623/p/uwp_galaxy_shuttle.html">3D 穿梭效果？使用 UWP 也能搞定</a>· <a href="https://www.cnblogs.com/xiaoxiaotank/p/15525052.html">理解ASP.NET Core - 日志(Logging)</a>· <a href="https://www.cnblogs.com/tcjiaan/p/15528276.html">[.NET 与树莓派] 用 MPD 制作数字音乐播放器</a></p>
<p><strong>最新新闻</strong>：· <a href="https://news.cnblogs.com/n/707078/">时隔10年谷歌计划重启谷歌实验室 聚焦AR、VR项目发力元宇宙（2021-11-16 14:00）</a>· <a href="https://news.cnblogs.com/n/707077/">如果量子计算发展超过区块链技术 那么如何保护数字货币安全呢？（2021-11-16 13:49）</a>· <a href="https://news.cnblogs.com/n/707076/">亚马逊挑战《魔兽世界》惨遭滑铁卢：原创新游戏高开低走，一个月玩家流失75%（2021-11-16 13:41）</a>· <a href="https://news.cnblogs.com/n/707065/">猫鼠游戏继续：微软阻止Edge Deflector 强迫Windows 11用户调用Edge（2021-11-16 13:26）</a>· <a href="https://news.cnblogs.com/n/707042/">互联网到处是预售（2021-11-16 12:57）</a>» <a href="https://news.cnblogs.com/">更多新闻…</a></p>
<p>Copyright © 2021 渴望成为大牛的男人Powered by .NET 6 on Kubernetes &amp; Theme <a href="https://github.com/esofar/cnblogs-theme-silence">Silence v2.0.2</a></p>
<p><strong>CONTENTS</strong></p>
<p>✕</p>
<ul>
<li>1. @babel/core</li>
<li>2. @babel/cli</li>
<li>3. @babel/plugin*和@babel/preset-env</li>
<li>3.1. @babel/plugin*</li>
<li>3.2. @babel/preset-env</li>
<li>4. @babel/polyfill(由core-js2和regenerator-runtime组成的一个集成包)</li>
<li>5. @babel/runtime(依赖@babel/helpers和regenerator-runtime)</li>
<li>5.1. 小节</li>
<li>5.2. 写在最后：</li>
</ul>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
  </entry>
  <entry>
    <title>Create stunning content</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Create%20stunning%20content/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Create-stunning-content"><a href="#Create-stunning-content" class="headerlink" title="Create stunning content"></a>Create stunning content</h1><p>Created: December 13, 2021 4:52 PM<br>Tags: #notion, #ppt, #snackthis<br>URL: <a href="https://snackthis.co/">https://snackthis.co/</a><br>author: Jackson</p>
<p>[[https//snackthis.co/static/stunning-cdb81ace26ddc23dde00a857f222bdf4.gif]]</p>
<hr>
<p>[[Create stunning content/stunning-cdb81ace26ddc23dde00a857f222bdf4.gif]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#snackthis</tag>
        <tag>#ppt</tag>
        <tag>#notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Css实现漂亮的滚动条样式 - 简书</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Css%E5%AE%9E%E7%8E%B0%E6%BC%82%E4%BA%AE%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F%20-%20%E7%AE%80%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Css实现漂亮的滚动条样式-简书"><a href="#Css实现漂亮的滚动条样式-简书" class="headerlink" title="Css实现漂亮的滚动条样式 - 简书"></a>Css实现漂亮的滚动条样式 - 简书</h1><p>Created: October 27, 2021 2:50 PM<br>Tags: #css, #web, #简书<br>URL: <a href="https://www.jianshu.com/p/c2addb233acd">https://www.jianshu.com/p/c2addb233acd</a><br>author: nomooo</p>
<p><a href="Css%E5%AE%9E%E7%8E%B0%E6%BC%82%E4%BA%AE%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F%20-%20%E7%AE%80%E4%B9%A6%20a19c6d3ef57b437fb2f3ad52377f50f0/c2addb233acd">c2addb233acd</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#css</tag>
        <tag>#简书</tag>
        <tag>#web</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse设置代码格式化（详解）</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Eclipse%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Eclipse设置代码格式化（详解）"><a href="#Eclipse设置代码格式化（详解）" class="headerlink" title="Eclipse设置代码格式化（详解）"></a>Eclipse设置代码格式化（详解）</h1><p>Created: October 27, 2021 9:20 AM<br>Tags: #CSDN, #eclipse<br>URL: <a href="https://blog.csdn.net/weixin_46028577/article/details/106431924">https://blog.csdn.net/weixin_46028577/article/details/106431924</a></p>
<h3 id="（错误演示）"><a href="#（错误演示）" class="headerlink" title="（错误演示）"></a>（错误演示）</h3><p>[[Eclipse%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/20200529195914280.png]]</p>
<h2 id="方法一：直接在代码界面右键，选择Source—》format"><a href="#方法一：直接在代码界面右键，选择Source—》format" class="headerlink" title="方法一：直接在代码界面右键，选择Source—》format"></a>方法一：直接在代码界面右键，选择Source—》format</h2><p>[[Eclipse%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/20200529200016878.png]]</p>
<h2 id="方法二：一劳永逸，设置自动格式化，Window—》Preferences"><a href="#方法二：一劳永逸，设置自动格式化，Window—》Preferences" class="headerlink" title="方法二：一劳永逸，设置自动格式化，Window—》Preferences"></a>方法二：一劳永逸，设置自动格式化，Window—》Preferences</h2><p>[[Eclipse%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/2020052920014718.png]]</p>
<h3 id="写完代码后保存即可"><a href="#写完代码后保存即可" class="headerlink" title="写完代码后保存即可"></a>写完代码后保存即可</h3><h3 id="（正确演示）"><a href="#（正确演示）" class="headerlink" title="（正确演示）"></a>（正确演示）</h3><p>[[Eclipse%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/20200529200449892.png]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#CSDN</tag>
        <tag>#eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>Express Learning</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Express%20Learning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Express-Learning"><a href="#Express-Learning" class="headerlink" title="Express Learning"></a>Express Learning</h1><p>Created: December 2, 2021 6:09 PM<br>Tags: #express, #node</p>
<h1 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h1><p><strong>路由</strong>（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#express</tag>
        <tag>#node</tag>
      </tags>
  </entry>
  <entry>
    <title>Indify – Notion Widgets</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Indify%20%E2%80%93%20Notion%20Widgets/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Indify-–-Notion-Widgets"><a href="#Indify-–-Notion-Widgets" class="headerlink" title="Indify – Notion Widgets"></a>Indify – Notion Widgets</h1><p>Created: November 3, 2021 3:43 PM<br>Tags: #notion<br>URL: <a href="https://indify.co/">https://indify.co/</a><br>author: Indify</p>
<p>-</p>
<pre><code>[[Indify – Notion Widgets/calendar.png]]
</code></pre>
<p>-</p>
<pre><code>[[Indify – Notion Widgets/weather.png]]
</code></pre>
<h3 id="Join-our-community"><a href="#Join-our-community" class="headerlink" title="Join our community!"></a>Join our community!</h3><p>Widgets made with ❤️ by Indify. If you have any questions, please email us at <a href="mailto:hello+support@indify.co">hello@indify.co</a>.</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Interview</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Interview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Interview"><a href="#Interview" class="headerlink" title="Interview"></a>Interview</h1><p>Created: October 19, 2022 3:46 PM</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
  </entry>
  <entry>
    <title>Notion Official</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Notion%20Official/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Notion-Official"><a href="#Notion-Official" class="headerlink" title="Notion Official"></a>Notion Official</h1><p>Created: October 26, 2021 2:18 PM<br>Tags: #notion<br>URL: <a href="https://www.notion.so/Notion-Official-83715d7703ee4b8699b5e659a4712dd8">https://www.notion.so/Notion-Official-83715d7703ee4b8699b5e659a4712dd8</a></p>
<p>[[Notion Official/https3A2F2Fs3-us-west-2.amazonaws.com2Fsecure.notion-static.com2Fff307fed-4664-46b0-8de1-6fdcc1e937b22FNotion-logo.png]]</p>
<p><a href="https://www.processon.com/embed/5d3ab497e4b065dc42b38ca0">https://www.processon.com/embed/5d3ab497e4b065dc42b38ca0</a></p>
<p><a href="http://player.bilibili.com/player.html?aid=336205825&bvid=BV16R4y1J7Xr&cid=426660585&page=1&high_quality=1">http://player.bilibili.com/player.html?aid=336205825&amp;bvid=BV16R4y1J7Xr&amp;cid=426660585&amp;page=1&amp;high_quality=1</a></p>
<iframe src="[//player.bilibili.com/player.html?aid=336205825&bvid=BV16R4y1J7Xr&cid=426660585&page=1](notion://player.bilibili.com/player.html?aid=336205825&bvid=BV16R4y1J7Xr&cid=426660585&page=1)" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><a href="http://player.bilibili.com/player.html?aid=336205825&bvid=BV16R4y1J7Xr&cid=426660585&page=1">http://player.bilibili.com/player.html?aid=336205825&amp;bvid=BV16R4y1J7Xr&amp;cid=426660585&amp;page=1</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion Template Gallery</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Notion%20Template%20Gallery/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Notion-Template-Gallery"><a href="#Notion-Template-Gallery" class="headerlink" title="Notion Template Gallery"></a>Notion Template Gallery</h1><p>Created: October 26, 2021 1:45 PM<br>Tags: #notion<br>URL: <a href="https://www.notion.so/Notion-Template-Gallery-181e961aeb5c4ee6915307c0dfd5156d">https://www.notion.so/Notion-Template-Gallery-181e961aeb5c4ee6915307c0dfd5156d</a></p>
<p>[[Notion Template Gallery/default.png]]</p>
<p>Whether you’re just getting off the ground or scaling fast, get started running your startup in Notion with these handy templates.</p>
<p>Get started using Notion to organize your assignments, deadlines, and life as a student with these templates.</p>
<p>Like most folks these days, the Notion team is now working from home. We put together a few templates for remote teams to stay on track.</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion 优质资源汇总 - 少数派</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Notion%20%E4%BC%98%E8%B4%A8%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Notion-优质资源汇总-少数派"><a href="#Notion-优质资源汇总-少数派" class="headerlink" title="Notion 优质资源汇总 - 少数派"></a>Notion 优质资源汇总 - 少数派</h1><p>Created: May 26, 2022 8:30 AM<br>Tags: #notion, #少数派<br>URL: <a href="https://sspai.com/post/71893">https://sspai.com/post/71893</a></p>
<p>[[https//cdn.sspai.com/2022/03/07/e5f314d934a4fb5a960f89cf21edf749.png]]</p>
<hr>
<p>[[Notion 优%E8%B4%A8%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB - %E5%B0%91%E6%95%B0%E6%B4%BE/e5f314d934a4fb5a960f89cf21edf749.png]]</p>
<p><strong>Matrix 首页推荐</strong></p>
<p><a href="https://sspai.com/matrix">Matrix</a> 是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。</p>
<p>文章代表作者个人观点，少数派仅对标题和排版略作修改。</p>
<p>如果询问这两年来最火爆的笔记类产品，那么答案很有可能是 [[Notion]].</p>
<p>在产品端，已经有了不少 Notion 类的产品。具体可以移步参阅我的另外一篇文章《<a href="https://sspai.com/post/71905">关于 Notion-Like 工具的畅想</a>》。其中，有些产品在 Notion 的基础上做了优化，也有一些增加了一些新的特色功能。比如，国外有主打本地和加密等特性的 <a href="https://anytype.io/">AnyType</a>, 国内有可以当作网盘的文件夹页面功能、通过原生开发提升使用体验的 <a href="https://flowus.cn/login">FlowUs</a>.</p>
<p>在用户端，Notion 中文社区已经拥有 11200 多人。在各大数字平台，Notion 已经成为热门标签。从少数派到哔哩哔哩，从知乎到小红书，有大量的 Notion 用户每天都在分享自己的 Notion 使用经验。这导致关于 Notion的文章和视频每天都在快速增长。因此，在这篇文章中，我无意于再次班门弄斧地介绍我的 Notion 使用体验。与其他同类产品相比，Notion 除了功能更加强大、更为成熟等特性，围绕 Notion 的社区生态也是 Notion 强大的重要原因。这篇文章，便是将我在 Notion 中文社区以及其他平台所收集、关于 Notion 生态的优质资源加以分享。</p>
<p>[[Notion 优%E8%B4%A8%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB - %E5%B0%91%E6%95%B0%E6%B4%BE/62edfc9bf6597d40617e6fc967e31300.png]]</p>
<p>阅读清单 Database 转化为 Chart</p>
<h2 id="Notion-汉化"><a href="#Notion-汉化" class="headerlink" title="Notion 汉化"></a><strong>Notion 汉化</strong></h2><p>Notion 的中文界面可能是中文区用户呼声最高的功能。然而，由于种种原因，Notion 中文语言界面迟迟没有到来。于是，便有动手能力强的 Notion 用户决定自己解决这个问题。不过好消息是，Notion 的中文界面正在灰度测试，希望早日能发布。如果你在官方正式推出之前中文界面依然想尝试 Notion 汉化版，请参考以下方案：</p>
<p>目前，Notion 汉化方案有两种：</p>
<p><strong>网页版汉化</strong>：具体操作方法是，在 Chrome 或者 Edge 等浏览器中使用油猴插件 Tampermonkey 的 <a href="https://greasyfork.org/zh-CN/scripts/409695-notionenhancer">NotionEnhancer</a> 脚本加以实现。 具体教程参见 <a href="https://github.com/Kur0x/notion-enhancer-tampermonkey">notion-enhancer-tampermonkey</a> 或者 <a href="https://zhuanlan.zhihu.com/p/397634631">notion中文汉化方法·传送门</a>.</p>
<p><strong>客户端汉化</strong>：此方法本质上也是在客户端中增加脚本，开发者貌似和 notion-enhancer 是同一个人。Notion 客户端汉化是由 <a href="https://github.com/Reamd7/notion-zh_CN">notion-zh_CN</a> 提供。目前最新的 2.0 版本同时支持网页端(油猴脚本)+桌面端。 具体教程可以参考 <a href="https://zhuanlan.zhihu.com/p/440773804">Notion中文客户端汉化版教程</a>.</p>
<h2 id="Notion-插件和工具"><a href="#Notion-插件和工具" class="headerlink" title="Notion 插件和工具"></a><strong>Notion 插件和工具</strong></h2><h3 id="Notion-插件"><a href="#Notion-插件" class="headerlink" title="Notion 插件"></a><strong>Notion 插件</strong></h3><p>在少数派作者 @<a href="https://sspai.com/u/a817dgw2/updates">JasperJia</a> 的文章《<a href="https://sspai.com/post/63355">这 5 个第三方工具让 Notion 更好用</a>》这篇文章中，事实上已经介绍了关于 Notion 的几个强大插件，包括 Save to Notion（网页剪裁）、Notion+ Mark Manager（标注文章）、Notion PDF Export（导出笔记）、Snackthis.co（幻灯片播放）、Indify.co（Notion 页面小组件）。另一个少数派作者 @<a href="https://sspai.com/u/chixiang1983/updates">chixiang</a> 则在《<a href="https://sspai.com/post/65736">把 Roam Research 「集成」 到你的 Notion 中</a>》介绍了 <a href="https://www.notion.so/Evergreen-Notes-For-Notion-e35e6ed4dd5a45b19bf2de2bb86b1a7e?pvs=21">Evergreen Notes</a> 这款集引用、页面高亮、悬浮目录、搜索等面板于一身的强大插件。</p>
<p>在此基础上，今天我介绍一些最新出现、关于 Notion 的插件。</p>
<ul>
<li><a href="https://simpread.pro/">简悦</a>：简悦作为一款集收藏、阅读、稍后读、回顾等多种功能于一身的信息管理工具，针对 Notion 用户的需求，定制了两个特色功能。1. 对于 Notion 用户而言，全选 Notion 页面的时候，却无法批量复制页面中的图片，只能将图片逐个下载，再插入到其他平台之中。简悦专门适配 Notion Page，在阅读模式下允许用户直接选中包括所有图片在内的内容，一键复制至目标平台的编辑器。2. 简悦支持一键将完整内容保存至 Notion 页面，比官方的剪藏功能更为强大。并且，简悦增加了 Notion 图床功能，允许用户将 Notion 作为图床工具，为保存至 Notion 的图片生成专有的图床链接，可以解决原文出现 404 的问题。</li>
</ul>
<p>[[Notion 优%E8%B4%A8%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB - %E5%B0%91%E6%95%B0%E6%B4%BE/234db7e3441b375d4ef894aaa1bba660.png]]</p>
<ul>
<li><a href="https://gourav.io/notion-boost">Notion Boost</a> 这是一款十分强大的 Notion 插件，包括悬浮目录、对页面设置/反向链接/图标等元素提供自定义功能。</li>
<li><a href="https://www.producthunt.com/posts/notion-themes">Notion Themes</a> 这是 <a href="https://www.producthunt.com/@yudax/made">Yudax</a>专为 Notion 设计的精美主题，包括十多种白天和黑暗风格等彩色主题。此外，Yudax 正在开发一款十分精美的 Notion Slides 插件，值得期待。</li>
</ul>
<p>[[Notion 优%E8%B4%A8%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB - %E5%B0%91%E6%95%B0%E6%B4%BE/a947bfaafecb8d3c3aa39dbfe0b8ad89.jpeg]]</p>
<h3 id="Notion-Tools"><a href="#Notion-Tools" class="headerlink" title="Notion Tools"></a><strong>Notion Tools</strong></h3><p>在 Notion 插件之外，大量第三方开发者围绕 Notion 开发了不少 Notion 辅助工具，极大丰富了 Notion 的生态体系。举例如下：</p>
<p>[[Notion 优%E8%B4%A8%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB - %E5%B0%91%E6%95%B0%E6%B4%BE/7f96e41d2efa2db4231f2faed958e92e.png]]</p>
<ul>
<li>如果你想要在 Notion 中创建与笔记相关的 Flashcards（抽认卡），那么你可以选择 <a href="https://zorbi.cards/make-flashcards-in-notion/">Zorbi</a>。</li>
</ul>
<p>[[Notion 优%E8%B4%A8%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB - %E5%B0%91%E6%95%B0%E6%B4%BE/2d2cf58363e8a90b0fbaddb7960e774c.png]]</p>
<ul>
<li>如果你想要在你的 Notion 页面添加各种精美的 Widgets，比如天气、进度条、时钟、名言引用，那么强烈推荐你使用 <a href="https://indify.co/">Indify</a> 这个站点。</li>
<li>如果你想要将 Notion 生成更为精美的 PDF，则可以选择 <a href="https://notioninvoice.com/">Notion Invoice</a> 和<a href="https://notionpdf.com/">NotionPDF</a>。</li>
<li>如果你想要使用 Notion 作为演示文稿，则可以选择 <a href="https://snackthis.co/presentations/">Snackthis</a>。</li>
<li>如果你想要将你的 Notion Database 可视化，生成各种精美、优雅、强大的图表，则可以选择 <a href="https://chart-nerd.now.sh/">Chart Nerd</a>、<a href="https://www.notion.vip/charts/">Notion Charts</a>。</li>
<li>如果你想要使用 Notion 进行运营，生成 Notion Forms 可以选择 <a href="https://tally.so/">Tally</a>、<a href="https://notionforms.io/">NotionForms</a>，使用 <a href="https://notionlytics.com/">Notionlytics</a> 分析你的 Notion 页面访客。</li>
</ul>
<p><a href="https://notionlytics.com/">Notionlytics</a></p>
<h3 id="Notion-自动化"><a href="#Notion-自动化" class="headerlink" title="Notion 自动化"></a><strong>Notion 自动化</strong></h3><p>Notion 官方已经提供了 <a href="https://developers.notion.com/">Notion API</a> 可供实现自动化。目前，常用的自动化服务均已经支持 Notion Automation,包括 <a href="https://ifttt.com/">IFTTT</a>、<a href="https://automate.io/">Automate.io</a>、<a href="https://zapier.com/">Zapier</a>、<a href="https://notion2sheets.com/">notion2sheets</a>、<a href="https://www.integromat.com/en/integrations/notion">Integromat</a>、<a href="https://www.thegist.so/">the Gist</a>。利用这三大自动化服务工具，你可以轻松地将 Notion 与谷歌生态、微软生态以及常见的任务管理、阅读工具、网盘等应用连接起来。</p>
<p>除此之外，还有一些第三方的自动化服务工具支持 Notion 生态。</p>
<ul>
<li>Twitter &amp; Notion。比如 <a href="https://heyslideit.com/">slideit</a>— Save Tweets to Notion、<a href="https://www.tressel.xyz/">Tressel</a> | Save tweets &amp; threads to Notion 以及 Obsidian &amp; Evernote 等。</li>
<li><a href="https://telegramtonotion.com/">Telegram to Notion</a>，将你的电报与 Notion 加以连接。</li>
<li>Github，包括 <a href="https://githubnotionsync.com/">同步 GitHub issues 至 Notion</a>。</li>
<li>由于国内软件生态的原因，与 Notion 相关的自动化服务比较少。如果你喜欢豆瓣平台，可以使用 <a href="https://github.com/Qliangw/notion_sync_data">Notion_sync_data</a>，将你的豆瓣书影音数据至 Notion Database。</li>
</ul>
<p>另外，国产轻量级笔记工具 <a href="https://flomoapp.com/feature/">Flomo</a> 则是一款很棒的中继站。通过 Flomo 的 API 服务，你可以轻松地将微信、微博等平台的数据存储至 Flomo，随后再通过 Flomo to Notion 服务，将相关的数据同步至 Notion。</p>
<h3 id="Notion-模板"><a href="#Notion-模板" class="headerlink" title="Notion 模板"></a><strong>Notion</strong> 模板</h3><p>Notion 的强大很大程度上源于 Notion Database, 而为了挖掘 Database 的巨大潜力则又进一步依赖于 Notion 模板。<strong>模板就是生产力。</strong>每一个模板都内含了一定的工作流程。通过标准化的 Notion 模板，加速你的工作效率。</p>
<p>那么，在哪儿获取自己需要的模板呢？Notion 官方内置提供了大量 [[Notion Templates]]。第二个路径便是查看专门的 Notion Templates 汇总站点，比如 [[Notion Pages]]、[[Notionery]]。此外，还有一些 Notion 大使或者 Notion 使用达人用户分享的模板。比如，[[Notion 模板中心]]、[[Notion 实践]] 等。这些模板既有免费版、也有付费版，根据自己需要自取即可。</p>
<p><a href="https://notionpages.com/">Notion Pages</a></p>
<p>模板就是生产力。然而，在使用 Notion 过程中，不要过分沉溺于模板。很多人在接触了兼具美观和强大的 Notion 后，就像发现了新大陆。不少人在使用 Notion 的初期，沉迷于不停地寻找模板、复制模板、修改模板、设计模板。简直就把 Notion 作为新买的房子一样，不停地尝试对 Notion 主页和结构进行「精装修」，从而耗费了大量时间和精力。就像工作流一样，优秀的、符合自己的模板也不是一天能设计出来的。好的模板最好随着自己的使用场景、使用需求而迭代演化升级。<strong>在实践中不断重塑</strong>模板，你会同时收获效率和快乐。</p>
<h3 id="Notion-教程"><a href="#Notion-教程" class="headerlink" title="Notion 教程"></a><strong>Notion 教程</strong></h3><p>在使用 Notion 之前，最好了解 Notion 的产品理念。少数派作者 @<a href="https://sspai.com/u/7v5q81b1/updates">fonter</a> 的《<a href="https://sspai.com/post/61000">Notion 的支撑者</a>》一文详细介绍了影响 Notion 的计算机先锋以及 Notion 员工和投资人介绍。</p>
<p>至于 Notion 教程，你能在少数派、知乎、哔哩哔哩等平台找到大量的精彩教程。如果推荐的话，可以首先查看 Notion 中文社区版主 @Linmi 的<a href="https://linmi.cc/">站点及 Linmi Weekly</a><a href="https://www.notion.so/177-466f3df46024432fabc894c57bb83bb0?pvs=21">。@177</a> 精心制作了大量的视频及文字教程，十分值得参阅。此外，<a href="https://www.notion.so/66ed7807248042d187e1e6e10a404e8d?pvs=21">Notion 主页墙</a> 整理了几十个优秀的 Notion 主页公开分享，也可以作为借鉴。</p>
<p>此外，国外一些活跃的 Notion 创作者或者 Notion 大使多有自己的 Notion NewsLetter，比如著名的 <a href="https://www.redgregory.com/">Red Gregory</a>、<a href="https://potion.so/notion-weekly">Notion Weekly</a>。他们都有高质量的 Notion 内容输出。不过对于我个人而言，订阅他们的 Newsletter 多数是为了获取一些免费的模板。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>Notion 社区所提供的上述优质资源，赋予了 Notion 无尽的超能力，在很大程度上拓展了 Notion 使用场景的上限。当然，每一天都有各种 Notion 优秀的第三方工具或者资源在不断涌现。文章中列出的也只是目之所至的 Notion 优质资源的一小部分。如果有文章没有提及、您感觉不错的 Notion 资源，期待您在评论区中分享，以便让更多的读者和用户受益。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>进一步阅读：我的另外一篇文章《<a href="https://sspai.com/post/71905">关于 Notion-Like 工具的畅想</a>》</li>
</ul>
<p>下面是少数派上一些关于 Notion 使用案例的文章，可进一步参考：</p>
<blockquote>
<p>下载 <a href="https://sspai.com/page/client">少数派 2.0 客户端</a>、关注 <a href="https://sspai.com/s/J71e">少数派公众号</a>，解锁全新阅读体验 📰</p>
</blockquote>
<blockquote>
<p>实用、好用的 <a href="https://sspai.com/mall">正版软件</a>，少数派为你呈现 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
        <tag>#少数派</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion 中如何嵌入 B 站视频？ - Linmi</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Notion%20%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5%20B%20%E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F%20-%20Linmi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Notion-中如何嵌入-B-站视频？-Linmi"><a href="#Notion-中如何嵌入-B-站视频？-Linmi" class="headerlink" title="Notion 中如何嵌入 B 站视频？ - Linmi"></a>Notion 中如何嵌入 B 站视频？ - Linmi</h1><p>Created: October 27, 2021 12:08 PM<br>Tags: #notion<br>URL: <a href="https://linmi.cc/2853.html">https://linmi.cc/2853.html</a><br>author: Linmi</p>
<blockquote>
<p>Hi~ 我是 Linmi，这里是 Notion Tips 栏目，我会每天更新一个 Notion 技巧，帮助小伙伴们更好的使用 Notion ，提高 Notion 使用效率。</p>
</blockquote>
<p>本篇内容涉及点有：内嵌 B 站视频到 Notion 的方法流程，如何开启 B 站内嵌在 Notion 中实现最高画质预览。</p>
<p>本篇是 Notion Tips 的第六篇，本篇技巧写作缘由是来源于 Notion 微信群内的提问。考虑到不少小伙伴有嵌入一些视频或者音频的需求，类似的 Notion 中可以嵌入 YouTube 视频。</p>
<p>B 站又是国内比较大的流媒体网站，所以相应的会有一些需求去嵌入这些流媒体网站的内容到 Notion 上。</p>
<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/YItusFSnBfdMX4r.gif]]</p>
<blockquote>
<p>这里测试网易云音乐不支持嵌入，不过之前我确实内嵌成功过，具体原因我还在测试。</p>
</blockquote>
<p>诡异的是，我通过先内嵌博客，再跳转链接到网易云，是可以打开与播放的。</p>
<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/m5iHQeVnU3ZqJXh.gif]]</p>
<p>回过头来说，个人直接在 Notion 中嵌入B站的链接是生效要么是一个链接 Block、要么是整个网站。</p>
<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/fqVxnOpgDwJAQYu.jpg]]</p>
<p>不过真实情况我们更希望看到直接像 YouTube 显示一个播放器即可，不用显示多余元素，但是粘贴显示又是上面两种情况。</p>
<p>那么有什么办法能够像粘贴 YouTube 到 Notion 一样的展示么？完全可以。</p>
<h2 id="如何在-Notion-中嵌入-B-站视频"><a href="#如何在-Notion-中嵌入-B-站视频" class="headerlink" title="如何在 Notion 中嵌入 B 站视频"></a>如何在 Notion 中嵌入 B 站视频</h2><p>很简单，非常简单。</p>
<h3 id="第一步：打开你要嵌入的-B-站视频"><a href="#第一步：打开你要嵌入的-B-站视频" class="headerlink" title="第一步：打开你要嵌入的 B 站视频"></a>第一步：打开你要嵌入的 B 站视频</h3><p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/JRsbmUnYOcez6da.gif]]</p>
<p>这里我选择《看不见的父爱，其实一直都在》这一部视频。</p>
<h3 id="第二步：点击分享按钮，找到嵌入代码"><a href="#第二步：点击分享按钮，找到嵌入代码" class="headerlink" title="第二步：点击分享按钮，找到嵌入代码"></a>第二步：点击分享按钮，找到嵌入代码</h3><p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/lbmeP9kCaSFWd56.gif]]</p>
<p>我们直接把代码复制出来，得到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=71427557&amp;cid=123765248&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<p>这样代码粘贴到 Notion 中是无效的，我们需要直接一个 URL 即可。类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://linmi.cc/</span><br></pre></td></tr></table></figure>

<p>我们来仔细在之前代码里面找与特征相符的链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//player.bilibili.com/player.html?aid=71427557&amp;cid=123765248&amp;page=1</span><br></pre></td></tr></table></figure>

<p>得到上面这一个 URL，前面加上 https:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://player.bilibili.com/player.html?aid=71427557&amp;cid=123765248&amp;page=1</span><br></pre></td></tr></table></figure>

<p>接下来可以直接粘贴了。</p>
<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/JIHQ4Zs1B9KmVED.gif]]</p>
<p>当然也可以使用命令 <code>/embed</code> 实现内嵌。</p>
<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/Ei3MVTqDsvlYNJh.gif]]</p>
<h3 id="第三步：-1080P-看-B-站视频"><a href="#第三步：-1080P-看-B-站视频" class="headerlink" title="第三步： 1080P 看 B 站视频"></a>第三步： 1080P 看 B 站视频</h3><p>内嵌是内嵌了，但是看起来不高清呀，360P 这画质能闪瞎我的钛合金眼。</p>
<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/5RzI27WUuo9TV4s.jpg]]</p>
<p>哈哈，这里我们需要对上面的链接加上一个参数 <code>&amp;high_quality=1</code>，得到下面这个链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//player.bilibili.com/player.html?aid=71427557&amp;cid=123765248&amp;page=1&amp;high_quality=1</span><br></pre></td></tr></table></figure>

<p>这个参数的意思就是，登录时看内嵌视频就是最大分辨率了。</p>
<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/1cxJ9rKOmDIY2oF.jpg]]</p>
<p>加上后只是 480P，说好的最高分辨率呢？</p>
<p>前面其实已经提到了直接内嵌 B 站整个网站都是可以的，既然可以内嵌整个网站，登录不也就可以？</p>
<p>按照上面的方法内嵌 B 站登录入口链接，粘贴整个链接到 Notion。(注意这样也很危险，容易被盗账号。)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://passport.bilibili.com/login</span><br></pre></td></tr></table></figure>

<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/Zu8IvwThM5VfW9p.gif]]</p>
<p>按照步骤登录即可，最后再打开视频，就是最高画质来播放，放置在 Notion 任何页面都是这样。</p>
<p>[[Notion 中如何嵌入 B %E7%AB%99%E8%A7%86%E9%A2%91%EF%BC%9F - Linmi/tvVYM4qy3PFDQmB.gif]]</p>
<p>大功告成！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你善于发现的话，其实下面的链接就可以实现内嵌 B 站视频。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">player.bilibili.com/player.html?aid=71427557</span><br></pre></td></tr></table></figure>

<p>对比原有的 B 站视频链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/av71427557/</span><br></pre></td></tr></table></figure>

<p>aid= 与 av 后面的数字是一样的，其实只要把 av 后面的数字替换即可。保留好下面这个链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">player.bilibili.com/player.html?aid=填写数字&amp;high_quality=1</span><br></pre></td></tr></table></figure>

<p>需要时候填入 av 后数字即可。</p>
<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>最近同事离职还是比较忙，抽空开始把之前的主题开始梳理写起来，答应中南的稿子也没给到，实在惭愧。</p>
<p>Notion 中文社区：<a href="https://linmi.cc/notiongroup">加入 Notion 中文社区社群</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion 使用技巧(一)：初入 Notion 时不得不知的一些链接 - 少数派</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Notion%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7(%E4%B8%80)%EF%BC%9A%E5%88%9D%E5%85%A5%20Notion%20%E6%97%B6%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E9%93%BE%E6%8E%A5%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Notion-使用技巧-一-：初入-Notion-时不得不知的一些链接-少数派"><a href="#Notion-使用技巧-一-：初入-Notion-时不得不知的一些链接-少数派" class="headerlink" title="Notion 使用技巧(一)：初入 Notion 时不得不知的一些链接 - 少数派"></a>Notion 使用技巧(一)：初入 Notion 时不得不知的一些链接 - 少数派</h1><p>Created: November 3, 2021 3:42 PM<br>Tags: #notion, #少数派<br>URL: <a href="https://sspai.com/post/64498?ivk_sa=1024320u">https://sspai.com/post/64498?ivk_sa=1024320u</a><br>author: UNICK_尤克</p>
<p>在使用 Notion 一年有余以来，将一些心得进行整理。本篇主要整理了在使用 Notion 过程中或许有用的一些链接。希望有所帮助。</p>
<p><a href="Notion%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7(%E4%B8%80)%EF%BC%9A%E5%88%9D%E5%85%A5%20Notion%20%E6%97%B6%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E9%93%BE%E6%8E%A5%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE%202381b528a6f648c0a566be2ddabd52cf/435aa550562181e3480c273506117adc">Notion%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7(%E4%B8%80)%EF%BC%9A%E5%88%9D%E5%85%A5%20Notion%20%E6%97%B6%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E9%93%BE%E6%8E%A5%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE%202381b528a6f648c0a566be2ddabd52cf/435aa550562181e3480c273506117adc</a></p>
<p>来自 Notion 官网图片</p>
<p><strong>看完本篇，大概会了解到</strong>🔖</p>
<ul>
<li>插件：save to notion、notion-enhancer 等</li>
<li>技巧：提升国内访问速度、如何使用 Database 等</li>
<li>社群：Notion 社群、notion-enhancer 社群</li>
</ul>
<h2 id="Notion-官网"><a href="#Notion-官网" class="headerlink" title="Notion 官网"></a><strong>Notion 官网</strong></h2><h2 id="中文社区组织者-Linmi"><a href="#中文社区组织者-Linmi" class="headerlink" title="中文社区组织者 @Linmi"></a><strong>中文社区组织者 @Linmi</strong></h2><h2 id="🍎1。关于插件"><a href="#🍎1。关于插件" class="headerlink" title="🍎1。关于插件"></a><strong>🍎1。关于插件</strong></h2><ul>
<li>来自少数派官网上的一些推荐，让 Notion 使用起来更加顺手。强推 save to notion 这款插件</li>
<li>如果 Notion 原装的功能并不能满足你，或许可以试一试 notion-enhancer ，配置起来也很简单，另外也有社群，可以及时反馈问题</li>
</ul>
<h2 id="🍑2。奇技淫巧"><a href="#🍑2。奇技淫巧" class="headerlink" title="🍑2。奇技淫巧"></a><strong>🍑2。奇技淫巧</strong></h2><ul>
<li>Database（以下简称，db） 不好用？还是在把 db 当简单的表格来用？如下提供了些 Notion 中 db 的玩法，可供参考</li>
<li>Esor（电脑玩物）最近也开始更新【从 Evernote 笔记转移到 Notion 教学】系列，虽然也有关于 Notion 的教学，但是我觉得这一系列可能对于习惯于标签管理和搜索的朋友，更容易初次上手 Notion</li>
<li>关于使用 Notion 来进行管理的技巧，同时包含早期让我入坑的视频</li>
</ul>
<h2 id="🍌3。官方社群"><a href="#🍌3。官方社群" class="headerlink" title="🍌3。官方社群"></a><strong>🍌3。官方社群</strong></h2><h2 id="🍊4。补充几个问题"><a href="#🍊4。补充几个问题" class="headerlink" title="🍊4。补充几个问题"></a><strong>🍊4。补充几个问题</strong></h2><blockquote>
<p>Q：可以白嫖 Pro 计划嘛？</p>
<p>A：使用教育邮箱注册即可，尽情享受无限上传和 30 天历史版本，以及即将到来的 API。如果没有呢/(ㄒoㄒ)/~~🍋 可以通过曲线的方式，加入 Notion 中文社区 workspace ，然后将文件上传至 private 内任一页面，再从 private 转到你想保存的位置即可。（<a href="https://linmi.cc/notiongroup">加入 Notion 中文社区</a>）</p>
</blockquote>
<blockquote>
<p>Q：韩文版本已经发布有一段时间了，那么中文版还会远嘛？</p>
<p>A：很远很远。。。（已经在安排了，见<a href="https://www.yuque.com/icando/blogs/fdvt6r">语雀评论区</a>）</p>
</blockquote>
<blockquote>
<p>Q：Notion 有替代品么？</p>
<p>A：有一大堆，甚至都有借鉴者（这里不讨论）。不过我还是认为，这一类软件本身仅仅只是工具，更重要的是你如何处理信息的方法，因为，一旦有对信息流相应的处理方法，那么在任何软件上都是可以实现的，只不过各个软件复杂程度不同。</p>
</blockquote>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a><strong>版权声明</strong></h2><p>本篇内容遵循「署名-非商业性使用-禁止演绎 3.0 国际」（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">CC BY-NC-ND 3.0</a>）协议。即禁止修改本文内容，禁止商业用途，并且在转载之时，请附上以下链接（必须含有可跳转到本文的超链接）</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
        <tag>#少数派</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 左连接、右连接、全外连接、（+）号作用</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Oracle%20%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E3%80%81%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%EF%BC%88+%EF%BC%89%E5%8F%B7%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle-左连接、右连接、全外连接、（-）号作用"><a href="#Oracle-左连接、右连接、全外连接、（-）号作用" class="headerlink" title="Oracle 左连接、右连接、全外连接、（+）号作用"></a>Oracle 左连接、右连接、全外连接、（+）号作用</h1><p>Created: November 8, 2021 2:26 PM<br>Tags: #Database, #Oracle, #Oracle-JOIN<br>URL: <a href="http://blog.chinaunix.net/uid-21187846-id-3288525.html">http://blog.chinaunix.net/uid-21187846-id-3288525.html</a><br>author: you12323464</p>
<p>Oracle 外连接</p>
<p>（1）左外连接 (左边的表不加限制)<br> （2）右外连接(右边的表不加限制)<br> （3）全外连接(左右两表都不加限制)</p>
<p>外连接(Outer Join)</p>
<p>outer join则会返回每个满足第一个（顶端）输入与第二个（底端）输入的联接的行。它还返回任何在第二个输入中没有匹配行的第一个输入中的行。外连接分为三种： 左外连接，右外连接，全外连接。 对应SQL：LEFT/RIGHT/FULL OUTER JOIN。 通常我们省略outer 这个关键字。 写成：LEFT/RIGHT/FULL JOIN。</p>
<p>在左外连接和右外连接时都会以一张表为基表，该表的内容会全部显示，然后加上两张表匹配的内容。 如果基表的数据在另一张表没有记录。 那么在相关联的结果集行中列显示为空值（NULL）。</p>
<p>对于外连接， 也可以使用“(+) ”来表示。 关于使用（+）的一些注意事项：<br> <strong>1.（+）操作符只能出现在where子句中，并且不能与outer join语法同时使用。<br> 2. 当使用（+）操作符执行外连接时，如果在where子句中包含有多个条件，则必须在所有条件中都包含（+）操作符<br> 3.（+）操作符只适用于列，而不能用在表达式上。<br> 4.（+）操作符不能与or和in操作符一起使用。<br> 5.（+）操作符只能用于实现左外连接和右外连接，而不能用于实现完全外连接。<br> 6.（+）在哪个表，这个表就是匹配表，另一个表是主表.</strong></p>
<p>在做实验之前，我们先将dave表和bl里加一些不同的数据。 以方便测试。</p>
<p>SQL&gt; select * from bl;</p>
<p>ID NAME</p>
<hr>
<p>1 dave</p>
<p>2 bl</p>
<p>3 big bird</p>
<p>4 exc</p>
<p>9 怀宁</p>
<p>SQL&gt; select * from dave;</p>
<p>ID NAME</p>
<hr>
<p>8 安庆</p>
<p>1 dave</p>
<p>2 bl</p>
<p>1 bl</p>
<p>2 dave</p>
<p>3 dba</p>
<p>4 sf-express</p>
<p>5 dmm</p>
<p>2.1 左外连接（Left outer join/ left join）</p>
<p>left join是以左表的记录为基础的,示例中Dave可以看成左表,BL可以看成右表,它的结果集是Dave表中的数据，在加上Dave表和BL表匹配的数据。换句话说,左表(Dave)的记录将会全部表示出来,而右表(BL)只会显示符合搜索条件的记录。BL表记录不足的地方均为NULL.</p>
<p>示例：</p>
<p>SQL&gt; select * from dave a left join bl b on a.id = b.id;</p>
<p>ID NAME ID NAME</p>
<hr>
<p>1 bl 1 dave</p>
<p>1 dave 1 dave</p>
<p>2 dave 2 bl</p>
<p>2 bl 2 bl</p>
<p>3 dba 3 big bird</p>
<p>4 sf-express 4 exc</p>
<p>5 dmm – 此处B表为null，因为没有匹配到</p>
<p>8 安庆 – 此处B表为null，因为没有匹配到</p>
<p>SQL&gt; select * from dave a left outer join bl b on a.id = b.id;</p>
<p>ID NAME ID NAME</p>
<hr>
<p>1 bl 1 dave</p>
<p>1 dave 1 dave</p>
<p>2 dave 2 bl</p>
<p>2 bl 2 bl</p>
<p>3 dba 3 big bird</p>
<p>4 sf-express 4 exc</p>
<p>5 dmm</p>
<p>8 安庆</p>
<p>用（+）来实现， 这个+号可以这样来理解： + 表示补充，即哪个表有加号，这个表就是匹配表。所以加号写在右表，左表就是全部显示，故是左连接。</p>
<p>SQL&gt; Select * from dave a,bl b where a.id=b.id(+); – 注意： 用（+） 就要用关键字where</p>
<p>ID NAME ID NAME</p>
<hr>
<p>1 bl 1 dave</p>
<p>1 dave 1 dave</p>
<p>2 dave 2 bl</p>
<p>2 bl 2 bl</p>
<p>3 dba 3 big bird</p>
<p>4 sf-express 4 exc</p>
<p>5 dmm</p>
<p>8 安庆</p>
<p>2.2 右外连接（right outer join/ right join）</p>
<p>和left join的结果刚好相反,是以右表(BL)为基础的, 显示BL表的所以记录，在加上Dave和BL 匹配的结果。 Dave表不足的地方用NULL填充.</p>
<p>示例：</p>
<p>SQL&gt; select * from dave a right join bl b on a.id = b.id;</p>
<p>ID NAME ID NAME</p>
<hr>
<p>1 dave 1 dave</p>
<p>2 bl 2 bl</p>
<p>1 bl 1 dave</p>
<p>2 dave 2 bl</p>
<p>3 dba 3 big bird</p>
<p>4 sf-express 4 exc</p>
<p>9 怀宁 –此处左表不足用Null 填充</p>
<p>已选择7行。</p>
<p>SQL&gt; select * from dave a right outer join bl b on a.id = b.id;</p>
<p>ID NAME ID NAME</p>
<hr>
<p>1 dave 1 dave</p>
<p>2 bl 2 bl</p>
<p>1 bl 1 dave</p>
<p>2 dave 2 bl</p>
<p>3 dba 3 big bird</p>
<p>4 sf-express 4 exc</p>
<p>9 怀宁 –此处左表不足用Null 填充</p>
<p>已选择7行。</p>
<p>用（+）来实现， 这个+号可以这样来理解： + 表示补充，即哪个表有加号，这个表就是匹配表。所以加号写在左表，右表就是全部显示，故是右连接。</p>
<p>SQL&gt; Select * from dave a,bl b where a.id(+)=b.id;</p>
<p>ID NAME ID NAME</p>
<hr>
<p>1 dave 1 dave</p>
<p>2 bl 2 bl</p>
<p>1 bl 1 dave</p>
<p>2 dave 2 bl</p>
<p>3 dba 3 big bird</p>
<p>4 sf-express 4 exc</p>
<p>9 怀宁</p>
<p>2.3 全外连接（full outer join/ full join）</p>
<p>左表和右表都不做限制，所有的记录都显示，两表不足的地方用null 填充。 全外连接不支持（+）这种写法。</p>
<p>示例：</p>
<p>SQL&gt; select * from dave a full join bl b on a.id = b.id;</p>
<p>ID NAME ID NAME</p>
<hr>
<p>8 安庆</p>
<p>1 dave 1 dave</p>
<p>2 bl 2 bl</p>
<p>1 bl 1 dave</p>
<p>2 dave 2 bl</p>
<p>3 dba 3 big bird</p>
<p>4 sf-express 4 exc</p>
<p>5 dmm</p>
<p>9 怀宁</p>
<p>已选择9行。</p>
<p>SQL&gt; select * from dave a full outer join bl b on a.id = b.id;</p>
<p>ID NAME ID NAME</p>
<hr>
<p>8 安庆</p>
<p>1 dave 1 dave</p>
<p>2 bl 2 bl</p>
<p>1 bl 1 dave</p>
<p>2 dave 2 bl</p>
<p>3 dba 3 big bird</p>
<p>4 sf-express 4 exc</p>
<p>5 dmm</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#Database</tag>
        <tag>#Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle锁表查询和解锁方法_qhzhen的博客-CSDN博客_oracle 锁表</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Oracle%E9%94%81%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%A3%E9%94%81%E6%96%B9%E6%B3%95_qhzhen%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_oracle%20%E9%94%81%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle锁表查询和解锁方法-qhzhen的博客-CSDN博客-oracle-锁表"><a href="#Oracle锁表查询和解锁方法-qhzhen的博客-CSDN博客-oracle-锁表" class="headerlink" title="Oracle锁表查询和解锁方法_qhzhen的博客-CSDN博客_oracle 锁表"></a>Oracle锁表查询和解锁方法_qhzhen的博客-CSDN博客_oracle 锁表</h1><p>Created: November 5, 2021 11:21 AM<br>Tags: #CSDN, #Database, #Oracle<br>URL: <a href="https://blog.csdn.net/qq_38819293/article/details/86526696">https://blog.csdn.net/qq_38819293/article/details/86526696</a></p>
<p>我们这里一般用的PL/SQL,总是无意间把表锁住，所以我今天就整理了一下简单的解锁和查询锁表的方法；</p>
<p>一、首先PL/SQL要以管理员的账号（system/admin等）登录，管理员的账号和密码根据个人设置而来，连接为一般选择Normal,也可选择SYSDBA;</p>
<p>[[Oracle%E9%94%81%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%A3%E9%94%81%E6%96%B9%E6%B3%95_qhzhen%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_oracle %E9%94%81%E8%A1%A8/20190522095931499.png]]</p>
<p>二、相关SQL语句：</p>
<ul>
<li>-查看被锁表信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT sess.sid, sess.serial#, lo.oracle_username, lo.os_user_name, ao.object_name</span><br><span class="line">	, lo.locked_mode</span><br><span class="line">FROM v$locked_object lo, dba_objects ao, v$session sess</span><br><span class="line">WHERE ao.object_id = lo.object_id</span><br><span class="line">	AND lo.session_id = sess.sid</span><br></pre></td></tr></table></figure>

<p>[[Oracle%E9%94%81%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%A3%E9%94%81%E6%96%B9%E6%B3%95_qhzhen%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_oracle %E9%94%81%E8%A1%A8/20190522100503437.png]]</p>
<ul>
<li>-杀掉锁表进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter system kill session &#x27;68,51&#x27;;--分别为SID和SERIAL#号</span><br></pre></td></tr></table></figure>

<ul>
<li>-查看数据库引起锁表的SQL语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.USERNAME,</span><br><span class="line">       A.MACHINE,</span><br><span class="line">       A.PROGRAM,</span><br><span class="line">       A.SID,</span><br><span class="line">       A.SERIAL#,</span><br><span class="line">       A.STATUS,</span><br><span class="line">       C.PIECE,</span><br><span class="line">       C.SQL_TEXT</span><br><span class="line">  <span class="keyword">FROM</span> V$SESSION A, V$SQLTEXT C</span><br><span class="line"> <span class="keyword">WHERE</span> A.SID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> T2.SID</span><br><span class="line">                   <span class="keyword">FROM</span> V$LOCKED_OBJECT T1, V$SESSION T2</span><br><span class="line">                  <span class="keyword">WHERE</span> T1.SESSION_ID <span class="operator">=</span> T2.SID)</span><br><span class="line">   <span class="keyword">AND</span> A.SQL_ADDRESS <span class="operator">=</span> C.ADDRESS(<span class="operator">+</span>)</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> C.PIECE;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#CSDN</tag>
        <tag>#Database</tag>
        <tag>#Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法——left join on 多条件_minixuezhen的博客-CSDN博客</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/SQL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94left%20join%20on%20%E5%A4%9A%E6%9D%A1%E4%BB%B6_minixuezhen%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL语法——left-join-on-多条件-minixuezhen的博客-CSDN博客"><a href="#SQL语法——left-join-on-多条件-minixuezhen的博客-CSDN博客" class="headerlink" title="SQL语法——left join on 多条件_minixuezhen的博客-CSDN博客"></a>SQL语法——left join on 多条件_minixuezhen的博客-CSDN博客</h1><p>Created: November 9, 2021 9:46 AM<br>URL: <a href="https://blog.csdn.net/minixuezhen/article/details/79763263">https://blog.csdn.net/minixuezhen/article/details/79763263</a></p>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><strong>重点</strong></h3><p>先匹配，再筛选where条件。</p>
<p>本文将通过几个例子说明两者的差别。</p>
<p>表1：product</p>
<p>表2：product_details</p>
<h3 id="1-单个条件"><a href="#1-单个条件" class="headerlink" title="1. 单个条件"></a>1. 单个条件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from product a</span><br><span class="line">left join  product_details b</span><br><span class="line">on a.id  = b.id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以左表为准匹配，结果：</p>
<p>[[Untitled Database]]</p>
<h3 id="2-条件写在on-与where区别"><a href="#2-条件写在on-与where区别" class="headerlink" title="2. 条件写在on 与where区别"></a>2. 条件写在on 与where区别</h3><p>查询1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM product LEFT JOIN product_details</span><br><span class="line">ON (product.id = product_details.id)</span><br><span class="line">AND   product.amount=200;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>把on的所有条件作为匹配条件，不符合的右表都为null。<br> 查询2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM product LEFT JOIN product_details</span><br><span class="line">ON (product.id = product_details.id)</span><br><span class="line">WHERE product.amount=200;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>匹配完再筛选，结果只有一条记录。</p>
<h3 id="3-where-XXX-is-null-情况"><a href="#3-where-XXX-is-null-情况" class="headerlink" title="3. where XXX is null 情况"></a>3. where XXX is null 情况</h3><p>使用该语句表示：删除掉不匹配on后面条件的记录。<br> where XXX is not null 则表示筛选出符合on后面条件的记录。<br> 常用于只需要左表的数据，比如count id这类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT a.* FROM product a LEFT JOIN product_details b</span><br><span class="line">ON a.id=b.id AND b.weight!=44 AND b.exist=0</span><br><span class="line">WHERE b.id IS NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>可以直观看出，只有id=2的纪录完全匹配上三个条件，所以筛除这条纪录，另三条保留，此时这三条纪录的右表均为null。<br> 筛选出不符合on后面条件的，即 !(<a href="http://a.id=b.id/">a.id=b.id</a> AND b.weight!=44 AND b.exist=0).<br> !(<a href="http://a.id=b.id/">a.id=b.id</a> AND || !(b.weight!=44) || !(b.exist=0).<br> (<a href="http://a.id/">a.id</a> != <a href="http://b.id/">b.id</a> AND || (b.weight = 44) || ( b.exist! = 0).<br> 逻辑 AND 和 逻辑 OR表达式，其操作数是从左到右求值的。如果第一个参数做够判断操作结果，那么第二个参数便不会被计算求值（短路效果）。</p>
<p>下面语句与该语句效果相同：（这里相同指的是最后只用到左表数据，若是将右表数据写出来是不一样的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT a.* FROM product a LEFT JOIN product_details b</span><br><span class="line">ON a.id=b.id</span><br><span class="line">WHERE b.id is null OR b.weight=44 OR b.exist=1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将on的否定条件写在where后，效果相同。</p>
<p>注：<br> 如果你使用 LEFT JOIN 来寻找在一些表中不存在的记录，你需要做下面的测试：WHERE 部分的 col_name IS NULL，MYSQL 在查询到一条匹配 LEFT JOIN 条件后将停止搜索更多行（在一个特定的组合键下）。</p>
<p>参考：<a href="https://blog.csdn.net/czhphp/article/details/18657341">https://blog.csdn.net/czhphp/article/details/18657341</a></p>
<p>有时我们不仅需要用一个字段去关联，还希望两个表的两个字段都是一样的，这时候可以这样写<br> select * from(<br> select id,name,code from table1<br> ) a<br> left join<br> (<br> select id,name,code from table2<br> ) b<br> on a.id = b.id and a.code = b.code<br> 有时候on出错的话，可以用cast<br> on cast(a.id as varchar(40)) = cast(b.id as varchar(40))<br> and cast(a.code as varchar(40)) = cast(b.code as varchar(40))</p>
<p>inner join right join 亦然~</p>
<p>你学废了吗</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud 微服务实现数据权限控制 - 简书</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/SpringCloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%20-%20%E7%AE%80%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringCloud-微服务实现数据权限控制-简书"><a href="#SpringCloud-微服务实现数据权限控制-简书" class="headerlink" title="SpringCloud 微服务实现数据权限控制 - 简书"></a>SpringCloud 微服务实现数据权限控制 - 简书</h1><p>Created: December 15, 2021 8:54 AM<br>Tags: #SpringCloud, #微服务<br>URL: <a href="https://www.jianshu.com/p/ea3540202e43">https://www.jianshu.com/p/ea3540202e43</a><br>author:<br>barry的异想世界</p>
<p>[[https//upload-images.jianshu.io/upload_images/3242982-cd150e401635a676.png]]</p>
<hr>
<p><a href="SpringCloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%20-%20%E7%AE%80%E4%B9%A6%202a27e5df01fa4e129d425410c94b5371/ea3540202e43">ea3540202e43</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#SpringCloud</tag>
        <tag>#微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity - YouTube</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Unity%20-%20YouTube/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Unity-YouTube"><a href="#Unity-YouTube" class="headerlink" title="Unity - YouTube"></a>Unity - YouTube</h1><p>Created: November 5, 2021 9:31 PM<br>Tags: #Unity, #Youtube<br>URL: <a href="https://www.youtube.com/user/Unity3D">https://www.youtube.com/user/Unity3D</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#Youtube</tag>
        <tag>#Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity - Manual Unity User Manual 2020.3 (LTS)</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Unity%20-%20Manual%20Unity%20User%20Manual%202020.3%20(LTS)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Unity-Manual-Unity-User-Manual-2020-3-LTS"><a href="#Unity-Manual-Unity-User-Manual-2020-3-LTS" class="headerlink" title="Unity - Manual: Unity User Manual 2020.3 (LTS)"></a>Unity - Manual: Unity User Manual 2020.3 (LTS)</h1><p>Created: November 5, 2021 9:30 PM<br>Tags: #Unity, #Unity User Manual<br>URL: <a href="https://docs.unity3d.com/Manual/UnityManual.html?_ga=2.126209103.354687184.1636113956-429140652.1635762900">https://docs.unity3d.com/Manual/UnityManual.html?_ga=2.126209103.354687184.1636113956-429140652.1635762900</a></p>
<p>Use the Unity Editor to create 2D and 3D games, apps and experiences. Download the Editor at <a href="https://store.unity.com/">unity.com</a>.</p>
<p>The Unity User Manual helps you learn how to use the Unity Editor and its associated services. You can read it from start to finish, or use it as a reference.</p>
<p>If it’s your first time using Unity, take a look at the introductory documentation on <a href="https://docs.unity3d.com/Manual/UnityOverview.html">Working with Unity</a>, and see <a href="https://unity.com/learn">Unity Learn</a>.</p>
<h3 id="Unity-User-Manual-sections"><a href="#Unity-User-Manual-sections" class="headerlink" title="Unity User Manual sections"></a>Unity User Manual sections</h3><p>[[Unity - Manual Unity User Manual 2020 3 (LTS]]%20dcc15b9f6ec940e8bcf411d221d6c77e/StructEditor.jpg)</p>
<p>[[Unity - Manual Unity User Manual 2020 3 (LTS]]%20dcc15b9f6ec940e8bcf411d221d6c77e/struct2d.jpg)</p>
<h3 id="Further-sources-of-information"><a href="#Further-sources-of-information" class="headerlink" title="Further sources of information"></a>Further sources of information</h3><ul>
<li><a href="https://answers.unity3d.com/">Unity Answers</a> or <a href="https://forum.unity3d.com/">Unity Forums</a> - here you can ask questions and search answers.</li>
<li><a href="https://support.unity3d.com/">The Unity Knowledge Base</a> - a collection of answers to questions posed to Unity’s Support teams.</li>
<li><a href="https://unity.com/learn">Unity Learn</a> - step by step video and written guides to using the Unity Editor.</li>
<li><a href="https://unityads.unity3d.com/help/index">Unity Ads Knowledge Base</a> - a guide to including ads in your game.</li>
</ul>
<h3 id="Known-issues"><a href="#Known-issues" class="headerlink" title="Known issues"></a>Known issues</h3><p>Is a feature not working as you expect it to? It might be an existing Known Issue. Please check using the <strong>Issue Tracker</strong> at <a href="https://issuetracker.unity3d.com/">issuetracker.unity3d.com</a>.</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity AdditionPlugin</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Unity%20AdditionPlugin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Unity-Addition-Plugin"><a href="#Unity-Addition-Plugin" class="headerlink" title="Unity Addition/Plugin"></a>Unity Addition/Plugin</h1><p>Created: November 9, 2021 11:13 PM<br>Tags: #Unity, #Unity Plugin</p>
<p>[[ProGrids]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs 实践：express 最佳实践 (一) 项目结构 - htoooth - 博客园</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/nodejs%20%E5%AE%9E%E8%B7%B5%EF%BC%9Aexpress%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%20(%E4%B8%80)%20%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%20-%20htoooth%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="nodejs-实践：express-最佳实践-一-项目结构-htoooth-博客园"><a href="#nodejs-实践：express-最佳实践-一-项目结构-htoooth-博客园" class="headerlink" title="nodejs 实践：express 最佳实践 (一) 项目结构 - htoooth - 博客园"></a>nodejs 实践：express 最佳实践 (一) 项目结构 - htoooth - 博客园</h1><p>Created: December 1, 2021 3:12 PM<br>URL: <a href="https://www.cnblogs.com/htoooth/p/7181864.html">https://www.cnblogs.com/htoooth/p/7181864.html</a></p>
<p>第二篇: <a href="http://www.cnblogs.com/htoooth/p/7240135.html">express 最佳实践(二)：中间件</a></p>
<p>最近，一直在使用 nodejs 做项目，对 nodejs 开发可以说深有体会。</p>
<p>先说说 nodejs 在业务中的脚色，, 在 <code>web同构</code> 方面， nodejs 的优势相对于其他语言来说，可以说非常巨大，基本上算是只有 nodejs 能做，其他语言根本不能做。在<code>传统 web 开发</code>方面，nodejs（必竟时间太短了）的相对于其他语言来说的劣势，已经不是太明显了。</p>
<p>再来说说自己，算了算差不多做了 5 个项目，都是使用 express 做为项目的基础框架，然后再上面进行业务开发工作，一个路由下来，平均 10 个左右的中间件，执行效率都是不错的，开发效率也非常好，是时候总结一下 express 实践经验，同时结合配套自己的想法，来看看理想中 express 项目应该是怎样的规划，以及我是怎么想的。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>做一个项目的规划，首先要为项目订一个基调，就是项目架构是应该怎样设计，怎样考虑的，对业务开发是否方便，部署是否方便等要素。</p>
<p>我现在认为一个项目最重要的规划是：<code>核心+插件式开发</code>。一个项目一定要支持这两点，如果不支持这个项目就很难做下去，为什么我这样说。因为现在的任何一个项目都不可能是一个人开发，一定是多人分工开发，如果你的项目支持 <code>核心+插件式开发</code>，你就可以把核心的基础功能如：网络，日志，基础布局等功能，找个高级工程师来完成；业务开发，就可以分给一些初级工程师，并行完成，同时在做项目的时候对代码码进行审查，及时调整坏代码。这样项目，能保证进度，也能保证项目质量，不会大烂，同时人力也得到了充分利用。</p>
<p>这种思想落实到架构上，就是从项目的文件组织结构上考虑怎样达到这样的目标。</p>
<p>我是这样规划文件目录的：</p>
<h3 id="按业务特性而不按分层进行规划"><a href="#按业务特性而不按分层进行规划" class="headerlink" title="按业务特性而不按分层进行规划"></a>按业务特性而不按分层进行规划</h3><p>分层最典型的代表就是<code>ruby on rails</code>，app 目录下，就是 controllers, models等目录，当然我不是说，这种规划不好，只是到项目大到一定程度，你想找某个 controller 下的一个方法，就会很麻烦，不知道没有这种体验，在几十个文件中找某个方法是怎样的感觉，搜索也是全文搜索，不能限定到某个目录下面。因此在这个项目规划中，以业务特征为插件名，在 express 中，也就是 subExpress，如果，我有一个购物车的业务，那于购物车相关的所有的项目都规在 <code>passport</code> 这个子应用下了，这样相关的业务在一起，方便查找，同时也方便理解和修改。当然这种规划方式也有不方便的地方，如果想跨 subApplication 调用方法，就没有那么方便。</p>
<h3 id="边界显式说明"><a href="#边界显式说明" class="headerlink" title="边界显式说明"></a>边界显式说明</h3><p>这个跟传统的 controller, service , model 没有什么区别。还是刚才的 passport 应用，按分层进行划分，包括 controllers, services, models, views, index.js, router.js。需要说明一下，在项目中我们一再强调， controllers 中负责与 http 的连接工作，只做简单参数的验证，传参和调起 services ，禁止把 rep, res 对像做为参数传递到 services 层；services 层纯业务，没有与 http 相关的任何东西，需要数据请调用 models 中的方法；models 只于数据打交到，其它都不管。这样做的好处是什么呢？ 想想看，如果相把一个页面的数据拿出来做接口，只需要简单几行就搞定了，还有如果要把框架改成 koa ，你的业务都不用重写，还有你想增加 websocket 的支持，直接在 controllers 进行调整就行了。 models的作用更明显，原来的项目是一个普通是 web 项目，models 是连接数据库的，现在技术升级要前后端分离，不用数据库了，改成调用后端的接口了，你就只用把 models 用接口实现一遍，其他不用变了。 controllers 和 models 就是你业务的边界，service 则是你业务的核心，边界实现的改变不应该影响你业务。</p>
<h3 id="落实"><a href="#落实" class="headerlink" title="落实"></a>落实</h3><p>思想利用 express 的中间件思想，达到我的架构意图，如下图所示：</p>
<p>图中，蓝色的部分代表业务中间件，橙黄色代表 核心中间件。在一个网站项目中核心中间件，应该包括 limiter 限流操作，这个中间件主要是防止爬虫；htaccess 改写 url，这个中间件主要用，改写网站url， 为什么要改呢？因为一但网站线上运行时，路由的规则不应发生变化，但是有时候 seo 的时候，你需要兼容新老 url 的时候，这个中间件就会非常有用，网站的业务都不用变，只用在新url 到达时，变成老的再进行处理就行了；dispatch 不是一个中间件，它的思想是用来整合各个业务线的 subApplication 和主 application 的关系的；auth 鉴权，有些页面和接口需要有用户登录，如果没有用户登录，就需要跳转到登录页面，登录完成后跳回来；clientError 和 serverError 是对错误进行统一的处理，统一显示 404 , 如果是接口的话也会统一 404 的返回码。</p>
<p>业务端在开发时只需要在 dispatch 的地方加入自已的模块，然后就可以开始写自己的业务，不用但心自己的文件被别人改动。</p>
<p>下面是项目的文件夹规划：</p>
<p>简单说明下：</p>
<p>apps 目录下就写各自的业务逻辑，用 dispatch 把 主app 与 业务 连接起来，实现起来也挺简单的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = (app) =&gt; &#123;</span><br><span class="line">  app.use(&#x27;/passport&#x27;, require(&#x27;./apps/passport&#x27;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有 shared 的存在，是为了解决前后端模板公用的问题。</p>
<p>与业务没有关系的代码可以，移到到 modules 中使用。</p>
<p>如果个业务的之间需要共享部分代码，就放到 utils 中，这个文件夹就是用来干这种事的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个项目中规划就是，怎样使用 express 最好，另外再加上自己的一些思考，现在项目的结构出来了，后面会再讨论一些有关中间件的处理方法。</p>
<p>该项目的 <a href="https://github.com/htoooth/express-boilerplate">github</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
  </entry>
  <entry>
    <title>Welcome to Unity  Unity Blog</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Welcome%20to%20Unity%20%20Unity%20Blog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Welcome-to-Unity-Unity-Blog"><a href="#Welcome-to-Unity-Unity-Blog" class="headerlink" title="Welcome to Unity | Unity Blog"></a>Welcome to Unity | Unity Blog</h1><p>Created: November 5, 2021 9:31 PM<br>Tags: #Unity, #Unity Blog<br>URL: <a href="https://blog.unity.com/?_ga=2.158262520.354687184.1636113956-429140652.1635762900">https://blog.unity.com/?_ga=2.158262520.354687184.1636113956-429140652.1635762900</a></p>
<p>[[Welcome to Unity Unity Blog/unity_genart_0.jpeg.jpg]]</p>
<p>We have spent the last six months building new key functionality that addresses the three key pillars of quality, productivity, and performance in the 2021.2 Tech Stream release, which is available for download as of today.</p>
<p>The 2021.1 release from Pixyz, now part of Unity, includes two new products: Pixyz Scenario Processor, which enables the creation of on-premises or cloud-based automated, scalable 3D content optimization pipelines; and Pixyz Loader, which loads prepared assets directly in the Uni…</p>
<p>The #unitytips Dev Takeover is an ongoing series on our @unitygames Twitter account. The Unity team invites super users from our community to share their insights, tips, and tricks directly with our followers. We’re kicking things off with Harry Alisavakis, tech artist at Jumpshi…</p>
<p>If you’re a regular reader of the Unity blog then you probably noticed the recent series of posts that shared many great tips for optimizing mobile games, including graphics and assets, profiling, memory, and code architecture, and physics, UI, and audio.</p>
<p>Developed by Zoink and published by Electronic Arts, Lost in Random is a gothic fairytale-inspired action adventure where every citizen’s fate is determined by the roll of a dice. Released back in September to rave reviews across multiple platforms, the game features a unique ble…</p>
<p>The 2020 LTS is made for creators like you who prioritize greater stability and support when teamwork is underway. In this release, we’ve made several optimizations to speed up workflows for designers, more specifically. These include new capabilities for editing Prefabs in the c…</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#Unity</tag>
        <tag>#unitytips</tag>
      </tags>
  </entry>
  <entry>
    <title>quartz (一) 任务Job - 知乎</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/quartz%20(%E4%B8%80)%20%E4%BB%BB%E5%8A%A1Job%20-%20%E7%9F%A5%E4%B9%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="quartz-一-任务Job-知乎"><a href="#quartz-一-任务Job-知乎" class="headerlink" title="quartz (一) 任务Job - 知乎"></a>quartz (一) 任务Job - 知乎</h1><p>Created: May 18, 2022 3:05 PM<br>Tags: #Java, #quartz<br>URL: <a href="https://zhuanlan.zhihu.com/p/474954816">https://zhuanlan.zhihu.com/p/474954816</a></p>
<h3 id="1-Quartz概念"><a href="#1-Quartz概念" class="headerlink" title="1 Quartz概念"></a>1 Quartz概念</h3><p>quartz就是基于java实现的任务调度框架，用于执行你想要执行的任何任务。</p>
<h3 id="2-核心概念-重要"><a href="#2-核心概念-重要" class="headerlink" title="2 核心概念 重要"></a>2 核心概念 重要</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务Job</span><br><span class="line">Job就是你想要实现的任务类，每一个Job必须实现org.quartz.job接口，且只需实现接口定义的execute()方法。</span><br><span class="line"></span><br><span class="line">触发器Trigger</span><br><span class="line">Trigger为你执行任务的触发器，比如你想每天定时3点发送一份统计邮件，Trigger将会设置3点进行执行该任务。Trigger主要包含两种SimpleTrigger和CronTrigger。</span><br><span class="line"></span><br><span class="line">调度器Scheduler</span><br><span class="line">Scheduler为任务的调度器，它会将任务job及触发器Trigger整合起来，负责基于Trigger设定的时间来执行Job。</span><br></pre></td></tr></table></figure>

<p>3 <strong>Quartz的体系结构 重要</strong></p>
<p>[[quartz (一]]%20%E4%BB%BB%E5%8A%A1Job%20-%20%E7%9F%A5%E4%B9%8E%20c485bdfca5f740a4bb3967064b5c45a5/v2-31c7f5abbb115e425b0b2fbe6df5c36d_720w.jpg)</p>
<h2 id="4-组件API"><a href="#4-组件API" class="headerlink" title="4 组件API"></a>4 组件API</h2><ul>
<li>Scheduler 用于与调度程序交互的主程序接口。 Scheduler 调度程序-任务执行计划表，只有安排进执行计划的任务Job（通过scheduler.scheduleJob方法安排进执行计划），当它预先定义的执行时间到了的时候（任务触发trigger），该任务才会执行。</li>
<li>Job 我们预先定义的希望在未来时间能被调度程序执行的任务类，我们可以自定义。</li>
<li>JobDetail 使用JobDetail来定义定时任务的实例，JobDetail实例是通过JobBuilder类创建的。</li>
<li>JobDataMap 可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用 其中的数据；JobDataMap是Java Map接口的一个实现，额外增加了一些便于存取基本类型的数 据的方法。</li>
<li>JobBuilder -用于声明一个任务实例，也可以定义关于该任务的详情比如任务名、组名等，这个声明的实例将会作为一个实际执行的任务。</li>
<li>Trigger 触发器，Trigger对象是用来触发执行Job的。当调度一个job时，我们实例一个触发器然后调整它的属性来满足job执行的条件。表明任务在什么时候会执行。定义了一个已经被安排的任务将会在什么时候执行的时间条件，比如每2秒就执行一次。</li>
<li>TriggerBuilder 触发器创建器，用于创建触发器trigger实例。</li>
<li>JobListener、TriggerListener、SchedulerListener监听器，用于对组件的监听。</li>
</ul>
<p>5 jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;quartz&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>6 代码示例</p>
<p>任务类HelloJob</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义任务类</span><br><span class="line">public class HelloJob implements Job &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">		// 定义时间</span><br><span class="line">		Date date = new Date();</span><br><span class="line">		SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">		String dateString = dateFormat.format(date);</span><br><span class="line">		// 定义工作任务内容</span><br><span class="line">		System.out.println(&quot;当前任务执行的时间：&quot;+dateString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务调度类HelloSchedulerDemo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloSchedulerDemo &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">	// 1：从工厂中获取任务调度的实例</span><br><span class="line">        Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        // 2：定义一个任务调度实例，将该实例与HelloJob绑定，任务类需要实现Job接口</span><br><span class="line">        JobDetail job = JobBuilder.newJob(HelloJob.class)</span><br><span class="line">                .withIdentity(&quot;job1&quot;, &quot;group1&quot;) // 定义该实例唯一标识</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        // 3：定义触发器 ，马上执行, 然后每5秒重复执行一次</span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) // 定义该实例唯一标识</span><br><span class="line">                .startNow()  // 马上执行</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">        .repeatSecondlyForever(5)) // 每5秒执行一次</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        // 4：使用触发器调度任务的执行</span><br><span class="line">        scheduler.scheduleJob(job, trigger);</span><br><span class="line"></span><br><span class="line">        // 5：开启</span><br><span class="line">        scheduler.start();</span><br><span class="line">        // 关闭</span><br><span class="line">        // scheduler.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-Job和JobDetail介绍"><a href="#6-2-Job和JobDetail介绍" class="headerlink" title="6.2 Job和JobDetail介绍"></a>6.2 Job和JobDetail介绍</h3><ul>
<li>Job：工作任务调度的接口，任务类需要实现该接口。该接口中定义execute方法，类似JDK提供的TimeTask类的run方法。在里面编写任务执行的业务逻辑。</li>
<li>Job实例在Quartz中的生命周期：每次调度器执行Job时，它在调用execute方法前会创建一个新的Job实例，当调用完成后，关联的Job对象实例会被释放，释放的实例会被垃圾回收机制回收。</li>
<li>JobDetail：JobDetail为Job实例提供了许多设置属性，以及JobDetaMap成员变量属性，它用来存储特定Job实例的状态信息，调度器需要借助JobDetail对象来添加Job实例。</li>
<li>JobDetail重要属性：name、group、jobClass、jobDataMap</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JobDetail job = JobBuilder.newJob(HelloJob.class)</span><br><span class="line">        .withIdentity(&quot;job1&quot;, &quot;group1&quot;) // 定义该实例唯一标识，并指定一个组。</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;name:&quot;+job.getKey().getName());</span><br><span class="line">System.out.println(&quot;group:&quot;+job.getKey().getGroup());</span><br><span class="line">System.out.println(&quot;jobClass:&quot;+job.getJobClass().getName());</span><br></pre></td></tr></table></figure>

<h3 id="6-3-JobExecutionContext介绍"><a href="#6-3-JobExecutionContext介绍" class="headerlink" title="6.3 .JobExecutionContext介绍"></a>6.3 .JobExecutionContext介绍</h3><ul>
<li>当Scheduler调用一个Job，就会将JobExecutionContext传递给Job的execute()方法；</li>
<li>Job能通过JobExecutionContext对象访问到Quartz运行时候的环境以及Job本身的明细数据。</li>
</ul>
<h3 id="6-4-JobDataMap介绍"><a href="#6-4-JobDataMap介绍" class="headerlink" title="6.4 .JobDataMap介绍"></a>6.4 .JobDataMap介绍</h3><p>（1）使用Map获取。</p>
<ul>
<li>在进行任务调度时，JobDataMap存储在JobExecutionContext中 ，非常方便获取。</li>
<li>JobDataMap可以用来装载任何可序列化的数据对象，当job实例对象被执行时这些参数对象会传递给它。</li>
<li>JobDataMap实现了JDK的Map接口，并且添加了非常方便的方法用来存取基本数据类型。</li>
</ul>
<p>调度器类HelloSchedulerDemo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2：定义一个任务调度实例，将该实例与HelloJob绑定，任务类需要实现Job接口</span><br><span class="line">    JobDetail job = JobBuilder.newJob(HelloJob.class)</span><br><span class="line">    		.withIdentity(&quot;job1&quot;, &quot;group1&quot;) // 定义该实例唯一标识</span><br><span class="line">    		.usingJobData(&quot;message&quot;, &quot;打印日志&quot;) //把map类型数据传递给任务类</span><br><span class="line">    		.build();</span><br><span class="line"></span><br><span class="line">    // 3：定义触发器 ，马上执行, 然后每5秒重复执行一次</span><br><span class="line">    Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">    		.withIdentity(&quot;trigger1&quot;, &quot;group1&quot;) // 定义该实例唯一标识</span><br><span class="line">    		.startNow()  // 马上执行</span><br><span class="line">    		//.startAt(triggerStartTime) // 针对某个时刻执行</span><br><span class="line">    		.withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                .repeatSecondlyForever(5)) // 每5秒执行一次</span><br><span class="line">    		.usingJobData(&quot;message&quot;, &quot;simple触发器&quot;)////把map类型数据传递给任务类</span><br><span class="line">    		.build();</span><br></pre></td></tr></table></figure>

<p>任务类HelloJob execute方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JobKey jobKey = context.getJobDetail().getKey();</span><br><span class="line">System.out.println(&quot;工作任务名称：&quot;+jobKey.getName()+&quot;;工作任务组：&quot;+jobKey.getGroup());</span><br><span class="line">System.out.println(&quot;任务类名称（带包名）：&quot;+context.getJobDetail().getJobClass().getName());</span><br><span class="line">System.out.println(&quot;任务类名称：&quot;+context.getJobDetail().getJobClass().getSimpleName());</span><br><span class="line">System.out.println(&quot;当前任务执行时间：&quot;+context.getFireTime());</span><br><span class="line">System.out.println(&quot;下一任务执行时间：&quot;+context.getNextFireTime());</span><br><span class="line"></span><br><span class="line">TriggerKey triggerKey = context.getTrigger().getKey();</span><br><span class="line">System.out.println(&quot;触发器名称：&quot;+triggerKey.getName()+&quot;;触发器组：&quot;+triggerKey.getGroup());</span><br><span class="line"></span><br><span class="line">//从调度器创建job中取数据</span><br><span class="line">JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();</span><br><span class="line">String jobMessage = jobDataMap.getString(&quot;message&quot;);</span><br><span class="line">System.out.println(&quot;任务参数消息值：&quot;+jobMessage);</span><br><span class="line"></span><br><span class="line">//从调度器创建trigger中取数据</span><br><span class="line">JobDataMap triggerDataMap = context.getTrigger().getJobDataMap();</span><br><span class="line">String triggerMessage = triggerDataMap.getString(&quot;message&quot;);</span><br><span class="line">System.out.println(&quot;触发器参数消息值：&quot;+triggerMessage);</span><br></pre></td></tr></table></figure>

<h3 id="6-5-Job实现类中添加setter方法对应JobDataMap的键值，Quartz框架默认的JobFactory实现类在初始化job实例对象时会自动地调用这些setter方法。"><a href="#6-5-Job实现类中添加setter方法对应JobDataMap的键值，Quartz框架默认的JobFactory实现类在初始化job实例对象时会自动地调用这些setter方法。" class="headerlink" title="6.5 Job实现类中添加setter方法对应JobDataMap的键值，Quartz框架默认的JobFactory实现类在初始化job实例对象时会自动地调用这些setter方法。"></a>6.5 Job实现类中添加setter方法对应JobDataMap的键值，Quartz框架默认的JobFactory实现类在初始化job实例对象时会自动地调用这些setter方法。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String message;</span><br><span class="line">public void setMessage(String message) &#123;</span><br><span class="line">	this.message = message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：如果遇到同名的key，Trigger中的.usingJobData(“message”, “simple触发器”)会覆盖JobDetail中的.usingJobData(“message”, “打印日志”)。</p>
<h3 id="6-6-有状态的Job和无状态的Job"><a href="#6-6-有状态的Job和无状态的Job" class="headerlink" title="6.6 有状态的Job和无状态的Job"></a>6.6 有状态的Job和无状态的Job</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PersistJobDataAfterExecution注解的使用</span><br><span class="line"></span><br><span class="line">有状态的Job可以理解为多次Job调用期间可以持有一些状态信息，这些状态信息存储在JobDataMap中，而默认的无状态job每次调用时都会创建一个新的JobDataMap。</span><br></pre></td></tr></table></figure>

<p>调度器类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JobDetail job = JobBuilder.newJob(HelloJob.class)</span><br><span class="line">    		.withIdentity(&quot;job1&quot;, &quot;group1&quot;) // 定义该实例唯一标识</span><br><span class="line">    		.usingJobData(&quot;message&quot;, &quot;打印日志&quot;)</span><br><span class="line">    		.usingJobData(&quot;count&quot;, 0)//添加，表示计数器，用来区别注解使用</span><br><span class="line">    		.build();</span><br></pre></td></tr></table></figure>

<p>任务类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Integer count;</span><br><span class="line">public void setCount(Integer count) &#123;</span><br><span class="line">	this.count = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务类 execute方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">++count;</span><br><span class="line">System.out.println(&quot;count数量：&quot;+count);</span><br><span class="line">context.getJobDetail().getJobDataMap().put(&quot;count&quot;, count);</span><br></pre></td></tr></table></figure>

<p>任务类没有添加@PersistJobDataAfterExecution注解，每次调用时都会创建一个新的JobDataMap。不会累加；</p>
<p>任务类添加@PersistJobDataAfterExecution注解，多次Job调用期间可以持有一些状态信息，即可以实现count的累加。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#Java</tag>
        <tag>#quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Learners - Unity Connect</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Unity%20Learners%20-%20Unity%20Connect/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Unity-Learners-Unity-Connect"><a href="#Unity-Learners-Unity-Connect" class="headerlink" title="Unity Learners - Unity Connect"></a>Unity Learners - Unity Connect</h1><p>Created: November 5, 2021 9:29 PM<br>Tags: #Unity, #Unity Learners<br>URL: <a href="https://learn.unity.com/g/unity-learners">https://learn.unity.com/g/unity-learners</a></p>
<p><a href="Unity%20Learners%20-%20Unity%20Connect%2021b81739a54a4e0fb856e86748491250/d7a7e3b2-d6f9-4f97-888b-c023741dcfcf">Unity%20Learners%20-%20Unity%20Connect%2021b81739a54a4e0fb856e86748491250/d7a7e3b2-d6f9-4f97-888b-c023741dcfcf</a></p>
<p>Hello, I created a microgame and published it via WebGL at <a href="https://learn.unity.com/">https://learn.unity.com/</a>. It was saved fine.</p>
<p>When I pushed ‘Play’ the error was showed: The first play through is recorded to add a preview of the game (90%). It lasted for 30 minutes. I refreshed the page, did a publishing again, restart my computer, but still the error is here so I can’t (and nobody can) play the game.</p>
<p>[[Unity Learners - Unity Connect/77609330-277f-4bf7-903e-9362d8941d48_error.png]]</p>
<p>[[Unity Learners - Unity Connect/d37ec8cb-05f3-4fbe-9a6d-009e81a970d1_1.png]]</p>
<p>[[Unity Learners - Unity Connect/f1b8608c-b0f1-4a7b-8e41-ea2b36b0aaa0_2.png]]</p>
<p><a href="https://learn.unity.com/tutorial/lesson-2-1-control-player-bounds-with-if-then-statements/?courseId=5cf96c41edbc2a2ca6e8810f&amp;projectId=5cdcc312edbc2a24a41671e6&amp;tab=overview&amp;uv=2020.3">https://learn.unity.com/tutorial/lesson-2-1-control-player-bounds-with-if-then-statements/?courseId=5cf96c41edbc2a2ca6e8810f&amp;projectId=5cdcc312edbc2a24a41671e6&amp;tab=overview&amp;uv=2020.3</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>剪裁网页增强、标注文章、笔记导出…… 这 5 个第三方工具让 Notion 更好用</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/%E5%89%AA%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%20%E8%BF%99%205%20%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9%20Notion%20%E6%9B%B4%E5%A5%BD%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剪裁网页增强、标注文章、笔记导出……-这-5-个第三方工具让-Notion-更好用"><a href="#剪裁网页增强、标注文章、笔记导出……-这-5-个第三方工具让-Notion-更好用" class="headerlink" title="剪裁网页增强、标注文章、笔记导出…… 这 5 个第三方工具让 Notion 更好用"></a>剪裁网页增强、标注文章、笔记导出…… 这 5 个第三方工具让 Notion 更好用</h1><p>Created: December 13, 2021 4:42 PM</p>
<blockquote>
<p>随着使用人数增加，Notion 的第三方工具也如雨后春笋般冒出来。本篇文章基于作者的使用经历，为大家收集了 5 款关于 Notion 的第三方小工具。</p>
</blockquote>
<h3 id="Matrix-精选"><a href="#Matrix-精选" class="headerlink" title="Matrix 精选"></a><strong>Matrix 精选</strong></h3><p><a href="https://sspai.com/matrix">Matrix</a> 是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。</p>
<p>文章代表作者个人观点，少数派仅对标题和排版略作修改。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>[[Notion]] 是一款非常优秀的数字化生产力工具，在任务管理，知识整合方面都能提供易于使用和高效的体验。丰富的模板，干净的用户体验以及优秀的社区，越来越多人爱上这「第二个大脑」（Second brain）。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/4c9bc22d-a14c-4108-9a5f-ffc43f69831e.png]]</p>
<p>Notion 作为信息收集处理的「第二大脑」（Credit：Tiago Forte）</p>
<p>随着使用人数的增加，Notion 相关的第三方工具也如雨后春笋般迅速地冒出来。本篇文章基于我个人的使用经历，为大家收集了 5 款关于 Notion 的第三方小工具。它们有的能为你提高网页剪裁效率，有的能为你在 Notion 中直接标注文章，还有的能让你轻轻松松导出你的所有笔记。</p>
<h2 id="网页剪裁：Save-to-Notion"><a href="#网页剪裁：Save-to-Notion" class="headerlink" title="网页剪裁：Save to Notion"></a>网页剪裁：Save to Notion</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/72798929-7880-4df7-86f7-80511ad2af2d.png]]</p>
<p>Save to Notion</p>
<p>市面上有很多优秀的剪藏工具，比如印象笔记剪藏、语雀剪藏、MaoXian Web Clipper 等等。Notion 自家也有一款 Notion WebClipper 插件负责网页的剪裁和插入，不仅支持在浏览器中把网页剪藏到 Databases 和 Pages 中，在移动端上也能方便地进行剪裁。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/3d38960d-121a-48fe-8314-db46011c6f04.png]]</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/0e29973c-a40d-4341-aa1c-70f17779985b.png]]</p>
<p>Notion WebClipper (左) vs. Save to Notion (右)</p>
<p>今天要推荐的插件 Save to Notion 与官方的 WebClipper 功能相近，但是具有以下三个新特点。</p>
<h3 id="1-丰富的可配置项"><a href="#1-丰富的可配置项" class="headerlink" title="1. 丰富的可配置项"></a>1. 丰富的可配置项</h3><p>Save to Notion 不仅能指定工作间（Workspace）和数据库（Database），还能选择预设模板、图标、背景图、以及其他页面属性配置选项。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/c6a8a242-5d66-4e44-8b26-bd112db1e5ab.gif]]</p>
<p>丰富的可选功能</p>
<p>这最大的用处在于，不单单是剪裁了文章或者网页本身，一些基础的标签就可以直接一并添加了，不需要再打开 Notion 去单独添加。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/32122e48-4013-4909-8c6e-3e89ad64abad.png]]</p>
<p>红圈内的预设属性内容都可以在 Save to Notion 里直接更新</p>
<h3 id="2-多种自定义剪裁规则"><a href="#2-多种自定义剪裁规则" class="headerlink" title="2. 多种自定义剪裁规则"></a>2. 多种自定义剪裁规则</h3><p>不同的网页内容，可以添加不同的剪裁规则（Form）方便下一次剪裁。比如，少数派的文章可以放在「Reading List」这个页面，论文又可以选择放在「Research Base」页面里。不同的规则里面的配置也可以完全自定义。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/bc014b08-53b3-4c65-8876-4a9dc65c3dc3.png]]</p>
<p>可以添加多种剪裁规则</p>
<h3 id="3-链接的支持"><a href="#3-链接的支持" class="headerlink" title="3. 链接的支持"></a>3. 链接的支持</h3><p>网页剪裁的时候，可以选择对应链接的数据库（Relation Field），包括最近新推出的反向链接。这项功能加强了剪裁页面的功能性，使得 Notion 彼此页面的连接更加紧密。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/bba87fd4-5013-4aa7-ae16-9def145ec571.gif]]</p>
<p>可以选择对应连接的数据库</p>
<p>你可以在 <a href="https://chrome.google.com/webstore/detail/save-to-notion/ldmmifpegigmeammaeckplhnjbbpccmm?hl=en">Chrome 网上应用店</a> 或 <a href="https://addons.mozilla.org/en-US/firefox/addon/save-to-notion/">FireFox Add-on</a> 获取 Save to Notion。值得一提的是，开发者目前正在更新 Edge 的相应插件，期待之后对 Edge 的支持。</p>
<h2 id="标注文章：Notion-Mark-Manager"><a href="#标注文章：Notion-Mark-Manager" class="headerlink" title="标注文章：Notion+ Mark Manager"></a>标注文章：Notion+ Mark Manager</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/f6dde0ce-4d9e-4fa3-aec3-3721772e1874.png]]</p>
<p>Notion+ Mark Manager</p>
<p>我很喜欢<a href="https://simpread.pro/">简悦</a>，新版本一出来就第一时间在少数派下单了高级用户。沉浸式的阅读体验以及新增的「稍后读」功能真的让人爱不释手。</p>
<p>但对我来说，还是有一个痛点，有些时候不想去稍后读处理网页文章，就只能通过模糊锚定在 Notion 里直接进行标注。之前少数派推荐了 <a href="https://sspai.com/post/63033">Hypothesis</a> 这款标注工具，除开注册和配置的繁琐，也并不能完全支持直接在 Notion 页面里进行标注。此外，Notion 自带的标注功能虽然可选颜色和样式众多，却无法之后进行查询，只能成为绣花枕头。</p>
<p>Notion+ Mark Manager 则完美地解决了 Notion 文章标注的问题。你可以用 Notion 自带的页标注，还可以一键显示页面所有标注，轻松定位到当前标注位置，以及导出 / 导入各种标注。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/3c779c38-2ec0-4f52-b412-6e9d22df28a3.gif]]</p>
<p>自如切换标注内容以及定位到所选标注（Credit：Yeefun）</p>
<p>你可以在 <a href="https://chrome.google.com/webstore/detail/notion%20-mark-manager/hipgmnlpnimedfepbfbfiaobohhffcfc">Chrome 网上应用店</a> 或 <a href="https://addons.mozilla.org/en-US/firefox/addon/notion-mark-manager/">Firefox Add-on</a> 或 <a href="https://github.com/yeefun/notion-mark-manager">GitHub</a> 获取 Notion+ Mark Manager。</p>
<h2 id="导出笔记：Notion-PDF-Export"><a href="#导出笔记：Notion-PDF-Export" class="headerlink" title="导出笔记：Notion PDF Export"></a>导出笔记：Notion PDF Export</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/83194db6-a6db-4d67-b058-a5a9df6168e7.jpeg]]</p>
<p>Notion Batch PDF Export</p>
<p>Notion 本身也自带了批量导出 PDF 文件的功能。然而，这个功能只对企业级用户（Enterprise User）开放，我这种学生免费套餐的用户只能眼巴巴地看着。之前王树义老师分享了<a href="https://sspai.com/post/61551">一个工具</a>来帮助大家导出笔记，今天就再推荐一个给大家。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/b48a961f-1e3a-48c8-92dc-d9997f02f4ba.png]]</p>
<p>批量 PDF 文件导出只有支持企业级用户</p>
<p>Notion PDF Export 这款软件是我们免费用户的福音，你可以首先导出为 HTML，然后使用这个工具将导出的 HTML 内容全部转换为 PDF。基本步骤如下，具体的操作可以参考 <a href="https://github.com/ganeshh123/notion-pdf-export#notion-pdf-export">GitHub 网站</a>。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/37126cda-f15c-434a-a511-7f889183b24d.png]]</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/0c07ef93-843f-403c-a11a-4b74e135b377.png]]</p>
<ol>
<li>选择导出格式 （HTML, 包括子页面）；2. 解压导出的 zip 文件</li>
</ol>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/32910083-fee2-4696-8006-92ea8f87bf46.png]]</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/7ec05db5-9344-4efe-bbb7-32f5ab3082e7.png]]</p>
<ol start="3">
<li>将解压出来的所有文件导入到该工具所在文件夹；4. 执行工具 exe 文件（以管理员身份运行）</li>
</ol>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/262762e9-03bc-4174-98c0-56cc9fff82a4.gif]]</p>
<p>导出的目标笔记文件（PDF 格式）</p>
<p>你可以获取 <a href="https://github.com/ganeshh123/notion-pdf-export/releases/download/1.3.0/notion-pdf-export_windows_1.3.0.zip">Windows 版本</a> 或 <a href="https://github.com/ganeshh123/notion-pdf-export/releases/download/1.3.0/notion-pdf-export_mac_1.3.0.zip">Mac 版本</a> 或在 <a href="https://github.com/ganeshh123/notion-pdf-export#notion-pdf-export">GitHub</a> 中获取 Notion PDF Export。</p>
<h2 id="幻灯片播放：Snackthis-co"><a href="#幻灯片播放：Snackthis-co" class="headerlink" title="幻灯片播放：Snackthis.co"></a>幻灯片播放：Snackthis.co</h2><p>[[https//cdn.sspai.com/2020/10/29/ed7d2926cff2e22c261cb3cb9cb4fa9b.png]]</p>
<p>Snackthis.co Presentation</p>
<p>Notion 页面除了可以做静态网页页面，也可以拿来做幻灯片展示。虽然功能上比不了 PowerPoint 或者 Keynote, 但是用来放置在登录页（Landing Page）上作为一个页面简介也是极好的。</p>
<p>Notion 自家有一款 Notion Slides 的工具，但是可选功能不足。支持 Notion 页面作为幻灯片的第三方插件不少，<a href="https://wunderpresentation.com/">Wunderpresentation</a> 也是一款简单好用的幻灯片演示工具，但相比于 Snackthis.co，可选样式和导出模式比较少。</p>
<p>使用 Snackthis.co 也十分简单，将你要进行演示的页面设置为公用，复制页面地址（Page URL）到网页里，点击「Beautify」按钮即可。制作好的幻灯片可以将链接置于自己的 Notion 或者其他网页里，也可以分享给其他人。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/785f8b59-9050-425c-a5cc-c049ffa1678d.png]]</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/f7bd3768-0f74-4cad-8eaf-65d3e1c3ee75.png]]</p>
<ol>
<li>获取公开的页面链接；2. 粘贴制作幻灯片</li>
</ol>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/69bed03d-2767-4ba8-8c7b-3c449e7fe6bd.gif]]</p>
<p>五种背景色以及三种英文文字样式可供选择</p>
<p>你可以在<a href="https://snackthis.co/presentations/">官网</a>用 Notion 页面进行幻灯片的制作。</p>
<h2 id="Notion-页面小组件：Indify-co"><a href="#Notion-页面小组件：Indify-co" class="headerlink" title="Notion 页面小组件：Indify.co"></a>Notion 页面小组件：Indify.co</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/8132018a-aae8-44b0-891a-82850cbf7b4e.png]]</p>
<p>Indify.co</p>
<p>喜欢添加小组件（widget）来美化自己页面的小伙伴，这款小工具值得拥有。Indify.co 可以让你在 Notion 页面里添加实时天气、进度条、倒计时、引言、时钟、以及谷歌日历。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/710189f3-5b50-493d-9ea0-334df12b9fac.png]]</p>
<p>天气，引言和倒计时显示插件</p>
<p>只需要在官网输入邮箱注册，即可选择各种组件进行制作。制作好之后，将产生的链接粘贴到自己的 Notion 页面即可。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/9caafe92-091f-4415-bca1-ae6c82f824e6.png]]</p>
<p>制作天气小组件（可以选择位置，单位，显示天数）</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6 %E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8/f68c754c-d80b-4383-a271-de404b3ff416.png]]</p>
<p>多种小插件可供选择制作</p>
<p>你可以在<a href="https://indify.co/">官网</a>上注册并使用 Indify.co。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相信随着大家对 Notion 使用的深入，会有更多优秀的第三方工具涌现出来。正所谓「工欲善其事，必先利其器。」，希望本文列举出来的小工具能为你平时使用 Notion 提供更多便利和支持，祝使用愉快！😄</p>
<p>另外，如果大家需要我分享我的 Notion 模板（比如阅读清单），请在评论里指出，我会粘贴在评论处供大家使用和改进。🤝</p>
<blockquote>
<p>下载少数派客户端 、关注少数派公众号 ，发现更多实用小工具 ⚙️</p>
</blockquote>
<blockquote>
<p>特惠、好用的硬件产品，尽在少数派 sspai 官方店铺  🛒 本文由简悦 SimpRead 转码</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
  </entry>
  <entry>
    <title>剪裁网页增强、标注文章、笔记导出……这 5 个第三方工具让 Notion 更好用 - 少数派</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/%E5%89%AA%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99%205%20%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9%20Notion%20%E6%9B%B4%E5%A5%BD%E7%94%A8%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剪裁网页增强、标注文章、笔记导出……这-5-个第三方工具让-Notion-更好用-少数派"><a href="#剪裁网页增强、标注文章、笔记导出……这-5-个第三方工具让-Notion-更好用-少数派" class="headerlink" title="剪裁网页增强、标注文章、笔记导出……这 5 个第三方工具让 Notion 更好用 - 少数派"></a>剪裁网页增强、标注文章、笔记导出……这 5 个第三方工具让 Notion 更好用 - 少数派</h1><p>Created: May 26, 2022 8:26 AM<br>Tags: #notion, #ppt, #少数派<br>URL: <a href="https://sspai.com/post/63355">https://sspai.com/post/63355</a></p>
<p>[[https//cdn.sspai.com/2020/10/29/ae7f4b90293c8e853fdec2a6d71d37cf.png]]</p>
<hr>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/ae7f4b90293c8e853fdec2a6d71d37cf.png]]</p>
<h3 id="Matrix-精选"><a href="#Matrix-精选" class="headerlink" title="Matrix 精选"></a><strong>Matrix 精选</strong></h3><p><a href="https://sspai.com/matrix">Matrix</a> 是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。</p>
<p>文章代表作者个人观点，少数派仅对标题和排版略作修改。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>[[Notion]] 是一款非常优秀的数字化生产力工具，在任务管理，知识整合方面都能提供易于使用和高效的体验。丰富的模板，干净的用户体验以及优秀的社区，越来越多人爱上这「第二个大脑」（Second brain）。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/8e0a489b7359ee0c24a3a33e7946e277.png]]</p>
<p>Notion 作为信息收集处理的「第二大脑」（Credit：Tiago Forte）</p>
<p>随着使用人数的增加，Notion 相关的第三方工具也如雨后春笋般迅速地冒出来。本篇文章基于我个人的使用经历，为大家收集了 5 款关于 Notion 的第三方小工具。它们有的能为你提高网页剪裁效率，有的能为你在 Notion 中直接标注文章，还有的能让你轻轻松松导出你的所有笔记。</p>
<h2 id="网页剪裁：Save-to-Notion"><a href="#网页剪裁：Save-to-Notion" class="headerlink" title="网页剪裁：Save to Notion"></a>网页剪裁：Save to Notion</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/c1704198763ea60aaf9993bd7bbfbd70.png]]</p>
<p>Save to Notion</p>
<p>市面上有很多优秀的剪藏工具，比如印象笔记剪藏、语雀剪藏、MaoXian Web Clipper 等等。Notion 自家也有一款 Notion WebClipper 插件负责网页的剪裁和插入，不仅支持在浏览器中把网页剪藏到 Databases 和 Pages 中，在移动端上也能方便地进行剪裁。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/396d537c05360a56d609d62e0cbb82cf.png]]</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/2f9ff90c7eb654a8041847b57aa83bea.png]]</p>
<p>Notion WebClipper (左) vs. Save to Notion (右)</p>
<p>今天要推荐的插件 Save to Notion 与官方的 WebClipper 功能相近，但是具有以下三个新特点。</p>
<h3 id="1-丰富的可配置项"><a href="#1-丰富的可配置项" class="headerlink" title="1. 丰富的可配置项"></a>1. 丰富的可配置项</h3><p>Save to Notion 不仅能指定工作间（Workspace）和数据库（Database），还能选择预设模板、图标、背景图、以及其他页面属性配置选项。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/07e85cb11e90c71512bd81ed5a0c0e1c.gif]]</p>
<p>丰富的可选功能</p>
<p>这最大的用处在于，不单单是剪裁了文章或者网页本身，一些基础的标签就可以直接一并添加了，不需要再打开 Notion 去单独添加。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/9dba33e6c63e51fe8933adb770cc290b.png]]</p>
<p>红圈内的预设属性内容都可以在 Save to Notion 里直接更新</p>
<h3 id="2-多种自定义剪裁规则"><a href="#2-多种自定义剪裁规则" class="headerlink" title="2. 多种自定义剪裁规则"></a>2. 多种自定义剪裁规则</h3><p>不同的网页内容，可以添加不同的剪裁规则（Form）方便下一次剪裁。比如，少数派的文章可以放在「Reading List」这个页面，论文又可以选择放在「Research Base」页面里。不同的规则里面的配置也可以完全自定义。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/fb654a47e83f21bd3e1dc7b5bf16f35f.png]]</p>
<p>可以添加多种剪裁规则</p>
<h3 id="3-链接的支持"><a href="#3-链接的支持" class="headerlink" title="3. 链接的支持"></a>3. 链接的支持</h3><p>网页剪裁的时候，可以选择对应链接的数据库（Relation Field），包括最近新推出的反向链接。这项功能加强了剪裁页面的功能性，使得 Notion 彼此页面的连接更加紧密。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/7535ed7774452d03db6013b9a9504948.gif]]</p>
<p>可以选择对应连接的数据库</p>
<p>你可以在 <a href="https://chrome.google.com/webstore/detail/save-to-notion/ldmmifpegigmeammaeckplhnjbbpccmm?hl=en">Chrome 网上应用店</a> 或 <a href="https://addons.mozilla.org/en-US/firefox/addon/save-to-notion/">FireFox Add-on</a> 获取 Save to Notion。值得一提的是，开发者目前正在更新 Edge 的相应插件，期待之后对 Edge 的支持。</p>
<h2 id="标注文章：Notion-Mark-Manager"><a href="#标注文章：Notion-Mark-Manager" class="headerlink" title="标注文章：Notion+ Mark Manager"></a>标注文章：Notion+ Mark Manager</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/09c37abbf7b61f96c9673c7e27ec2122.png]]</p>
<p>Notion+ Mark Manager</p>
<p>我很喜欢<a href="https://simpread.pro/">简悦</a>，新版本一出来就第一时间在少数派下单了高级用户。沉浸式的阅读体验以及新增的「稍后读」功能真的让人爱不释手。</p>
<p>但对我来说，还是有一个痛点，有些时候不想去稍后读处理网页文章，就只能通过模糊锚定在 Notion 里直接进行标注。之前少数派推荐了 <a href="https://sspai.com/post/63033">Hypothesis</a> 这款标注工具，除开注册和配置的繁琐，也并不能完全支持直接在 Notion 页面里进行标注。此外，Notion 自带的标注功能虽然可选颜色和样式众多，却无法之后进行查询，只能成为绣花枕头。</p>
<p>Notion+ Mark Manager 则完美地解决了 Notion 文章标注的问题。你可以用 Notion 自带的页标注，还可以一键显示页面所有标注，轻松定位到当前标注位置，以及导出/导入各种标注。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/4bcd441b132dffdd33387542bd830577.gif]]</p>
<p>自如切换标注内容以及定位到所选标注（Credit：Yeefun）</p>
<p>你可以在 <a href="https://chrome.google.com/webstore/detail/notion%20-mark-manager/hipgmnlpnimedfepbfbfiaobohhffcfc">Chrome 网上应用店</a> 或 <a href="https://addons.mozilla.org/en-US/firefox/addon/notion-mark-manager/">Firefox Add-on</a> 或 <a href="https://github.com/yeefun/notion-mark-manager">GitHub</a> 获取 Notion+ Mark Manager。</p>
<h2 id="导出笔记：Notion-PDF-Export"><a href="#导出笔记：Notion-PDF-Export" class="headerlink" title="导出笔记：Notion PDF Export"></a>导出笔记：Notion PDF Export</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/ba3dd244a53852cbff9a9138cde8f476.jpg]]</p>
<p>Notion Batch PDF Export</p>
<p>Notion 本身也自带了批量导出 PDF 文件的功能。然而，这个功能只对企业级用户（Enterprise User）开放，我这种学生免费套餐的用户只能眼巴巴地看着。之前王树义老师分享了<a href="https://sspai.com/post/61551">一个工具</a>来帮助大家导出笔记，今天就再推荐一个给大家。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/4f3519e03b5af66057b50f16a365493b.png]]</p>
<p>批量 PDF 文件导出只有支持企业级用户</p>
<p>Notion PDF Export 这款软件是我们免费用户的福音，你可以首先导出为 HTML，然后使用这个工具将导出的 HTML 内容全部转换为 PDF。基本步骤如下，具体的操作可以参考 <a href="https://github.com/ganeshh123/notion-pdf-export#notion-pdf-export">GitHub 网站</a>。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/c4234247d6819fd4be28a4adec394203.png]]</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/f040d4e4c4258c56f63bc831596eea3e.png]]</p>
<ol>
<li>选择导出格式 （HTML, 包括子页面）；2.解压导出的zip文件</li>
</ol>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/5615d667fa0a88f1f47a97acf1159c72.png]]</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/66d005a9433b916290bc32f0eb01fc54.png]]</p>
<p>3.将解压出来的所有文件导入到该工具所在文件夹；4.执行工具exe文件（以管理员身份运行）</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/8024cda1e751c2f654cb2b5dfbc04ca8.gif]]</p>
<p>导出的目标笔记文件（PDF 格式）</p>
<p>你可以获取 <a href="https://github.com/ganeshh123/notion-pdf-export/releases/download/1.3.0/notion-pdf-export_windows_1.3.0.zip">Windows 版本</a> 或 <a href="https://github.com/ganeshh123/notion-pdf-export/releases/download/1.3.0/notion-pdf-export_mac_1.3.0.zip">Mac 版本</a> 或在 <a href="https://github.com/ganeshh123/notion-pdf-export#notion-pdf-export">GitHub</a> 中获取 Notion PDF Export。</p>
<h2 id="幻灯片播放：Snackthis-co"><a href="#幻灯片播放：Snackthis-co" class="headerlink" title="幻灯片播放：Snackthis.co"></a>幻灯片播放：Snackthis.co</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/ed7d2926cff2e22c261cb3cb9cb4fa9b.png]]</p>
<p>Snackthis.co Presentation</p>
<p>Notion 页面除了可以做静态网页页面，也可以拿来做幻灯片展示。虽然功能上比不了 PowerPoint 或者 Keynote, 但是用来放置在登录页（Landing Page）上作为一个页面简介也是极好的。</p>
<p>Notion 自家有一款 Notion Slides 的工具，但是可选功能不足。支持 Notion 页面作为幻灯片的第三方插件不少，<a href="https://wunderpresentation.com/">Wunderpresentation</a> 也是一款简单好用的幻灯片演示工具，但相比于 Snackthis.co，可选样式和导出模式比较少。</p>
<p>使用 Snackthis.co 也十分简单，将你要进行演示的页面设置为公用，复制页面地址（Page URL）到网页里，点击「Beautify」按钮即可。制作好的幻灯片可以将链接置于自己的 Notion 或者其他网页里，也可以分享给其他人。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/1a61a67bf44d930457c2930b30466c73.png]]</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/804c681e0d88a20143c386cf963989d6.png]]</p>
<ol>
<li>获取公开的页面链接；2.粘贴制作幻灯片</li>
</ol>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/1b4071720018ce9fd4da9d060807b85d.gif]]</p>
<p>五种背景色以及三种英文文字样式可供选择</p>
<p>你可以在<a href="https://snackthis.co/presentations/">官网</a>用 Notion 页面进行幻灯片的制作。</p>
<h2 id="Notion-页面小组件：Indify-co"><a href="#Notion-页面小组件：Indify-co" class="headerlink" title="Notion 页面小组件：Indify.co"></a>Notion 页面小组件：Indify.co</h2><p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/99692b2ab3f92572114071567353790b.png]]</p>
<p>Indify.co</p>
<p>喜欢添加小组件（widget）来美化自己页面的小伙伴，这款小工具值得拥有。Indify.co 可以让你在 Notion 页面里添加实时天气、进度条、倒计时、引言、时钟、以及谷歌日历。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/36fe6352bd5822800bc0b83f7b41c5fb.png]]</p>
<p>天气，引言和倒计时显示插件</p>
<p>只需要在官网输入邮箱注册，即可选择各种组件进行制作。制作好之后，将产生的链接粘贴到自己的 Notion 页面即可。</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/5a68387eb22416ac333ce0757d363a35.png]]</p>
<p>制作天气小组件（可以选择位置，单位，显示天数）</p>
<p>[[剪%E8%A3%81%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%BC%BA%E3%80%81%E6%A0%87%E6%B3%A8%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%E2%80%A6%E2%80%A6%E8%BF%99 5 %E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E8%AE%A9 Notion %E6%9B%B4%E5%A5%BD%E7%94%A8 - %E5%B0%91%E6%95%B0%E6%B4%BE/4cd6dd0c0688404bc284f5450a9ae3fe.png]]</p>
<p>多种小插件可供选择制作</p>
<p>你可以在<a href="https://indify.co/">官网</a>上注册并使用 Indify.co。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相信随着大家对 Notion 使用的深入，会有更多优秀的第三方工具涌现出来。正所谓「工欲善其事，必先利其器。」，希望本文列举出来的小工具能为你平时使用 Notion 提供更多便利和支持，祝使用愉快！😄</p>
<p>另外，如果大家需要我分享我的 Notion 模板（比如阅读清单），请在评论里指出，我会粘贴在评论处供大家使用和改进。🤝</p>
<blockquote>
<p>下载少数派<a href="https://sspai.com/page/client">客户端</a> 、关注<a href="https://sspai.com/s/J71e">少数派公众号</a> ，发现更多实用小工具 ⚙️</p>
</blockquote>
<blockquote>
<p>特惠、好用的硬件产品，尽在<a href="https://shop549593764.taobao.com/?spm=a230r.7195193.1997079397.2.2ddc7e0bPqKQHc">少数派 sspai 官方店铺</a>  🛒</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#ppt</tag>
        <tag>#notion</tag>
        <tag>#少数派</tag>
      </tags>
  </entry>
  <entry>
    <title>在notion中我们可以嵌入哪些国内应用？（01） - 知乎</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/%E5%9C%A8notion%E4%B8%AD%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%85%A5%E5%93%AA%E4%BA%9B%E5%9B%BD%E5%86%85%E5%BA%94%E7%94%A8%EF%BC%9F%EF%BC%8801%EF%BC%89%20-%20%E7%9F%A5%E4%B9%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="在notion中我们可以嵌入哪些国内应用？（01）-知乎"><a href="#在notion中我们可以嵌入哪些国内应用？（01）-知乎" class="headerlink" title="在notion中我们可以嵌入哪些国内应用？（01） - 知乎"></a>在notion中我们可以嵌入哪些国内应用？（01） - 知乎</h1><p>Created: October 27, 2021 1:37 PM<br>Tags: #notion, #知乎<br>URL: <a href="https://zhuanlan.zhihu.com/p/281618057">https://zhuanlan.zhihu.com/p/281618057</a><br>author: 喵字效率手册</p>
<p>[[在notion中我们可以嵌入哪些国内应%E7%94%A8%EF%BC%9F%EF%BC%8801%EF%BC%89 - %E7%9F%A5%E4%B9%8E/v2-08ceeb89a6f35ca4d4942049411a75fd_1440w.jpg]]</p>
<h2 id="嵌入方法"><a href="#嵌入方法" class="headerlink" title="嵌入方法"></a>嵌入方法</h2><p>开篇，我先介绍一下嵌入的方法。</p>
<p>首先要确定该应用是否有网页端，没有网页端的话，就很难了。目前，我也不知道有哪些方法能够把非网页端应用嵌入进来，如果有大神知道，望告知。话说回来，也并不是所有的网页都能成功嵌入并且完美适配。</p>
<p>嵌入方法很简单，总共就两步。</p>
<p>第一步，复制网页链接。</p>
<p>这里我以石墨文档为例子。链接如下</p>
<p>第二步，粘贴进notion的模块单位里面，这时会弹出三个选项，如下图所示，选中最后一个“Create embed”。</p>
<p>好了，方法是不是很简单，你学会了吗？</p>
<p>接下来进入正题。本人亲测可用。</p>
<h2 id="生产力工具篇"><a href="#生产力工具篇" class="headerlink" title="生产力工具篇"></a>生产力工具篇</h2><ol>
<li>滴答清单</li>
<li>石墨文档</li>
<li>百度脑图</li>
<li>幕布</li>
<li>有道云笔记</li>
<li>百度翻译</li>
<li>有道翻译</li>
<li>独特工具箱</li>
<li>腾讯文档（注意，能嵌入不代表能在notion里面一站使用，腾讯文档总是喜欢跳链接到浏览器，不是很推荐嵌入使用）</li>
</ol>
<h2 id="其他篇"><a href="#其他篇" class="headerlink" title="其他篇"></a>其他篇</h2><ol>
<li>花瓣</li>
<li>少数派</li>
<li>微信读书</li>
<li>书格</li>
<li>小鸡词典</li>
<li>BiliOB观测者</li>
<li>豆瓣（豆瓣结合notion使用会非常强大，减少很多管理工作量，回头我开新坑介绍我的方法论）</li>
<li>腾讯视频（能嵌入，但意义不大，不能在notion里面播放，会跳链接。如果能在notion里播放，那做文案工作就方便很多了，甚是可惜）</li>
<li>QQ邮箱（依然能嵌入，但是很遗憾，可以点击的部分不多，也就是说，你顶多查看一下邮件列表，其他啥也干不成）</li>
<li>全历史（真乃学习历史的神器，不过比较遗憾的是，依然会跳链接到浏览器）</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>就先写到这，虽然这篇文章看似简单直接，但却花费了我很长的时间去寻找和体验。</p>
<p>相信日后，随着我的对notion的使用，我会找到更多的嵌入工具告诉各位看官，所以未完待续。</p>
<p>建议对notion有兴趣的朋友可以关注一下我的动态。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
        <tag>#知乎</tag>
      </tags>
  </entry>
  <entry>
    <title>ProBuilder快速关卡建模实践</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/ProBuilder%E5%BF%AB%E9%80%9F%E5%85%B3%E5%8D%A1%E5%BB%BA%E6%A8%A1%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ProBuilder快速关卡建模实践"><a href="#ProBuilder快速关卡建模实践" class="headerlink" title="ProBuilder快速关卡建模实践"></a>ProBuilder快速关卡建模实践</h1><p>Created: November 10, 2021 10:08 PM<br>URL: <a href="https://mp.weixin.qq.com/s?__biz=MzU5MjQ1NTEwOA==&amp;mid=2247493165&amp;idx=1&amp;sn=8b2be56909449c787ef335feecd0d0be&amp;chksm=fe1dd286c96a5b907971e59d57181d4ea7c354f1d741172d196633eb497527b70cf0429efdf8&amp;mpshare=1&amp;scene=1&amp;srcid=0531p2jJBHCo3OXwHHk75vju#rd">https://mp.weixin.qq.com/s?__biz=MzU5MjQ1NTEwOA==&amp;mid=2247493165&amp;idx=1&amp;sn=8b2be56909449c787ef335feecd0d0be&amp;chksm=fe1dd286c96a5b907971e59d57181d4ea7c354f1d741172d196633eb497527b70cf0429efdf8&amp;mpshare=1&amp;scene=1&amp;srcid=0531p2jJBHCo3OXwHHk75vju#rd</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
  </entry>
  <entry>
    <title>强化你的仪表盘：试试 Notion 类工具的国产组件库 NotionPet - 少数派</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95%20Notion%20%E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93%20NotionPet%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="强化你的仪表盘：试试-Notion-类工具的国产组件库-NotionPet-少数派"><a href="#强化你的仪表盘：试试-Notion-类工具的国产组件库-NotionPet-少数派" class="headerlink" title="强化你的仪表盘：试试 Notion 类工具的国产组件库 NotionPet - 少数派"></a>强化你的仪表盘：试试 Notion 类工具的国产组件库 NotionPet - 少数派</h1><p>Created: May 26, 2022 8:21 AM<br>Tags: #notion, #少数派<br>URL: <a href="https://sspai.com/post/73211">https://sspai.com/post/73211</a></p>
<p>[[https//cdn.sspai.com/2022/05/14/f9cf8d905775a1c6298c9aac92bbbf4c.png]]</p>
<hr>
<p><strong>Matrix 首页推荐</strong></p>
<p><a href="https://sspai.com/matrix">Matrix</a> 是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。</p>
<p>文章代表作者个人观点，少数派仅对标题和排版略作修改。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前段时间我发布了《<a href="https://sspai.com/post/71893">Notion 优质资源汇总</a>》，在这篇文章中，不少小伙伴反映了一个问题：这些面向 Notion 类产品的服务，几乎都是由国外开发者提供，有些产品虽然好但是需要付费，另外一些产品虽然是免费的，但是在大陆地区使用的话服务器又不够稳定。</p>
<p>有比较好的解决办法吗？比如推荐使用一些国产服务。在资源汇总这篇文章发布后，通过评论区的留言，我加上了 <a href="https://noto.so/">Noto</a>，这是 @<a href="https://sspai.com/u/jimmylv/posts">吕立青_JimmyLv</a> 提供的建站服务。今天我介绍另外一个在评论区发现的、面向 Notion 类产品的服务——国产组件库 NotionPet。</p>
<p>很多用户可能对小组件并不陌生，这当中最为常见的便是智能手机等移动设备的桌面，Android 和 iOS 已经先后支持了小组件。小组件，英文为 widget extension，主要以图形化展示的可视化模块，让用户想要了解的信息触手可及。</p>
<p>与此类似的，使用 NotionPet，[[Notion]]、[[FlowUs]] 等服务的用户，也可以在笔记软件内部嵌入可视化模块，建立强大的仪表盘。</p>
<p>现在让我们一起走进国产小组件库 NotionPet。</p>
<h2 id="初识-NotionPet"><a href="#初识-NotionPet" class="headerlink" title="初识 NotionPet"></a>初识 NotionPet</h2><p>点击 <a href="https://notion.pet/#/">NotionPet</a> 的官网链接便可以看到官网介绍。这个站点的主要功能，便是为 Notion 等产品提供好看、强大、可定制的小组件。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/50bbaabad4d68537122cd47e670a0d78.png]]</p>
<p>NotionPet 目前允许新用户通过电子邮箱注册账号，或者可以直接微信扫码登录。随后我们就可以进入主页了。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/7f99050e897be64d2adfa9514a692348.png]]</p>
<p>在这里，我们自己所创建的小组件可以在页面上方查看，页面下方则是官方的小组件市场。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/4620ee3facc4b1f8024fad0c97461bfa.png]]</p>
<p>NotionPet 的小组件包括两种：基础组件和动态 Icon 组件。</p>
<p><strong>基础组件</strong>：NotionPet 目前提供了 21 个基础组件，包括动效文字、极简番茄钟、年度格子、生命倒计时、扁平时钟、访客统计、环形多彩时钟、中国天气组件、词霸每日一句英语、页面访客点赞、荧光关注引导、简约生日倒计时、微博热搜排行榜、恋爱纪念、哔哩哔哩粉丝看板、打卡计数、节假日倒计时。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/9117d145c184f4d8492c7ab05ed3db51.png]]</p>
<p><strong>动态 Icon 组件</strong>：目前动态 Icon 组件支持动态日历和 NotionPet 文字。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/529c40d6d05bc7a1850831076a3b9921.png]]</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/9c27bb552d1b76b8a1b1947aeabf3eb3.png]]</p>
<h2 id="小组件使用方式"><a href="#小组件使用方式" class="headerlink" title="小组件使用方式"></a>小组件使用方式</h2><p>NotionPet 的使用方法十分简单。具体流程如下：</p>
<p>首先，在小组件市场浏览并选择你想要创建的小组件类型。随后，将光标悬浮在该小组件之上，点击创建组件。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/1ef8d0657c7fec1ef518de3f5375f507.png]]</p>
<p>创建组件之后便直接进入了组件配置界面。如图，在配置页面左上角，你可以对小组件的标题进行设置。配置包括两种：一种是组件设置，主要设置组件内容中的文字内容、文字颜色、日期、数字等基础信息。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/1babea64243f670cfe000d69597a5c43.png]]</p>
<p>另外一种是公共配置，主要是配置小组件的外观显示效果，包括是否浅色和深色模式的选择以及对应的自定义容器背景的颜色配置。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/dfca4933babccba96a521f731e99c301.png]]</p>
<p>在配置完成后，在左下角复制链接，然后粘贴至你正在使用的 Notion 类笔记软件中，选择 「Embed/嵌入显示」即可。</p>
<h2 id="小组件使用场景"><a href="#小组件使用场景" class="headerlink" title="小组件使用场景"></a>小组件使用场景</h2><p>由于我正在使用支持文件夹页面、原生应用开发的 <a href="https://flowus.cn/product">FlowUs</a> . 下面我将以 FlowUs 为例，演示如何小组件的使用场景。</p>
<p><a href="%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95%20Notion%20%E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93%20NotionPet%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE%203d07c7f81be145c5a51e598fbaea1167/725c3139bace832daacfaeaad3c293c9">%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95%20Notion%20%E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93%20NotionPet%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE%203d07c7f81be145c5a51e598fbaea1167/725c3139bace832daacfaeaad3c293c9</a></p>
<p>FlowUs</p>
<h3 id="时间管理-amp-任务管理"><a href="#时间管理-amp-任务管理" class="headerlink" title="时间管理 &amp; 任务管理"></a>时间管理 &amp; 任务管理</h3><p>目前小组件主要属于时间管理、任务管理类。具体来说，我将其分为如下几个细分类别：</p>
<ul>
<li><strong>时钟类</strong>：极简番茄钟、环形多彩时钟；</li>
<li><strong>日期提醒类</strong>：生命倒计时、年度格子、节假日倒计时、恋爱纪念日、简约生日倒计时；</li>
<li><strong>天气类</strong>：基础中国天气类；</li>
<li><strong>打卡类</strong>：今天喝水数量。</li>
</ul>
<p>我使用这些小组件做了一个主页仪表盘，如图。为了紧凑，我将这些小组件集中在同一个页面了。你可以根据需要，选用合适的小组件。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/f352d83cb409fab1b2cab628d5250959.png]]</p>
<p>仪表盘·模版</p>
<p><strong>附</strong></p>
<ul>
<li>图中使用了动态日历。最好的办法是直接将链接上传至 icon/图标处。Notion 支持此功能。FlowUs 近期会上线此功能。</li>
</ul>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/40a53a279a88bed2edfb7c722a323410.png]]</p>
<p>仪表盘·模版</p>
<h3 id="自媒体运营"><a href="#自媒体运营" class="headerlink" title="自媒体运营"></a>自媒体运营</h3><p>此类小组件有多个，主要为：动效文字、哔哩哔哩粉丝看板、页面访客点赞、荧光关注引导、访客统计。具体显示效果如图。</p>
<p>其中，荧光关注引导目前支持哔哩哔哩、Twitter、Github、Notion 等四个站点。前两行为动效文字、哔哩哔哩粉丝看板、访客统计，作为对于读者的欢迎区域；中间为博客内容。最下方左边为荧光关注引导，右边为页面访客点赞。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/0e014ec42388967e25cb6572ae79d759.png]]</p>
<p>参考链接：<a href="https://flowus.cn/share/feb0ec4c-1a6d-4550-bbb6-5399d85ce12e">FlowUs 自媒体运营·模版·传送门</a></p>
<h3 id="资讯管理类"><a href="#资讯管理类" class="headerlink" title="资讯管理类"></a>资讯管理类</h3><p>此类小组件目前只有一个：微博热搜排行榜。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/cfa12e0f378bfd4d7add857e1bee3257.png]]</p>
<p>这种类型的小组件还是比较有用的，可以作为轻量级的阅读看板。现在的问题是，热搜排行榜的类型比较少，只有微博。如果能加入少数派、知乎、澎湃新闻、豆瓣、虎嗅网、36kr、哔哩哔哩等热门站点的热搜排行版就好了。</p>
<p>开发者不妨参考国内聚焦于热搜排行榜的产品——<a href="https://tophub.today/">今日热榜</a>。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/139983bb7d1882c8ca6538a833f51704.png]]</p>
<h3 id="学习类"><a href="#学习类" class="headerlink" title="学习类"></a>学习类</h3><p>此类小组件目前只有一个：词霸每日英语。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/dd330eb307567f7aa793cae4573e8707.png]]</p>
<p>以上是每日一词组件的显示效果。当然，单纯将这个组件放在一个页面中没有意义。每日一词小组件，最好放在你笔记软件的主页所在的仪表盘中，方便你每次打开查看几眼。或者，如果你正在学习英语，也可以放在相关笔记内容的首页处。</p>
<h2 id="价格体系"><a href="#价格体系" class="headerlink" title="价格体系"></a>价格体系</h2><p>NotionPet 区分为基础版和 Pro 版，其中基础版是对组件创建个数、组件创建类型存在限制。基础版提供创建 2 个基础组件和 3 个动态动态图标的数量，如果需要解除这些限制，则需要升级为 Pro 版。目前还不存在需要付费的高级组件类型，未来开发者可能会增加几个 Pro 组件。</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/6258887582e65a718d4027638fe70b92.png]]</p>
<p>[[强化你%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%9A%E8%AF%95%E8%AF%95 Notion %E7%B1%BB%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9B%BD%E4%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%93 NotionPet - %E5%B0%91%E6%95%B0%E6%B4%BE/a967475f99a7b04d2471fe347d4518d4.png]]</p>
<p>NotionPet 采取了订阅制。目前价格体系是：</p>
<ul>
<li>3 个月 Pro：9.9 元</li>
<li>1 年 Pro： 36 元</li>
<li>2 年 Pro：70 元</li>
<li>3 年 Pro：99 元</li>
</ul>
<p>目前，<a href="https://notion.pet/">NotionPet 官方</a> 正在活动期间，1 年 Pro 价格为 19.9/年。如果对这个国产组件库所提供的服务感兴趣，可以前往体验。</p>
<p><strong>注</strong>：官方的折扣是通过领券的形式实现的，跳转至 <a href="https://notion.pet/">NotionPet</a> 官网后注册登录，随后优惠券便会自动弹出，领取即可。</p>
<p>如果 <a href="https://notion.pet/">NotionPet</a> 中没有你想要的小组件，也可以点击页面右上角加入社群，或者点击右下角对话窗口，直接向开发者反馈。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上便是关于 NotionPet 的简要介绍。未来NotionPet 的发展方向如下：</p>
<ol>
<li>提供更多好看且实用的小组件</li>
<li>赋予小组件更为强大的定制化能力，满足用户的个性化需求</li>
<li>支持与第三方开发者共建社区生态</li>
<li>服务于更多的 Notion 类产品</li>
</ol>
<p>目前，官方已经将 Notion、FlowUs、Wolai 这三款产品加入官网相关链接。既然如此，随着 NotionPet 的发展也建议改个名，以便服务于更多产品所在的用户群体。</p>
<p>当然，面向 Notion 类的小组件库很多，如果你想对比多个组件库的优点和缺点的话，建议阅读《<a href="https://zhuanlan.zhihu.com/p/494869812">对比国内外 Notion 组件库哪家强？</a>》。如果你有使用体验比较好的资源，麻烦您在评论区分享。</p>
<p><strong>关联阅读：</strong></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<p>下载 <a href="https://sspai.com/page/client">少数派 2.0 客户端</a>、关注 <a href="https://sspai.com/s/J71e">少数派公众号</a>，解锁全新阅读体验 📰</p>
</blockquote>
<blockquote>
<p>实用、好用的 <a href="https://sspai.com/mall">正版软件</a>，少数派为你呈现 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
        <tag>#少数派</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>[[Symbol]]</p>
<p>[[Promise]]</p>
<p>[[Class]]</p>
<p>[[Generator]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>想要玩转 Notion？你需要这份快速上手指南 - 少数派</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/%E6%83%B3%E8%A6%81%E7%8E%A9%E8%BD%AC%20Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97%20-%20%E5%B0%91%E6%95%B0%E6%B4%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="想要玩转-Notion？你需要这份快速上手指南-少数派"><a href="#想要玩转-Notion？你需要这份快速上手指南-少数派" class="headerlink" title="想要玩转 Notion？你需要这份快速上手指南 - 少数派"></a>想要玩转 Notion？你需要这份快速上手指南 - 少数派</h1><p>Created: October 27, 2021 1:34 PM<br>Tags: #notion, #少数派<br>URL: <a href="https://sspai.com/post/57464">https://sspai.com/post/57464</a><br>author: 少数派</p>
<p>将笔记、任务管理及知识库相结合，<a href="https://notion.so/">Notion</a> 打造出了一款「瑞士军刀」般的协作工具： Notion 不仅是一款全平台、设计还不错的文档工具，更是在 2.0 版本加入了对表格、看板和日历等功能的支持，真正成为了一款结合文档、知识库以及任务管理功能的全能协作工具</p>
<p>或许你曾被许多人推荐过 Notion，但却不知道从何下手。又或者你已经上手了 Notion，却碍于想象力不知如何挖掘它的潜力。这篇会从基础功能到应用实例，帮你快速上手 Notion。</p>
<h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><p>Notion 的内容单位为「页」(Page)，你可以将 Notion 中的页面理解为传统笔记工具中的一条笔记。不同的是，Notion 中的页面支持无限层级，相当于有了类似于文件夹的功能，我们又能在 Notion 的每个页面中记录笔记。</p>
<p>Notion 页面支持「允许评论」「只读」2 种分享方式，在页面右上角设置页面权限之后，我们就可以复制页面的链接分享给其他人查看了。我们还可以输入其他人的邮箱，邀请其他人加入页面进行编辑。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/d1c909841e0aa00e904295de04554f19.gif]]</p>
<p>图 / Notion 官网</p>
<p>Notion 的编辑工具是一款基于「块」(Block) 的编辑器。简单地说，Notion 中的内容全部由「块」组成的，一段文字是一个「块」、一张图片是一个「块」、一张表格也是一个「块」。</p>
<p>Notion 的编辑器支持 Markdown 语法，它会将 Markdown 文本转为富文本，使用了「所见即所得」的编辑方式；这样做的好处不仅让我们能够方便地使用 Notion 的编辑器排版文本，同时又能利用 Markdown 语法的优势，提高输入效率。</p>
<p>另外，Notion 的编辑器还支持「嵌入模块」(Embed Block)，我们可以在页面中嵌入来自其它网站或者服务的内容，比如一条推文、Google Map 的位置地图等，由于 Notion 只是提取了嵌入网页的信息进行显示，只要嵌入网页中的内容发生变化，Notion 页面中的显示内容会同步进行更新，我们甚至可以在 Notion 页面中直接于其它网页中的内容进行交互，比如在 Notion 中直接查看和缩放 Google Map 中的位置和地图信息。</p>
<p>Notion 在 2.0 版本中加入了对于表格、看板和日历功能的支持，接下来向你介绍这几个功能在 Notion 中的实现方式和效果。</p>
<h3 id="看板"><a href="#看板" class="headerlink" title="看板"></a>看板</h3><p>Notion 的看板功能和 Trello 较为相似，它也能像 Trello 一样实现拖拽管理卡片、添加组员和日期的功能。但和 Trello 相比，Notion 缺少了订阅、归档等团队协作常用的功能。</p>
<p>除了任务管理，你可以用 Notion 的看板做点別的事，比如用不同的看板表示家中不同的收纳空间来记录物品位置、或者整理阅读清单等等。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/60e8ec1cfa30a33dbeb7a3508a89cb6f.gif]]</p>
<p>图 / Notion 官网</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在 Notion 的表格中，每一列的列首决定该列的属性，可选的属性有文字、数字、单选、多选、日期、成员等，你可以利用这些属性中的一个或多个表格内容进行排序和筛选。表格支持简单的数据处理，比如计数、计算时间跨度、加总等。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/a74c1d99b00c1f55342f81083ce9962b.png]]</p>
<p>表格也贯彻了它「无限层级」的设计理念，表格中的每一行都可以展开为一个空白页，以便补充更多细节内容。</p>
<h3 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h3><p>你还可以在 Notion 中插入日历，在相应日期上点击即可添加事件，事件可以发生在一天，也可以通过添加终止时间横跨某一个期间段。</p>
<p>可惜的是，Notion 的日历不支持与第三方服务同步，也不能订阅，它的用途更多是作为笔记中的时间索引，帮你更好地将一个时间段内的任务串联起来。</p>
<p>值得一提的是，表格、看板和日历功能在 Notion 不是相互独立的三部分，它们可以相互进行转换，为一个项目提供不同的视角。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/56ff851bfa3e8e1820645c0947848acd.gif]]</p>
<p>图 / Notion 官网</p>
<p>只要点击左上角的「view」，都可以将当前视图转换成另两种视图。举个例子，当你将一个表格转换成看板视图后，表格中的每一行都会转换成看板中的一张卡片，看板视图中的变化与表格是联动的，如果你在看板视图中将一张 Tag 为「iOS」的卡片拖到了「Android」群组，该张卡片的属性会变成「Android」，在日历视图中亦然。</p>
<h2 id="实用模版"><a href="#实用模版" class="headerlink" title="实用模版"></a>实用模版</h2><p>要说谁最了解 Notion，那么答案肯定是它自己。Notion 提供了涵盖了从个人生活到团队协作等各方面的模板，对 Notion 功能也应用得十分深入，方便我们可以直接套用。</p>
<h3 id="个人-团队主页：Personal-Team-Home"><a href="#个人-团队主页：Personal-Team-Home" class="headerlink" title="个人/团队主页：Personal/Team Home"></a>个人/团队主页：Personal/Team Home</h3><p>如果你想将 Notion 打造为自己的工作区，你肯定希望所有页面都能井井有条地整理好，在你需要时，可以迅速找到特定页面。这时候，一个可以将所有页面分门别类放置好的主页显得尤为重要。</p>
<p>Notion 官方为我们分别准备了 [[个人主页]] 和 [[团队主页]] 的模板，我们可以参照它来布局自己的 Notion 主页。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/b2c8397cc2b5979e6073af74ecbb426d.png]]</p>
<p>个人主页</p>
<p>这个模板的原理并不复杂，仅仅是用标题（Header）和页面（Page）将不同类别的页面归纳好，让你的工作区变得更有条理。主页模板的用法也非常简单，只要按照一定的格式将页面整理好，就能得到一个井井有条的主页。</p>
<h3 id="追踪游戏进度：Video-Game-Tracker"><a href="#追踪游戏进度：Video-Game-Tracker" class="headerlink" title="追踪游戏进度：Video Game Tracker"></a>追踪游戏进度：Video Game Tracker</h3><p>[[Video Game Tracker]] 是一款来自社区的优秀模板，它可以用于追踪游戏的进度。除了游戏外，你也可以用它来追踪正在看的电影、书籍。随着《复仇者联盟 4：终局之战》的上映，不妨用这个模板来追踪自己补电影的进度。</p>
<p>要在画廊中添加内容，只要点击右上角的「新建」（New），随后在弹出的窗口中填写游戏所在的平台、价格等信息即可完成将卡片收入画廊。如果你想用它来追踪阅读进度，也可以通过「添加类目」（Add a Property）来自定义模板。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/12edf35ca3df21d70269860f27b2cfc9.png]]</p>
<p>Video Game Tracker</p>
<p>这个模板用到了 Notion 的「画廊」（Gallery）功能，它可以让我们快速查看多张卡片的概要内容。配合封面图，你可以一目了然地分辨出不同卡片的内容。画廊也支持添加过滤选项，我们可以把所有卡片按照特定的规则筛选出来。你可以在画廊右上角的菜单键中找到「过滤器」（Filter）的选项，并创建自己的过滤规则。</p>
<h3 id="人际关系管理：Intentional-Relationship-Aid"><a href="#人际关系管理：Intentional-Relationship-Aid" class="headerlink" title="人际关系管理：Intentional Relationship Aid"></a>人际关系管理：Intentional Relationship Aid</h3><p>在当今社会，人与人之间的关系逐渐疏远。我们的微信里添加了许多好友，可真正有交集的却寥寥无几。[[Intentional Relationship Aid]] 是用于管理人际关系的一个模板，它可以帮助我们清晰地查看到自己与好友的互动情况。</p>
<p>这个模板用到了 Notion 的表格（Table）及函数功能（Formula），表格可以让我们清晰地看到所有好友的姓名、关系和联系频率等信息。每一行代表一个好友，点击好友名称即可打开一个单独的页面，你可以在这里添加好友的联系方式或是照片。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/4baa16b2484a6fe40fdb68824ab1f8be.png]]</p>
<p>Intentional Relationship Aid</p>
<p>这个模板还通过函数做出了「近期联系的可能性」及「多久联系一次」的推算，它将根据你为好友设置的联系频率和上次联系时间进行运算。作者将具体函数放在了模板中，你可以查看并根据自己的需求进行修改。</p>
<h3 id="个人财务管理：Personal-Finances"><a href="#个人财务管理：Personal-Finances" class="headerlink" title="个人财务管理：Personal Finances"></a>个人财务管理：Personal Finances</h3><p>[[Personal Finances]] 是一款个人财务管理的模板。你不需要拥有相关知识，只需要按照自己的需求对它的内容进行简单修改，就能得到一个自己的财务管理页面。</p>
<p>这个模板分为三个部分：</p>
<ol>
<li><strong>文字信息</strong>：用于放置消费目标、超支金额等文字内容。</li>
<li><strong>消费流水</strong>：以日历形式呈现每日的消费流水，可以清晰查看到消费内容与金额。</li>
<li><strong>每月消费</strong>：以看板形式呈现每月消费，可以根据分类进行过滤筛选。</li>
</ol>
<p>你可以随意修改文字信息，用它来做一个简单的消费计划。要添加消费流水，只需要点击日历右上角的「添加」，随后填入金额、日期等信息即可。你还可以选择消费的方式，比如订阅、预付费或是一次性付费。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/72bded74751b78aee5036fd57525fea6.png]]</p>
<p>Personal Finance</p>
<p>Personal Finances 模板用到了日历（Calendar）及看板（Board）功能，让我们可以通过不同的方式查看到自己的消费情况。即使你不需要进行财务管理，也可以学习它的思路，打造一个集合日历与看板的任务管理工具。</p>
<h3 id="目标进程追踪：OKRs"><a href="#目标进程追踪：OKRs" class="headerlink" title="目标进程追踪：OKRs"></a>目标进程追踪：OKRs</h3><p>OKR（Objectives and Key Results，即目标与关键成果法）是用于跟踪目标的工作法，许多团队都会用它来明确自己的目标及关键成果。[[OKRs]] 就是根据 OKR 工作法所制作的 Notion 模板。</p>
<p>OKRs 通过行内表格的方式来实现目标管理，点击项目名称即可设置目标的参数。设置完成后，你可以在表格中看到当前的数值和完成进度，你也可以随时修改当前数值，进度会自动随之改变。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/a6d17e7179460b986af9ea6611687be2.png]]</p>
<p>OKRs</p>
<p>OKRs 比较亮眼的一点是它用到了模板按钮（Template Button），你只需要点击「添加 OKR」即可快速添加一个新的表格，而不用从头创建新的表格。模板按钮可以用于快速创建模板化的内容，十分方便。</p>
<h3 id="看板式任务管理：Tasks-and-Issues"><a href="#看板式任务管理：Tasks-and-Issues" class="headerlink" title="看板式任务管理：Tasks and Issues"></a>看板式任务管理：Tasks and Issues</h3><p>[[Tasks and Issues]] 是 Notion 官方提供的一个看板式任务管理模板，如果你用过 Trello 或 Teambition，相信你对这个模板不会陌生。看板式任务管理可以让我们更加清晰地看到每个任务的执行情况。</p>
<p>这个模板不但支持对任务进行分类管理，还支持多人协作，你可以将任务分配给相应的同事。此外，你也可以通过自带的过滤器来筛选出分配给自己的任务。你也可以将其打造成自己的任务管理系统，时刻追踪任务完成情况。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/ba6f166cf5a8a5ae668a1f9aa28e23dc.png]]</p>
<p>Tasks &amp; Issues</p>
<p>在看板的时间设置中，你也可以添加提醒，让自己不再错过重要的任务。</p>
<h3 id="会议记录：Meeting-Notes"><a href="#会议记录：Meeting-Notes" class="headerlink" title="会议记录：Meeting Notes"></a>会议记录：Meeting Notes</h3><p>[[Meeting Notes]] 是一个会议记录的模板，它将以列表的形式把会议记录整理起来，你可以清晰地看到与具体会议相关的人员、部门。每一个会议都是一个单独的页面，你可以在页面中进行会议记录和归纳。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/5c60a4b60e8eda350811dcf25f92ca44.png]]</p>
<p>Meeting Notes</p>
<p>会议记录同样支持过滤，你可以按照部门、时间等条件筛选出符合规则的记录。除了套用这个模板进行会议记录外，我们也可以在这个模板的范例里学习到一些会议记录的方式和技巧。</p>
<p>除了 Notion 官方模版库，也有用户为 Notion 建立了第三方模版库。如果你想找到更多关于 Notion 的实用模版，可以阅读我们之前的介绍文章：</p>
<blockquote>
<p><a href="https://sspai.com/post/54148">用好这些实用模板，把 Notion 打造成全能助理</a></p>
</blockquote>
<h2 id="工具实例"><a href="#工具实例" class="headerlink" title="工具实例"></a>工具实例</h2><p>如果在了解 Notion 的基础功能以及模版之后，你仍然不知道能用 Notion 做什么事，不妨跟着下面几个实例实现几个实用小工具，学习其他人的 Notion 使用思路和技巧。</p>
<h3 id="打造个性化-Notion-进度条"><a href="#打造个性化-Notion-进度条" class="headerlink" title="打造个性化 Notion 进度条"></a>打造个性化 Notion 进度条</h3><p>先来试试用 Notion 实现展示年时间进度条的工具，在这个实例中，我们需要用到计算日期已经过去多久的函数，整个进度条是由十个方块■组成，一个方块■代表10%，0 – 10% 就占一个方块■，11% – 20% 就占两个方块■■，以此类推。</p>
<p>比如，今年已经过去 180 天，经过计算，我们可以得出今年已经走完了 180 / 365 = 49%，49% 在 41% – 50% 之间，占用五个方块，显示效果为「■■■■■ 49%」。</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/31f2db3d7bbc0f05609df7ef0928a9ca.gif]]</p>
<p><strong>关联阅读：</strong><a href="https://sspai.com/post/56777">Notion 还能这么玩：手把手教你打造个性化进度条</a></p>
<h3 id="学会使用-Notion-分栏"><a href="#学会使用-Notion-分栏" class="headerlink" title="学会使用 Notion 分栏"></a>学会使用 Notion 分栏</h3><p>虽然说是介绍 Notion 分栏功能使用场景的实例，但是这里还会介绍更多串联 Database 一些 Notion 用法，能够帮助你真正地在实际使用过程中用好这项功能。</p>
<p>在 Notion 分栏功能的使用实例中，你会了解到这些内容：</p>
<ul>
<li>丰富内容排版，让文章增添一些「生气」：</li>
</ul>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/ba4a02e1f07087b4cbccef2c6f7b917c.jpg]]</p>
<ul>
<li>系统性地整合视频的笔记内容以及与多人协作翻译文档：</li>
</ul>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/3012d11284c3aa06ce85f92378819942.gif]]</p>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/da9473e0de1af5ed2a7ca717184e954e.jpg]]</p>
<ul>
<li>制作专属个性化空间，自己动手创作好看的模版：</li>
</ul>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/47334eb24183c80cb448547a9c694115.jpg]]</p>
<p>总而言之，你只需要将 Notion 想象成积木一样，你可以自由地组合其中的内容，组合它为你提供的各种 Block，这些小工具的实现其实没有你想的那么难。</p>
<p><strong>关联阅读：</strong><a href="https://sspai.com/post/57110">你也可以做出好看的排版：三个场景玩转 Notion 分栏</a></p>
<h3 id="制作个人数据库，管理订阅服务"><a href="#制作个人数据库，管理订阅服务" class="headerlink" title="制作个人数据库，管理订阅服务"></a>制作个人数据库，管理订阅服务</h3><p>这个小工具利用了 Notion 的数据库功能，让我们通过制作一个小工具，方便地管理我们的订阅服务，以便及时取消不需要的服务或者进行续费。</p>
<p>通过学习这个实例，你可以了解到这些内容：</p>
<ul>
<li>从零开始制作订阅服务管理库，包含激活码管理、素材教程管理、续费提醒功能等。</li>
<li>快速组织个人电脑配置清单。</li>
<li>Notion Database 基础使用教程。</li>
<li>Notion Database 模板使用教程。</li>
<li>Notion formula 实践。</li>
</ul>
<p>[[想%E8%A6%81%E7%8E%A9%E8%BD%AC Notion%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E8%BF%99%E4%BB%BD%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97 - %E5%B0%91%E6%95%B0%E6%B4%BE/257af0917261c6d423d1c9682a96bb44.jpg]]</p>
<p>当然，这个小工具只是作为一个 Notion 使用思路的参考，你也可以利用 Notion 的数据库功能实现其它需求，比如：</p>
<ul>
<li>管理服务器、SSL 到期、物品打折提醒等。</li>
<li>集合笔记，方便随时管理。</li>
<li>制作 CRM、邮寄清单。</li>
<li>借助 Notion 便捷的协作分享功能，提高不会编程的用户的效率。</li>
<li>……</li>
</ul>
<p>从功能介绍到应用实例，不知道你学会如何使用 Notion 了吗？如果你想了解更多关于 Notion 的使用方法和技巧，欢迎阅读少数派为你准备的 Notion 专题：</p>
<blockquote>
<p>下载少数派 <a href="https://sspai.com/page/client">客户端</a>、关注 <a href="http://sspai.com/s/KEPQ">少数派公众号</a>，了解更多有趣的应用 🚀</p>
</blockquote>
<blockquote>
<p>特惠、好用的硬件产品，尽在 <a href="https://shop549593764.taobao.com/?spm=a230r.7195193.1997079397.2.2ddc7e0bPqKQHc">少数派 sspai 官方店铺</a> 🛒</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>#notion</tag>
        <tag>#少数派</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂 JS 原型与原型链（超详细，建议收藏）</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20JS%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一文搞懂-JS-原型与原型链（超详细，建议收藏）"><a href="#一文搞懂-JS-原型与原型链（超详细，建议收藏）" class="headerlink" title="一文搞懂 JS 原型与原型链（超详细，建议收藏）"></a>一文搞懂 JS 原型与原型链（超详细，建议收藏）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个前端开发工程师，熟练掌握 JS 这门语言是必须要的。无论是日常的工作中，亦或者是出去面试找工作，JS 掌握的多深多好，很大程度上决定了你能走的多远。今天本人就来介绍一下 JS 的<code>原型</code>以及<code>原型链</code>，基于本人的一些认识。因为本人也在学习的阶段，所以如果文章中有什么不对的或者不好的地方，烦请大家指出。</p>
<h2 id="JS-原型"><a href="#JS-原型" class="headerlink" title="JS 原型"></a>JS 原型</h2><p>众所周知，JS 的复杂类型都是对象类型（<strong>Object</strong>），而 JS 不是一门完全面向对象编程的语言，所以如何涉及继承机制，就是一个问题。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>因为 JS 中没有类（<strong>Class</strong>）这个概念，所以 JS 的设计者使用了<code>构造函数</code>来实现继承机制。</p>
<blockquote>
<p>ES6 中的class可以看作只是一个语法糖，它的绝大部分的功能，ES5 都可以做到，新的class写法只是让原型的写法更加的清晰、更像面向对象编程的语法而已。下文也会进一步的说明。（摘自阮一峰的 ES6 入门）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成实例</span><br><span class="line">const p = new Person(&#x27;zhangsan&#x27;, 18);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上述代码所示，JS 通过<code>构造函数</code>来生成<code>实例</code>。但是又出现了一个新的问题，在<code>构造函数</code>中通过<code>this</code>赋值的属性或者方法，是每个实例的<code>实例属性</code>以及<code>实例方法</code>，无法共享公共属性。所以又设计出了一个<code>原型对象</code>，来存储这个<code>构造函数</code>的公共属性以及方法。</p>
<h3 id="补充知识：构造函数创建一个实例的过程"><a href="#补充知识：构造函数创建一个实例的过程" class="headerlink" title="补充知识：构造函数创建一个实例的过程"></a>补充知识：构造函数创建一个实例的过程</h3><ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（这样 this 就指向了新对象）</li>
<li>执行构造函数中的代码（为新对象添加实例属性和实例方法）</li>
<li>返回新对象</li>
</ol>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>说了这么久，终于说到了 JS 的<code>原型对象</code>了。JS 的每个函数在创建的时候，都会生成一个属性<code>prototype</code>，这个属性指向一个对象，这个对象就是此函数的<code>原型对象</code>。该<code>原型对象</code>中有个属性为<code>constructor</code>，指向该函数。这样<code>原型对象</code>和<code>它的函数</code>之间就产生了联系。</p>
<h2 id="JS-原型链"><a href="#JS-原型链" class="headerlink" title="JS 原型链"></a>JS 原型链</h2><p>讲清楚了 JS 的<code>原型对象</code>，来就是介绍 JS 的<code>原型链</code>了。既然有了<code>构造函数</code>，那么就可以通过该<code>构造函数</code>，来创建一个实例对象了。此时，完善一下我们的<code>Preson</code>构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 构造函数</span><br><span class="line">    function Preson(name, age) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 所有实例共享的公共方法</span><br><span class="line">    Preson.prototype.say = function (word) &#123;</span><br><span class="line">      console.log(`$&#123;this.name&#125;说：$&#123;word&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const p1 = new Preson(&#x27;张三&#x27;, 18); // 创建一个Person实例对象</span><br><span class="line">    p1.hasOwnProperty(&#x27;say&#x27;) // false 说明不是定义在其本身上的</span><br><span class="line">    p1.say(&#x27;hello world&#x27;); // 调用公共方法 打印：张三说：hello world</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就要思考了，为什么我们构造的<code>p1</code>这个<code>实例对象</code>，它可以调用到<code>Person</code>这个<code>构造函数</code>的<code>原型对象</code>上的方法呢？明明只有在<code>构造函数</code>内部通过<code>this</code>来赋值的属性或者方法才会被实例所继承，为什么在<code>构造函数</code>的<code>原型对象</code>上定义的<code>say</code>方法也能通过实例来调用到呢？这里就引出了<code>原型链</code>这个概念。</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>每个通过<code>构造函数</code>创建出来的<code>实例对象</code>，其本身有个属性<code>__proto__</code>，这个属性会指向该<code>实例对象</code>的<code>构造函数</code>的<code>原型对象</code>，这么说好像有点绕，我们看下图</p>
<blockquote>
<p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法 / 属性。（摘自阮一峰的 ES6 入门）</p>
</blockquote>
<p>现在我们知道了，当访问一个<code>对象</code>的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的<code>__proto__</code>隐式属性，找到它的<code>构造函数</code>的<code>原型对象</code>，如果还没有找到就会再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p>
<p><strong>注意点</strong>：如果通过<code>p1实例对象</code>的<code>__proto__</code>属性赋值，则会改变其<code>构造函数</code>的<code>原型对象</code>，从而被所有实例所共享。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 构造函数</span><br><span class="line">    function Preson(name, age) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 所有实例共享的公共方法</span><br><span class="line">    Preson.prototype.say = function (word) &#123;</span><br><span class="line">      console.log(`$&#123;this.name&#125;说：$&#123;word&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const p1 = new Preson(&#x27;张三&#x27;, 18); // 创建一个Person实例对象</span><br><span class="line">    const p2 = new Preson(&#x27;李四&#x27;, 20); // 新创建一个Proson实例对象</span><br><span class="line">    p1.say(&#x27;hello world&#x27;); // 调用公共方法</span><br><span class="line">    p1.hasOwnProperty(&#x27;say&#x27;) // false 说明不是定义在其本身上的</span><br><span class="line">    p1.__proto__.do = function () &#123;</span><br><span class="line">      console.log(&#x27;往原型对象中添加方法&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    p2.do(); // 打印出了-往原型对象中添加方法</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以，我们在开发的时候，要注意不要通过实例对象去改变其构造函数的原型对象，这样会对其他通过该构造函数生成的实例对象造成影响。</p>
</blockquote>
<p>说到这里，有的读者可能又会产生疑问了，再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找是什么意思？我们继续往下看。</p>
<h3 id="补充知识：原型链的尽头"><a href="#补充知识：原型链的尽头" class="headerlink" title="补充知识：原型链的尽头"></a>补充知识：原型链的尽头</h3><p>既然我们之前构造的<code>p1实例对象</code>有<code>__proto__</code>属性指向其<code>构造函数</code>的<code>原型对象</code>，那么该<code>构造函数</code>的<code>原型对象</code>有这个<code>__proto__</code>属性吗？如果有，那么其又指向谁呢？我们不妨打印一下。</p>
<p>我们随便创建了一个<code>A</code>的<code>构造函数</code>，通过打印它的<code>prototype</code>属性，我们可以看到，在浏览器中，它有个<code>__proto__</code>属性指向了一个<code>Object</code>对象。</p>
<p>而进一步展开后，我们会发现，该对象的<code>构造函数</code>为<code>function Object</code>，我们由此可以得知，<strong>所有的<code>原型对象</code>的<code>__proto__</code>属性都是指向<code>function Object</code>的<code>原型对象</code>。</strong> 而<code>function Object</code>的<code>原型对象</code>在上图中我们可以得知是不存在<code>__proto__</code>这个属性的，它指向了<code>null</code>。我们就得知了<code>原型链</code>的尽头是<code>null</code>。</p>
<h3 id="补充知识：所有对象的原型链"><a href="#补充知识：所有对象的原型链" class="headerlink" title="补充知识：所有对象的原型链"></a>补充知识：所有对象的原型链</h3><p>既然 JS 的复杂类型都是<code>对象</code>，那么，函数作为一个<code>对象</code>，是否也存在<code>原型链</code>呢？ 我们在浏览器中创建一个<code>构造函数</code>，打印它的<code>__proto__</code>属性，一探究竟：</p>
<p>我们可以看到，它的<code>__proto__</code>属性指向了一个<code>function Function</code>的<code>原型对象</code>，该<code>原型对象</code>为 JS 中所有函数的<code>原型对象</code>，而其<code>__proto__</code>属性也还是指向了<code>function Object</code>的<code>原型对象</code>，所以验证了<code>原型链</code>的尽头为<code>null</code>，这一说法。</p>
<p>最后，奉上神图一张，祝大家理解 JS 的<code>原型链</code></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过上面的文章，大概梳理了一下本人对于<code>原型</code>和<code>原型链</code>这一概念的理解，并且尽可能详细的阐述了各个概念的前世今生。因为本人也是个前端菜鸡，写这篇文章的目的除了让大家了解<code>原型</code>和<code>原型链</code>这一概念外，还有就是自己梳理一遍所掌握的知识。如果上文有说的不对或者不好的地方，欢迎大家提出宝贵的意见。</p>
<p>PS：下一篇准备写关于闭包的一些个人理解。 &gt; 本文由简悦 SimpRead 转码</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>事件循环（Event Loop）</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event%20Loop%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h1><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li>[[单线程]]</li>
<li>[[事件循环机制 Event Loop]]</li>
<li>[[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]]</li>
</ul>
<h1 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h1><p>JavaScript 是一种单线程的编程语言，同一时间只能做一件事，所有任务都需要排队依次完成。<br>为什么 JS 不能有多个线程呢<br>答：作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准。</p>
<p>​ 为了避免这种复杂性，因此 JS 只能是单线程。</p>
<h1 id="事件循环机制（Event-Loop）"><a href="#事件循环机制（Event-Loop）" class="headerlink" title="事件循环机制（Event Loop）"></a><a href="https://so.csdn.net/so/search?q=%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020">事件循环机制</a>（Event Loop）</h1><p>含义：事件循环分为两种, 分别是<strong>浏览器事件循环</strong>和 <strong>node.js 事件循环</strong>，JavaScript 是一门单线程语言，指主线程只有一个。<strong>Event Loop</strong> 事件循环，其实就是 JS 引擎管理事件执行的一个流程，具体由运行环境确定。目前 JS 的主要运行环境有两个，浏览器和 Node.js。</p>
<p>​ 事件循环机制告诉了我们 JS 代码的执行顺序，是指浏览器或 Node 的一种解决 JS 单线程运行时不会阻塞的一种机制。</p>
<p>浏览器的事件循环又分为<strong>同步任务和异步任务</strong></p>
<h2 id="1、同步任务与异步任务"><a href="#1、同步任务与异步任务" class="headerlink" title="1、同步任务与异步任务"></a>1、同步任务与异步任务</h2><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>含义：在主线程上排队执行的任务，只有一个任务执行完毕，才能执行后一个任务</p>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>含义：不进入主线程，而进入 “任务队列（task queue）” 的任务，只有 “任务队列” 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>分类：异步任务又分为宏任务和微任务。所有同步任务都在主线程上执行，形成一个函数调用栈（执行栈），而异步则先放到<strong>任务队列</strong>（<strong>task queue</strong>）里，任务队列又分为<strong>宏任务</strong>（<a href="https://so.csdn.net/so/search?q=macro&spm=1001.2101.3001.7020">macro</a>-task）与<strong>微任务</strong>（micro-task）。</p>
<h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务包括：script(整体代码)、setTimout、setInterval、setImmediate(node.js 环境)、I/O、UI 交互事件</p>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>微任务包括：new promise().then(回调)、MutationObserver(html5 新特新)、Object.observe(已废弃)、process.nextTick（node 环境）</p>
<p>​ <strong>若同时存在 promise 和 nextTick，则先执行 nextTick</strong></p>
<h2 id="2、执行过程"><a href="#2、执行过程" class="headerlink" title="2、执行过程"></a>2、执行过程</h2><ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（调用栈）；</li>
<li>主线程之外，还存在一个‘任务队列’（task queue），浏览器中的各种 Web API 为异步的代码提供了一个单独的运行空间，当异步的代码运行完毕以后，会将代码中的回调送入到 任务队列中（队列遵循先进先出得原则）</li>
<li>一旦主线程的栈中的所有同步任务执行完毕后，调用栈为空时系统就会将队列中的回调函数依次压入调用栈中执行，当调用栈为空时，仍然会不断循环检测任务队列中是否有代码需要执行；</li>
</ol>
<h2 id="3、执行顺序"><a href="#3、执行顺序" class="headerlink" title="3、执行顺序"></a>3、执行顺序</h2><ul>
<li>先执行同步代码，</li>
<li>遇到异步宏任务则将异步宏任务放入宏任务队列中，</li>
<li>遇到异步微任务则将异步微任务放入微任务队列中，</li>
<li>当所有同步代码执行完毕后，再将<strong>异步微任务</strong>从队列中调入主线程执行，</li>
<li>微任务执行完毕后再将异步宏任务从队列中调入主线程执行，</li>
<li>一直循环直至所有任务执行完毕。</li>
</ul>
<p>注意：当宏任务和微任务都处于 任务队列（Task Queue） 中时，<strong>微任务的优先级大于宏任务</strong>，即先将微任务执行完，再执行宏任务；</p>
<h2 id="4、举例："><a href="#4、举例：" class="headerlink" title="4、举例："></a>4、举例：</h2><p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250957873.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250957778.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;4&quot;);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&quot;8&quot;);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">        new Promise((r) =&gt; &#123;</span><br><span class="line">          console.log(&quot;5&quot;);//构造函数是同步的</span><br><span class="line">          r();</span><br><span class="line">        &#125;).then(() =&gt; &#123;</span><br><span class="line">          console.log(&quot;7&quot;);//then()是异步的，这里已经入队</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(&quot;6&quot;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line"></span><br><span class="line">      new Promise((r) =&gt; &#123;</span><br><span class="line">        console.log(&quot;1&quot;);//构造函数是同步的</span><br><span class="line">        r();</span><br><span class="line">      &#125;).then(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;3&quot;);//then()是异步的，这里已经入队</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(&quot;2&quot;);</span><br><span class="line">//输出顺序：1 2 3 4 5 6 7 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;1&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&#x27;3&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;4&#x27;);</span><br><span class="line">//输出顺序：2 4 3 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>遇到 setTimout，异步宏任务，放入宏任务队列中；</li>
<li>遇到 new Promise，Promise 在实例化的过程中所执行的代码都是同步进行的，所以输出 2；</li>
<li>而 Promise.then 中<strong>注册的回调才是异步执行</strong>的，将其放入微任务队列中</li>
<li>遇到同步任务 console.log(‘4’); 输出 4；主线程中同步任务执行完</li>
<li>从微任务队列中取出任务到主线程中，输出 3，微任务队列为空</li>
<li>从宏任务队列中取出任务到主线程中，输出 1，宏任务队列为空，结束~</li>
</ol>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  new Promise(resolve =&gt;&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;test&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;).then( () =&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">  Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;before timeout&#x27;);</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;also before timeout&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(2);</span><br><span class="line">//输出：1 2 3 before timeout also before timeout 4 test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>遇到 setTimeout，异步宏任务，将 () =&gt; {console.log(4)} 放入宏任务队列中；</li>
<li>遇到 new Promise，Promise 在实例化的过程中所执行的代码都是同步进行的，所以输出 1；</li>
<li>而 Promise.then 中注册的回调才是异步执行的，将其放入微任务队列中</li>
<li>遇到同步任务 console.log(2)，输出 2；主线程中同步任务执行完</li>
<li>从微任务队列中取出任务到主线程中，输出 3，此微任务中又有微任务，Promise.resolve().then(微任务 a).then(微任务 b)，将其依次放入微任务队列中；</li>
<li>从微任务队列中取出任务 a 到主线程中，输出 before timeout；</li>
<li>从微任务队列中取出任务 b 到主线程中，任务 b 又注册了一个微任务 c，放入微任务队列中；</li>
<li>从微任务队列中取出任务 c 到主线程中，输出 also before timeout；微任务队列为空</li>
<li>从宏任务队列中取出任务到主线程，此任务中注册了一个微任务 d，将其放入微任务队列中，接下来遇到输出 4，宏任务队列为空</li>
<li>从微任务队列中取出任务 d 到主线程 ，输出 test，微任务队列为空，结束 &gt; 本文由简悦 SimpRead 转码</li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>一文彻底学会使用 web worker</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%20web%20worker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一文彻底学会使用-web-worker"><a href="#一文彻底学会使用-web-worker" class="headerlink" title="一文彻底学会使用 web worker"></a>一文彻底学会使用 web worker</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先来聊聊单线程的 Javascript</p>
<p>众所周知，js 最初设计是运行在浏览器中的，为了防止多个线程同时操作 DOM，带来渲染冲突问题，所以 js 执行器被设计成单线程。但随着前端技术的发展，js 能力远不止如此，当我们遇到需要大量计算的场景时（比如图像处理、视频解码等），js 线程往往会被长时间阻塞，甚至造成页面卡顿，影响用户体验。为了解决单线程带来的这一弊端，Web Worker 应运而生。</p>
<h1 id="1-Web-Worker"><a href="#1-Web-Worker" class="headerlink" title="1. Web Worker"></a>1. Web Worker</h1><h2 id="1-1-Web-Worker-是什么"><a href="#1-1-Web-Worker-是什么" class="headerlink" title="1.1 Web Worker 是什么"></a>1.1 <code>Web Worker</code> 是什么</h2><p><code>Web Worker</code> 是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。</p>
<p>因为是独立的线程，Worker 线程与 js 主线程能够同时运行，互不阻塞。所以，在我们有大量运算任务时，可以把运算任务交给 Worker 线程去处理，当 Worker 线程计算完成，再把结果返回给 js 主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。</p>
<h2 id="1-2-Web-Worker-能干些什么"><a href="#1-2-Web-Worker-能干些什么" class="headerlink" title="1.2 Web Worker 能干些什么"></a>1.2 <code>Web Worker</code> 能干些什么</h2><p>虽然 Worker 线程是在浏览器环境中被唤起，但是它与当前页面窗口运行在不同的全局上下文中，我们常用的顶层对象 <code>window</code>，以及 <code>parent</code> 对象在 Worker 线程上下文中是不可用的。另外，在 Worker 线程上下文中，操作 DOM 的行为也是不可行的，<code>document</code>对象也不存在。但是，<code>location</code>和<code>navigator</code>对象可以以可读方式访问。除此之外，绝大多数 Window 对象上的方法和属性，都被共享到 Worker 上下文全局对象 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope">WorkerGlobalScope</a> 中。同样，Worker 线程上下文也存在一个顶级对象 <code>self</code>。</p>
<p>详细信息请参考：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers">Functions and classes available to Web Workers</a></p>
<h1 id="2-Web-Worker-使用"><a href="#2-Web-Worker-使用" class="headerlink" title="2. Web Worker 使用"></a>2. Web Worker 使用</h1><h2 id="2-1-创建-worker"><a href="#2-1-创建-worker" class="headerlink" title="2.1 创建 worker"></a>2.1 创建 <code>worker</code></h2><p>创建 <code>worker</code> 只需要通过 <code>new</code> 调用 <code>Worker()</code> 构造函数即可，它接收两个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const worker = new Worker(path, options);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>path</td>
<td>有效的 js 脚本的地址，必须遵守同源策略。无效的 js 地址或者违反同源策略，会抛出SECURITY_ERR 类型错误</td>
</tr>
<tr>
<td>options.type</td>
<td>可选，用以指定 worker 类型。该值可以是 classic 或 module。 如未指定，将使用默认值 classic</td>
</tr>
<tr>
<td>options.credentials</td>
<td>可选，用以指定 worker 凭证。该值可以是 omit, same-origin，或 include。如果未指定，或者 type 是 classic，将使用默认值 omit (不要求凭证)</td>
</tr>
<tr>
<td>options.name</td>
<td>可选，在 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDedicatedWorkerGlobalScope</a> 的情况下，用来表示 worker 的 scope 的一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String_6fa58bba0570d663099f0ae7ae8883ab">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2Fconflicting%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString_6fa58bba0570d663099f0ae7ae8883ab</a> 值，主要用于调试目的。</td>
</tr>
</tbody></table>
<h2 id="2-2-js-主线程与-worker-线程数据传递"><a href="#2-2-js-主线程与-worker-线程数据传递" class="headerlink" title="2.2 js 主线程与 worker 线程数据传递"></a>2.2 js 主线程与 worker 线程数据传递</h2><p>主线程与 worker 线程都是通过 <code>postMessage</code> 方法来发送消息，以及监听 <code>message</code> 事件来接收消息。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line"></span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建worker</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&#x27;message&#x27;, e =&gt; &#123; // 接收消息</span><br><span class="line">    console.log(e.data); // Greeting from Worker.js，worker线程发送的消息</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 这种写法也可以</span><br><span class="line">// myWorker.onmessage = e =&gt; &#123; // 接收消息</span><br><span class="line">//    console.log(e.data);</span><br><span class="line">// &#125;;</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(&#x27;Greeting from Main.js&#x27;); // 向 worker 线程发送消息，对应 worker 线程中的 e.data</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123; // 接收到消息</span><br><span class="line">    console.log(e.data); // Greeting from Main.js，主线程发送的消息</span><br><span class="line">    self.postMessage(&#x27;Greeting from Worker.js&#x27;); // 向主线程发送消息</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好了，一个简单 worker 线程就创建成功了。</p>
<p><code>postMessage()</code> 方法接收的参数可以是字符串、对象、数组等。具体我们在 #2.7 讨论。</p>
<p>主线程与 worker 线程之间的数据传递是传值而不是传地址。所以你会发现，即使你传递的是一个<code>Object</code>，并且被直接传递回来，接收到的也不是原来的那个值了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;);</span><br><span class="line"></span><br><span class="line">const obj = &#123;name: &#x27;小明&#x27;&#125;;</span><br><span class="line">myWorker.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    console.log(e.data === obj); // false</span><br><span class="line">&#125;);</span><br><span class="line">myWorker.postMessage(obj);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    self.postMessage(e.data); // 将接收到的数据直接返回</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-监听错误信息"><a href="#2-3-监听错误信息" class="headerlink" title="2.3 监听错误信息"></a>2.3 监听错误信息</h2><p>web worker 提供两个事件监听错误，<code>error</code> 和 <code>messageerror</code>。这两个事件的区别是:</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>error</td>
<td>当 worker 内部出现错误时触发</td>
</tr>
<tr>
<td>messageerror</td>
<td>当 message 事件接收到无法被反序列化的参数时触发</td>
</tr>
</tbody></table>
<p>监听方式跟接收消息一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建worker</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&#x27;error&#x27;, err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;);</span><br><span class="line">myWorker.addEventListener(&#x27;messageerror&#x27;, err =&gt; &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">self.addEventListener(&#x27;error&#x27;, err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;);</span><br><span class="line">self.addEventListener(&#x27;messageerror&#x27;, err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-关闭-worker-线程"><a href="#2-4-关闭-worker-线程" class="headerlink" title="2.4 关闭 worker 线程"></a>2.4 关闭 worker 线程</h2><p>worker 线程的关闭在主线程和 worker 线程都能进行操作，但对 worker 线程的影响略有不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建worker</span><br><span class="line">myWorker.terminate(); // 关闭worker</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">self.close(); // 直接执行close方法就ok了</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无论是在主线程关闭 worker，还是在 worker 线程内部关闭 worker，worker 线程当前的 Event Loop 中的任务会继续执行。至于 worker 线程下一个 Event Loop 中的任务，则会被直接忽略，不会继续执行。</p>
<p>区别是，在主线程手动关闭 worker，主线程与 worker 线程之间的连接都会被立刻停止，即使 worker 线程当前的 Event Loop 中仍有待执行的任务继续调用 <code>postMessage()</code> 方法，但主线程不会再接收到消息。</p>
<p>在 worker 线程内部关闭 worker，不会直接断开与主线程的连接，而是等 worker 线程当前的 Event Loop 所有任务执行完，再关闭。也就是说，在当前 Event Loop 中继续调用 <code>postMessage()</code> 方法，主线程还是能通过监听<code>message</code>事件收到消息的。</p>
<p>如下两个例子可以很好说明这一点：</p>
<p><strong>在主线程关闭 worker</strong></p>
<ul>
<li>worker 线程在接受到消息后，立即向主线程回复一条消息。然后利用计时器添加一个宏任务；利用 Promise 添加一个微任务；执行一个 for 循环。目的都是向主线程回复一条消息。</li>
<li>主线程在接收到消息后立即关闭 worker 线程。</li>
</ul>
<p>大家可以思考一下，主线程会接收到哪些消息呢，控制台会打印出哪些信息呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建 worker</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    console.log(e.data);</span><br><span class="line">    myWorker.terminate(); // 关闭 worker</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(&#x27;Greeting from Main.js&#x27;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    postMessage(&#x27;Greeting from Worker&#x27;);</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;setTimeout run&#x27;);</span><br><span class="line">        postMessage(&#x27;Greeting from SetTimeout&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;Promise run&#x27;);</span><br><span class="line">        postMessage(&#x27;Greeting from Promise&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; 1001; i++) &#123;</span><br><span class="line">        if (i === 1000) &#123;</span><br><span class="line">            console.log(&#x27;Loop run&#x27;);</span><br><span class="line">            postMessage(&#x27;Greeting from Loop&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<ul>
<li>主线程只会接收到 worker 线程第一次通过 <code>postMessage()</code> 发送的消息，后面的消息不会接收到；</li>
<li>worker 线程当前 Event Loop 里的任务会继续执行，包括微任务；</li>
<li>worker 线程里 setTimeout 创建的下一个 Event Loop 任务队列没有执行。</li>
</ul>
<p><strong>在 worker 线程内部关闭 worker</strong></p>
<p>对上述例子稍作修改，将关闭 worker 的事件放到 worker 线程内部，大家觉得又会打印出什么呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建 worker</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    console.log(e.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(&#x27;Greeting from Main.js&#x27;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    postMessage(&#x27;Greeting from Worker&#x27;);</span><br><span class="line"></span><br><span class="line">    self.close(); // 关闭 worker</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;setTimeout run&#x27;);</span><br><span class="line">        postMessage(&#x27;Greeting from SetTimeout&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;Promise run&#x27;);</span><br><span class="line">        postMessage(&#x27;Greeting from Promise&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; 1001; i++) &#123;</span><br><span class="line">        if (i === 1000) &#123;</span><br><span class="line">            console.log(&#x27;Loop run&#x27;);</span><br><span class="line">            postMessage(&#x27;Greeting from Loop&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p>与在主线程关闭不同的是，worker 线程当前的 Event Loop 任务队列中的 <code>postMessage()</code> 事件都会被主线程监听到。</p>
<h2 id="2-5-Worker-线程引用其他-js-文件"><a href="#2-5-Worker-线程引用其他-js-文件" class="headerlink" title="2.5 Worker 线程引用其他 js 文件"></a>2.5 Worker 线程引用其他 js 文件</h2><p>总有一些场景，需要放到 worker 进程去处理的任务很复杂，需要大量的处理逻辑，我们当然不想把所有代码都塞到 <code>worker.js</code> 里，那样就太糟糕了。不出意料，web worker 为我们提供了解决方案，我们可以在 worker 线程中利用 <code>importScripts()</code> 方法加载我们需要的 js 文件，而且，通过此方法加载的 js 文件<strong>不受同源策略约束</strong>！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// utils.js</span><br><span class="line">const add = (a, b) =&gt; a + b;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">// 使用方法：importScripts(path1, path2, ...);</span><br><span class="line"></span><br><span class="line">importScripts(&#x27;./utils.js&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(add(1, 2)); // log 3</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-6-ESModule-模式"><a href="#2-6-ESModule-模式" class="headerlink" title="2.6 ESModule 模式"></a>2.6 ESModule 模式</h2><p>还有一些场景，当你开启一个新项目，正高兴的用 <code>importScripts()</code> 导入 js 文件时发现， <code>importScripts()</code> 方法执行失败。仔细一看，原来是新项目的 js 文件都用的是 ESModule 模式。难道要把引用到的文件都改一遍吗？当然不用，还记得上文提到初始化 worker 时的第二个可选参数吗，我们可以直接使用 module 模式初始化 worker 线程！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const worker = new Worker(&#x27;/worker.js&#x27;, &#123;</span><br><span class="line">    type: &#x27;module&#x27;  // 指定 worker.js 的类型</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// utils.js</span><br><span class="line">export default add = (a, b) =&gt; a + b;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">import add from &#x27;./utils.js&#x27;; // 导入外部js</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    postMessage(e.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(1, 2); // log 3</span><br><span class="line"></span><br><span class="line">export default self; // 只需把顶级对象self暴露出去即可</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-7-主线程和-worker-线程可传递哪些类型数据"><a href="#2-7-主线程和-worker-线程可传递哪些类型数据" class="headerlink" title="2.7 主线程和 worker 线程可传递哪些类型数据"></a>2.7 主线程和 worker 线程可传递哪些类型数据</h2><p>很多场景，在调用某些方法时，我们将一些自定义方法当作参数传入。但是，当你使用 <code>postMessage()</code> 方法时这么做，将会导致 <code>DATA_CLONE_ERR</code> 错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建worker</span><br><span class="line"></span><br><span class="line">const fun = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(fun); // Error：Failed to execute &#x27;postMessage&#x27; on &#x27;Worker&#x27;: ()=&gt;&#123;&#125; could not be cloned.</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，使用 <code>postMessage()</code> 方法传递消息，可以传递哪些数据？</p>
<p><code>postMessage()</code> 传递的数据可以是由<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/Guide/DOM/The_structured_clone_algorithm">结构化克隆</a>算法处理的任何值或 JavaScript 对象，包括循环引用。</p>
<p>结构化克隆算法<strong>不能处理</strong>的数据：</p>
<ul>
<li><code>Error</code> 以及 <code>Function</code> 对象；</li>
<li>DOM 节点</li>
<li>对象的某些特定参数不会被保留<ul>
<li><code>RegExp</code> 对象的 <code>lastIndex</code> 字段不会被保留</li>
<li>属性描述符，setters 以及 getters（以及其他类似元数据的功能）同样不会被复制。例如，如果一个对象用属性描述符标记为 read-only，它将会被复制为 read-write</li>
<li>原形链上的属性也不会被追踪以及复制。</li>
</ul>
</li>
</ul>
<p>结构化克隆算法<strong>支持</strong>的数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures%23%25E5%258E%259F%25E5%25A7%258B%25E5%2580%25BC">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FData_structures%23%25E5%258E%259F%25E5%25A7%258B%25E5%2580%25BC</a></td>
<td>symbols 除外</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FBoolean</a> 对象</td>
<td></td>
</tr>
<tr>
<td>String 对象</td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FDate</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FRegExp</a></td>
<td>lastIndex 字段不会被保留。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/File">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFile</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FileList">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFileList</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArrayBuffer</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FTypedArray</a></td>
<td>这基本上意味着所有的 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FTyped_arrays</a> ，如 Int32Array 等。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FImageData</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject</a></td>
<td>仅包括普通对象（如对象字面量）</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FMap</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSet</a></td>
<td></td>
</tr>
</tbody></table>
<h1 id="3-SharedWorker"><a href="#3-SharedWorker" class="headerlink" title="3.SharedWorker"></a>3.SharedWorker</h1><p><strong>SharedWorker</strong> 是一种特殊类型的 Worker，可以被多个浏览上下文访问，比如多个 windows，iframes 和 workers，但这些浏览上下文必须同源。它们实现于一个不同于普通 worker 的接口，具有不同的全局作用域：<code>[SharedWorkerGlobalScope](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FSharedWorkerGlobalScope)</code> ，但是继承自 <code>[WorkerGlobalScope](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FSharedWorkerGlobalScope%23properties_inherited_from_workerglobalscope)</code></p>
<p><code>SharedWorker</code> 线程的创建和使用跟 <code>worker</code> 类似，事件和方法也基本一样。 不同点在于，主线程与 <code>SharedWorker</code> 线程是通过 <code>[MessagePort](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FMessagePort)</code>建立起链接，数据通讯方法都挂载在<code>SharedWorker.port</code>上。</p>
<p>值得注意的是，如果你采用 <code>addEventListener</code> 来接收 <code>message</code> 事件，那么在主线程初始化<code>SharedWorker()</code> 后，还要调用 <code>SharedWorker.port.start()</code> 方法来手动开启端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new SharedWorker(&#x27;./sharedWorker.js&#x27;);</span><br><span class="line"></span><br><span class="line">myWorker.port.start(); // 开启端口</span><br><span class="line"></span><br><span class="line">myWorker.port.addEventListener(&#x27;message&#x27;, msg =&gt; &#123;</span><br><span class="line">    console.log(msg.data);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是，如果采用 <code>onmessage</code> 方法，则默认开启端口，不需要再手动调用<code>SharedWorker.port.start()</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new SharedWorker(&#x27;./sharedWorker.js&#x27;);</span><br><span class="line"></span><br><span class="line">myWorker.port.onmessage = msg =&gt; &#123;</span><br><span class="line">    console.log(msg.data);</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上两种方式效果是一样的，具体信息请参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort">MessagePort</a>。</p>
<p>由于 <code>SharedWorker</code> 是被多个页面共同使用，那么除了与各个页面之间的数据通讯是独立的，同一个<code>SharedWorker</code> 线程上下文中的其他资源都是共享的。基于这一点，很容易实现不同页面之间的数据通讯。</p>
<h2 id="一个利用SharedWorker实现多页面数据共享的例子"><a href="#一个利用SharedWorker实现多页面数据共享的例子" class="headerlink" title="一个利用SharedWorker实现多页面数据共享的例子"></a>一个利用<code>SharedWorker</code>实现多页面数据共享的例子</h2><ol>
<li>index 页面的 add 按钮，每点击一次，向 sharedWorker 发送一次 add 数据，页面 count 增加 1</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;index page&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;index page: &lt;/p&gt;</span><br><span class="line">        count: &lt;span id=&quot;container&quot;&gt;0&lt;/span&gt;</span><br><span class="line">        &lt;button id=&quot;add&quot;&gt;add&lt;/button&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        // 利用iframe加载</span><br><span class="line">        &lt;iframe src=&quot;./iframe.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        if (!!window.SharedWorker) &#123;</span><br><span class="line">            const container = document.getElementById(&#x27;container&#x27;);</span><br><span class="line">            const add = document.getElementById(&#x27;add&#x27;);</span><br><span class="line"></span><br><span class="line">            const myWorker = new SharedWorker(&#x27;./sharedWorker.js&#x27;);</span><br><span class="line"></span><br><span class="line">            myWorker.port.start();</span><br><span class="line"></span><br><span class="line">            myWorker.port.addEventListener(&#x27;message&#x27;, msg =&gt; &#123;</span><br><span class="line">                container.innerText = msg.data;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            add.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">                myWorker.port.postMessage(&#x27;add&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>iframe 页面的 reduce 按钮，每点击一次，向 sharedWorker 发送一次 reduce 数据，页面 count 减少 1</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// iframe.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;iframe page&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;iframe page: &lt;/p&gt;</span><br><span class="line">        count: &lt;span id=&quot;container&quot;&gt;0&lt;/span&gt;</span><br><span class="line">        &lt;button id=&quot;reduce&quot;&gt;reduce&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        if (!!window.SharedWorker) &#123;</span><br><span class="line">            const container = document.getElementById(&#x27;container&#x27;);</span><br><span class="line">            const reduce = document.getElementById(&#x27;reduce&#x27;);</span><br><span class="line"></span><br><span class="line">            const myWorker = new SharedWorker(&#x27;./sharedWorker.js&#x27;);</span><br><span class="line"></span><br><span class="line">            myWorker.port.start();</span><br><span class="line"></span><br><span class="line">            myWorker.port.addEventListener(&#x27;message&#x27;, msg =&gt; &#123;</span><br><span class="line">                container.innerText = msg.data;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            reduce.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">                myWorker.port.postMessage(&#x27;reduce&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>sharedWorker 在接收到数据后，根据数据类型处理 num 计数，然后返回给每个已连接的主线程。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// sharedWorker.js</span><br><span class="line"></span><br><span class="line">let num = 0;</span><br><span class="line">const workerList = [];</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;connect&#x27;, e =&gt; &#123;</span><br><span class="line">    const port = e.ports[0];</span><br><span class="line">    port.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">        num += e.data === &#x27;add&#x27; ? 1 : -1;</span><br><span class="line">        workerList.forEach(port =&gt; &#123; // 遍历所有已连接的part，发送消息</span><br><span class="line">            port.postMessage(num);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    port.start();</span><br><span class="line">    workerList.push(port); // 存储已连接的part</span><br><span class="line">    port.postMessage(num); // 初始化</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果可以发现，index 页面和 iframe 页面的 count 始终保持一致，实现了多个页面数据同步。</p>
<h2 id="sharedWorker调试"><a href="#sharedWorker调试" class="headerlink" title="sharedWorker调试"></a><code>sharedWorker</code>调试</h2><p>在 <code>sharedWorker</code> 线程里使用 <code>console</code> 打印信息，不会出现在主线程的的控制台中。如果你想调试 <code>sharedWorker</code>，需要在 Chrome 浏览器输入 <a href="https://link.juejin.cn/?target=">chrome://inspect/</a> ，这里能看到所有正在运行的 <code>sharedWorker</code>，然后开启一个独立的 dev-tool 面板。</p>
<h1 id="4-兼容性"><a href="#4-兼容性" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h1><p>数据统计于 2022-07</p>
<ol>
<li>web workers</li>
</ol>
<p>可以看出，web workers 已经被大多数浏览器支持，使用上基本不用考虑兼容问题。</p>
<ol>
<li>sharedWorker</li>
</ol>
<p>sharedWorker 在 Safari 以及移动端的兼容性不是很好，使用时还需注意。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>其实，除了 <code>worker</code> 和 <code>sharedWorker</code> 外，还有 <code>ServiceWorker</code>。它一般作为 Web 应用程序、浏览器和网络之间的代理服务，旨在创建有效的离线体验，拦截网络请求，并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。使用方法本文不作详细介绍，有兴趣可自行查看 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker">ServiceWorker</a></p>
<p>好了，以上就是本期全部内容，欢迎交流讨论！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Worker">Worker</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">SharedWorker</a></li>
<li><a href="https://juejin.cn/post/6844904198639714311">你不知道的 Web Workers</a></li>
</ul>
<blockquote>
<p>本文原作者 JackTian，欢迎交流讨论！ 本文由简悦 SimpRead 转码</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>BLOB 详解</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/BLOB%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BLOB-详解"><a href="#BLOB-详解" class="headerlink" title="BLOB 详解"></a>BLOB 详解</h1><p><code>BLOB</code>是<code>Binary Large Object</code>的缩写，意为 “大的二进制对象”。</p>
<p>《JavaScript 权威指南》中对 BLOB 的描述：</p>
<blockquote>
<p>A Blob is an opaque reference to, or handle for, a chunk of data.<br>Blobs oten represent chunks of data from an external source such as a local file, a URL, or a database.</p>
</blockquote>
<p>BLOB 的两个特点：</p>
<ul>
<li>large: Blob 表示巨大的数据块，如视频文件</li>
<li>opaque(不透明): 我们对 BLOB 可以做到操作仅限于设置字节长度、获取 MIME 类型、截取更小的 BLOB。</li>
</ul>
<h2 id="获取-Blob-的方式"><a href="#获取-Blob-的方式" class="headerlink" title="获取 Blob 的方式:"></a>获取 Blob 的方式:</h2><h3 id="1-Blob-支持结构化克隆算法（structured-clone-algorithm），所以可以通过消息事件从另外一个窗口或线程中获取-blob-对象"><a href="#1-Blob-支持结构化克隆算法（structured-clone-algorithm），所以可以通过消息事件从另外一个窗口或线程中获取-blob-对象" class="headerlink" title="1. Blob 支持结构化克隆算法（structured clone algorithm），所以可以通过消息事件从另外一个窗口或线程中获取 blob 对象"></a>1. Blob 支持结构化克隆算法（structured clone algorithm），所以可以通过消息事件从另外一个窗口或线程中获取 blob 对象</h3><h3 id="2-从客户端数据库取出-blob"><a href="#2-从客户端数据库取出-blob" class="headerlink" title="2. 从客户端数据库取出 blob"></a>2. 从客户端数据库取出 blob</h3><h3 id="3-通过-http-从网络上下载-blob"><a href="#3-通过-http-从网络上下载-blob" class="headerlink" title="3. 通过 http 从网络上下载 blob"></a>3. 通过 http 从网络上下载 blob</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getBlob(url, callback)&#123;</span><br><span class="line">    let xhr = new XMLHTTPRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.responseType = &quot;blob&quot;;</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">        callback(xhr.response); // 注意，是 .response 而不是 .responseText</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果下载的blob很大，可以使用 onprogress 获取下载进度</span><br><span class="line">    xhr.send(null);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-通过BlobBuilder创建新的-blob-对象"><a href="#4-通过BlobBuilder创建新的-blob-对象" class="headerlink" title="4. 通过BlobBuilder创建新的 blob 对象"></a>4. 通过<code>BlobBuilder</code>创建新的 blob 对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bb = new BlobBuilder();</span><br><span class="line">bb.append(&#x27;this blob contains this text and 10 big-endian 32-bit signed ints.&#x27;); // 写入字符串</span><br><span class="line">bb.append(&#x27;\0&#x27;); // 写入空字符，表示字符串已结束</span><br><span class="line">var arraybuffer = new ArrayBuffer(4*10);</span><br><span class="line">var dataView = new DataView(arrayBuffer);</span><br><span class="line">for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">    dataView.setInt32(i*4, i);</span><br><span class="line">&#125;</span><br><span class="line">bb.append(arrayBuffer); // 写入ArrayBuffer</span><br><span class="line">var blob = bb.getBlob(&#x27;x-optional/mime-type-here&#x27;); // 获取blob，并指定mime类型</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-客户端-JS-中的File对象是-BLob-的子类型。File-是一个有名称（name）和修改日期（lastModifiedDate）属性的-Blob-数据。可以通过-lt-input-type-quot-file-quot-gt-元素标签或者拖拽接口获取-File-对象。"><a href="#5-客户端-JS-中的File对象是-BLob-的子类型。File-是一个有名称（name）和修改日期（lastModifiedDate）属性的-Blob-数据。可以通过-lt-input-type-quot-file-quot-gt-元素标签或者拖拽接口获取-File-对象。" class="headerlink" title="5. 客户端 JS 中的File对象是 BLob 的子类型。File 是一个有名称（name）和修改日期（lastModifiedDate）属性的 Blob 数据。可以通过&lt;input type=&quot;file&quot;&gt;元素标签或者拖拽接口获取 File 对象。"></a>5. 客户端 JS 中的<code>File</code>对象是 BLob 的子类型。File 是一个有名称（name）和修改日期（lastModifiedDate）属性的 Blob 数据。可以通过<code>&lt;input type=&quot;file&quot;&gt;</code>元素标签或者拖拽接口获取 File 对象。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; id=&quot;ele&quot;&gt;</span><br><span class="line"></span><br><span class="line">const selectedFiles = document.getElementById(&quot;ele&quot;).files</span><br><span class="line">// files属性是的值是一个File对象数组，包含用户选择的0个或多个文件的file对象。</span><br><span class="line">for (let i = 0; i &lt; selectedFiles.length; i++) &#123;</span><br><span class="line">    const f = selectedFiles[i]</span><br><span class="line">    console.log(f.name, f.lastModifiedDate)</span><br><span class="line">    console.log(f.size, f.type) // Blob对象的属性</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对-Blob-对象可做如下操作"><a href="#对-Blob-对象可做如下操作" class="headerlink" title="对 Blob 对象可做如下操作:"></a>对 Blob 对象可做如下操作:</h2><h3 id="1-创建-Blob-URL"><a href="#1-创建-Blob-URL" class="headerlink" title="1. 创建 Blob URL"></a>1. 创建 Blob URL</h3><p>Blob url 是指向存储在浏览器缓存或磁盘中的 blob 的一个引用。</p>
<p>通过<code>createObjectURL()</code>获取指向 Blob 数据的 url <code>blob://</code>，并且在 DOM、css 中使用 blob url，用法和普通的 url 一样。</p>
<p>Blob URL 受同源策略限制，只有在同源的 document 中是合法的。</p>
<p>Blob URL 不是不变的，创建 Blob URL 的 document 被用户关闭后，Blob URL 就会变成无效的。</p>
<p><code>blob://URL</code>工作方式和<code>http://URL</code>类似，当请求<code>blob://URL</code>时浏览器行为和 http 请求相同。如果请求的 blob url 不再合法，浏览器必须返回 404（Not Found）状态码。当请求不同源的 blob url 时，浏览器必须返回 403（Not Allowed）。 Blob URL 只允许通过 <code>GET</code> 请求，请求成功需要返回状态码 200，并且<code>response.header.Content-Type = Blob.type</code></p>
<p>下面的代码是通过 blob url 预览拖拽到指定区域的图片文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            // 处理浏览器兼容问题</span><br><span class="line">            var getBlobURL = (window.URL &amp;&amp; URL.createObjectURL.bind(URL)) ||</span><br><span class="line">                (window.webkitURL &amp;&amp; webkitURL.createObjectURL.bind(URL)) ||</span><br><span class="line">                window.createObjectURL;</span><br><span class="line">            // 释放之前通过createObjectURL创建的对象</span><br><span class="line">            var revokeBlobURL = (window.URL &amp;&amp; URL.revokeObjectURL.bind(URL)) ||</span><br><span class="line">                (window.webkitURL &amp;&amp; webkitURL.revokeObjectURL.bind(URL)) ||</span><br><span class="line">                window.revokeObjectURL;</span><br><span class="line"></span><br><span class="line">            window.onload = function()&#123;</span><br><span class="line">                var droptarget = document.getElementById(&#x27;droptarget&#x27;);</span><br><span class="line">                droptarget.ondragenter = function (e) &#123;</span><br><span class="line">                    var types = e.dataTransfer.types;</span><br><span class="line">                    if (!types ||</span><br><span class="line">                        (types.contains &amp;&amp; types.contains(&#x27;Files&#x27;)) ||</span><br><span class="line">                        (types.indexOf &amp;&amp; types.indexOf(&#x27;Files&#x27;) !== -1)</span><br><span class="line">                    )&#123;</span><br><span class="line">                        droptarget.classList.add(&#x27;active&#x27;);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                droptarget.ondragleave = function () &#123;</span><br><span class="line">                    droptarget.classList.remove(&#x27;active&#x27;);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                droptarget.ondragover = function(e) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                droptarget.ondrop = function(e) &#123;</span><br><span class="line">                    var files = e.dataTransfer.files;</span><br><span class="line">                    for(var i=0; i&lt;files.length; i++)&#123;</span><br><span class="line">                        var type = files[i].type;</span><br><span class="line">                        if (type.substring(0, 6) !== &#x27;image/&#x27;) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        var img = document.createElement(&#x27;img&#x27;);</span><br><span class="line">                        img.src = getBlobURL(files[i]);</span><br><span class="line">                        img.onload = function () &#123;</span><br><span class="line">                            this.width = 100;</span><br><span class="line">                            document.body.append(this);</span><br><span class="line">                            revokeBlobURL(this.src); // 防止内存泄漏</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    droptarget.classList.remove(&#x27;active&#x27;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #droptarget &#123;border: solid black 2px; width: 200px; height: 200px;&#125;</span><br><span class="line">            #droptarget.active &#123;border: solid red 4px;&#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;droptarget&quot;&gt;Drop Files Here&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>postMessage()</code>在窗口和工作进程间传输 blob 数据</li>
<li>将 blob 存储在客户端数据库</li>
<li>通过 XMLHTTPRequest 的<code>send()</code>方法将 blob 上传到服务器</li>
</ol>
<h3 id="5-FileReader对象的异步接口以string或ArrayBuffer的形式提取-blob-对象的内容。"><a href="#5-FileReader对象的异步接口以string或ArrayBuffer的形式提取-blob-对象的内容。" class="headerlink" title="5. FileReader对象的异步接口以string或ArrayBuffer的形式提取 blob 对象的内容。"></a>5. <code>FileReader</code>对象的异步接口以<code>string</code>或<code>ArrayBuffer</code>的形式提取 blob 对象的内容。</h3><p>因为 Blob 的体积比较大，所有访问磁盘上的 blob 的相关 API 都是异步的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function readfile(f)&#123;</span><br><span class="line">    var reader = new FileReader();</span><br><span class="line">    reader.readAsText(f);</span><br><span class="line">    reader.onload = function () &#123;</span><br><span class="line">        var text = reader.result;</span><br><span class="line">        console.log(&#x27;file content: &#x27;, text);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onerror = function(e)&#123;</span><br><span class="line">        console.log(&#x27;Error&#x27;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>Filesystem API</code>和<code>FileWriter</code>对象将 Blob 对象写到本地文件，相关接口浏览器暂不支持。</li>
</ol>
<aside>
💡 BLOB 是 Binary Large Object 的缩写，意为“大的二进制对象”。《JavaScript 权威指南》中对 BLOB 的描述：“一个 Blob 是一个不透明的引用或句柄，指向一块数据。Blob 通常表示来自外部源（如本地文件、URL 或数据库）的数据块。”BLOB 的两个特点是：大（Blob 表示巨大的数据块，如视频文件）和不透明（我们对 BLOB 的操作仅限于设置字节长度、获取 MIME 类型、截取更小的 BLOB）。获取 Blob 的方式有：支持结构化克隆算法（structured clone algorithm），从客户端数据库取出 blob，通过 HTTP 从网络上下载 blob，通过 BlobBuilder 创建新的 blob 对象，以及客户端 JS 中的 File 对象是 Blob 的子类型。对 Blob 对象可做的操作有：创建 Blob URL，通过 createObjectURL() 获取指向 Blob 数据的 URL `blob://`，并且在 DOM、CSS 中使用 blob URL，用法和普通的 URL 一样。

</aside>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Portainer安装</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Docker/Portainer%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Portainer安装"><a href="#Portainer安装" class="headerlink" title="Portainer安装"></a>Portainer安装</h1><ol>
<li><code>docker pull portainer/portainer-ce:latest</code></li>
<li><code>docker run -d  --name portainer -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /app/portainer_data:/data --restart always --privileged**=**true portainer/portainer-ce:latest</code></li>
</ol>
<p><a href="https://www.portainer.io/">Powerful container management software for Platform Teams, DevOps, Dev</a></p>
<p>Portainer官网</p>
<p>快速排序算法是一种分治算法，它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>以下是 Java 语言实现的快速排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void quickSort(int[] arr, int low, int high) &#123;</span><br><span class="line">    if (arr == null || arr.length == 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (low &gt;= high)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 取中间值</span><br><span class="line">    int middle = low + (high - low) / 2;</span><br><span class="line">    int pivot = arr[middle];</span><br><span class="line"></span><br><span class="line">    // 将数组分为两部分</span><br><span class="line">    int i = low, j = high;</span><br><span class="line">    while (i &lt;= j) &#123;</span><br><span class="line">        // 将比中间值小的移到左边</span><br><span class="line">        while (arr[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将比中间值大的移到右边</span><br><span class="line">        while (arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (i &lt;= j) &#123;</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归排序子数组</span><br><span class="line">    if (low &lt; j)</span><br><span class="line">        quickSort(arr, low, j);</span><br><span class="line"></span><br><span class="line">    if (high &gt; i)</span><br><span class="line">        quickSort(arr, i, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Vue+Vite静态资产引入打包</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/Vue+Vite%E9%9D%99%E6%80%81%E8%B5%84%E4%BA%A7%E5%BC%95%E5%85%A5%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue-Vite静态资产引入打包"><a href="#Vue-Vite静态资产引入打包" class="headerlink" title="Vue+Vite静态资产引入打包"></a>Vue+Vite静态资产引入打包</h1><ol>
<li><p>CSS中引入</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">url(<span class="string">&quot;相对路径“)</span></span><br></pre></td></tr></table></figure></li>
<li><p>JS中引入</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> URL(<span class="string">&quot;相对路径&quot;</span>,<span class="keyword">import</span>.meta.url).href</span><br></pre></td></tr></table></figure></li>
<li><p>HTML中引入</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;@/....../...&quot;</span></span><br></pre></td></tr></table></figure>

 <aside>
 💡 需要注意的是当使用`@`引入视频音频文件时路径要写在`<source>`标签中

 </aside></li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3+Vite引入Sass</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/Vue3+Vite%E5%BC%95%E5%85%A5Sass/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue3-Vite引入Sass"><a href="#Vue3-Vite引入Sass" class="headerlink" title="Vue3+Vite引入Sass"></a>Vue3+Vite引入Sass</h1><p>全局：直接main.js引入就行</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局引入</span></span><br><span class="line"><span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">scss</span>: &#123;</span><br><span class="line">        <span class="comment">/**如果引入多个文件，可以使用</span></span><br><span class="line"><span class="comment">       * &#x27;<span class="doctag">@import </span>&quot;@/assets/scss/globalVariable1.scss&quot;;</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@import</span>&quot;@/assets/scss/globalVariable2.scss&quot;;&#x27;</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">        additionalData: <span class="string">&#x27;@import &quot;@/style/globalVar.scss&quot;;&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>局部</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按需引入并使用</span></span><br><span class="line">&lt;style scoped lang=<span class="string">&quot;scss&quot;</span>&gt;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&quot;@/style/globalMixin.scss&quot;</span>;</span><br><span class="line">.test&#123;</span><br><span class="line">  <span class="attr">width</span>: 650px;</span><br><span class="line">  height: 60px;</span><br><span class="line">  font-size: $font-size-normal;</span><br><span class="line">  background-color: $bg-color;</span><br><span class="line">  @include box-shadow;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>组件事件</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h1><p>在子组件的模板字符串中，可以直接使用$emit触发自定义事件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;$emit(&#x27;someEvent&#x27;)&quot;</span>&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>在父组件中通过v-on(简写为@)来监听事件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent @someEvent=<span class="string">&quot;callback&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>


<p>💡 在js中触发事件提交使用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">const</span> emit = defineEmits([<span class="string">&#x27;inFocus&#x27;</span>, <span class="string">&#x27;submit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buttonClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  emit(<span class="string">&#x27;submit&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>获取Dom元素</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/%E8%8E%B7%E5%8F%96Dom%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="获取Dom元素"><a href="#获取Dom元素" class="headerlink" title="获取Dom元素"></a>获取Dom元素</h1><p>给Dom元素或组件设置ref属性</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;audio ref=<span class="string">&quot;audio1&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;@/audios/where_do_i_start.mp3&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Page2</span> <span class="attr">ref</span>=<span class="string">&quot;page2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Page2</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>通过引入ref获取对应元素</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> audio1 = ref(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//变量名要与元素指定的ref的值相同</span></span><br></pre></td></tr></table></figure>

<p>通过<code>audio1.value</code>获取dom元素，获取组件的dom元素要通过<code>page2.value.**$el**</code></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>直接运行vue项目并访问</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Server/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8Cvue%E9%A1%B9%E7%9B%AE%E5%B9%B6%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="直接运行vue项目并访问"><a href="#直接运行vue项目并访问" class="headerlink" title="直接运行vue项目并访问"></a>直接运行vue项目并访问</h1><ol>
<li>先安装node 直接用宝塔面板的node工具安装</li>
<li>配置vite.config.js</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">server</span>:&#123;</span><br><span class="line">	<span class="attr">port</span>:<span class="string">&#x27;指定端口&#x27;</span>,</span><br><span class="line">	<span class="attr">host</span>:<span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>关闭防火墙，开放对应端口</li>
<li><code>npm run dev</code></li>
<li>通过公网ip加端口号访问</li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Server</category>
      </categories>
  </entry>
  <entry>
    <title>Docker+Jenkins+Nginx+Vue</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Server/Docker+Jenkins+Nginx+Vue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker-Jenkins-Nginx-Vue"><a href="#Docker-Jenkins-Nginx-Vue" class="headerlink" title="Docker+Jenkins+Nginx+Vue"></a>Docker+Jenkins+Nginx+Vue</h1><ol>
<li><p>安装Docker</p>
<p> 直接宝塔面板安装</p>
</li>
<li><p>docker安装Jenkins</p>
</li>
</ol>
<p>使用docker-compose安装（注意开放相关端口）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services</span>:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins:latest</span><br><span class="line">    <span class="attr">container_name</span>: jenkins</span><br><span class="line">    <span class="attr">restart</span>: always</span><br><span class="line">    <span class="attr">networks</span>:</span><br><span class="line">      - devops</span><br><span class="line">    <span class="attr">volumes</span>:</span><br><span class="line">      - jenkins-data:<span class="regexp">/var/</span>jenkins_home</span><br><span class="line">      - <span class="regexp">/var/</span>run/docker.sock:<span class="regexp">/var/</span>run/docker.sock</span><br><span class="line">    <span class="attr">ports</span>:</span><br><span class="line">      - <span class="string">&quot;9001:8080&quot;</span></span><br><span class="line">      - <span class="string">&quot;9002:50000&quot;</span></span><br><span class="line">    <span class="attr">healthcheck</span>:</span><br><span class="line">      test: [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;healthcheck.sh&quot;</span>, <span class="string">&quot;||&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">      <span class="attr">interval</span>: 30s</span><br><span class="line">      <span class="attr">timeout</span>: 10s</span><br><span class="line">      <span class="attr">retries</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">networks</span>:</span><br><span class="line">  devops:</span><br><span class="line">    driver: bridge</span><br><span class="line"><span class="attr">volumes</span>:</span><br><span class="line">  jenkins-data:</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>docker安装Nginx</li>
</ol>
<p>使用docker-compose安装（注意开放相关端口）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services</span>:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins:latest</span><br><span class="line">    <span class="attr">container_name</span>: jenkins</span><br><span class="line">    <span class="attr">restart</span>: always</span><br><span class="line">    <span class="attr">networks</span>:</span><br><span class="line">      - devops</span><br><span class="line">    <span class="attr">volumes</span>:</span><br><span class="line">      - jenkins-data:<span class="regexp">/var/</span>jenkins_home</span><br><span class="line">      - <span class="regexp">/var/</span>run/docker.sock:<span class="regexp">/var/</span>run/docker.sock</span><br><span class="line">    <span class="attr">ports</span>:</span><br><span class="line">      - <span class="string">&quot;9001:8080&quot;</span></span><br><span class="line">      - <span class="string">&quot;9002:50000&quot;</span></span><br><span class="line">    <span class="attr">healthcheck</span>:</span><br><span class="line">      test: [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;healthcheck.sh&quot;</span>, <span class="string">&quot;||&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">      <span class="attr">interval</span>: 30s</span><br><span class="line">      <span class="attr">timeout</span>: 10s</span><br><span class="line">      <span class="attr">retries</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">networks</span>:</span><br><span class="line">  devops:</span><br><span class="line">    driver: bridge</span><br><span class="line"><span class="attr">volumes</span>:</span><br><span class="line">  jenkins-data:</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>配置Jenkins</p>
<p> 配置gitee,配置node,创建Jenkins项目</p>
</li>
<li><p>Nginx的html目录映射到Jenkins的workspace的vue build生成的dist目录</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">/<span class="keyword">var</span>/lib/docker/volumes/2e54334c0a5ce2e3e5a5845df3ab3ada_jenkins-data/_data/workspace/BIRTHDAY/dist:<span class="regexp">/usr/</span>share/nginx/html</span><br><span class="line"></span><br><span class="line">jenkins-data:<span class="regexp">/var/</span>jenkins_home</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Server</category>
      </categories>
  </entry>
  <entry>
    <title>Neovim安装教程</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vim/Neovim%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Neovim安装教程"><a href="#Neovim安装教程" class="headerlink" title="Neovim安装教程"></a>Neovim安装教程</h1><h1 id="1-下载Neovim的exe文件"><a href="#1-下载Neovim的exe文件" class="headerlink" title="1. 下载Neovim的exe文件"></a>1. 下载Neovim的exe文件</h1><p>直接官网下载</p>
<h1 id="2-安装vim-plug"><a href="#2-安装vim-plug" class="headerlink" title="2. 安装vim-plug"></a>2. 安装vim-plug</h1><p>复制<a href="https://github.com/junegunn/vim-plug">plug.vim</a>到nvim的安装路径下的share\nvim\runtime\autoload文件夹下</p>
<p><a href="Neovim%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%20ee7c6333e872477fafe27fdddae6b324/plug.vim">plug.vim</a></p>
<h1 id="3-新建init-vim文件"><a href="#3-新建init-vim文件" class="headerlink" title="3. 新建init.vim文件"></a>3. 新建init.vim文件</h1><p>在C:\Users\当前用户\AppData\Local\nvim下新建init.vim文</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">call plug#begin(<span class="string">&#x27;D:\Softwares\Nvim\plugged&#x27;</span>)</span><br><span class="line"><span class="string">&quot;这里的路径可自定义，推荐放到nvim安装路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plug &#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;godlygeek/tabular&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;plasticboy/vim-markdown&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;iamcco/markdown-preview.nvim&#x27;, &#123; &#x27;do&#x27;: &#123; -&gt; mkdp#util#install() &#125;, &#x27;for&#x27;: [&#x27;markdown&#x27;, &#x27;vim-plug&#x27;]&#125;</span></span><br><span class="line"><span class="string">Plug &#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;yuttie/inkstained-vim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;ferrine/md-img-paste.vim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;</span></span><br><span class="line"><span class="string">Plug &#x27;nvim-lua/plenary.nvim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;nvim-telescope/telescope.nvim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;kyazdani42/nvim-web-devicons&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;nvim-treesitter/nvim-treesitter&#x27;, &#123;&#x27;do&#x27;: &#x27;:TSUpdate&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;</span>将所有插件安装在这里</span><br><span class="line"></span><br><span class="line">call plug#end()</span><br><span class="line"><span class="keyword">let</span> g:vim_markdown_folding_disabled = <span class="number">1</span></span><br><span class="line">map &lt;F2&gt; :NERDTree&lt;CR&gt;</span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"><span class="string">&quot; for normal mode</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; &lt;F8&gt; &lt;Plug&gt;MarkdownPreview</span></span><br><span class="line"><span class="string">&quot;</span> <span class="keyword">for</span> insert mode</span><br><span class="line">imap &lt;silent&gt; &lt;F8&gt; &lt;Plug&gt;MarkdownPreview</span><br><span class="line"><span class="string">&quot; for normal mode</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; &lt;F9&gt; &lt;Plug&gt;StopMarkdownPreview</span></span><br><span class="line"><span class="string">&quot;</span> <span class="keyword">for</span> insert mode</span><br><span class="line">imap &lt;silent&gt; &lt;F9&gt; &lt;Plug&gt;StopMarkdownPreview</span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&quot; Find files using Telescope command-line sugar.</span></span><br><span class="line"><span class="string">autocmd FileType markdown nmap &lt;buffer&gt;&lt;silent&gt; &lt;leader&gt;i :call mdip#MarkdownClipboardImage()&lt;CR&gt;</span></span><br><span class="line"><span class="string">let g:mdip_imgdir = &#x27;</span>.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">let g:mdip_imgname = &#x27;</span>image<span class="string">&#x27;</span></span><br><span class="line"><span class="string">set number</span></span><br></pre></td></tr></table></figure>

<h1 id="5-打开nvim-在命令模式输入PlugInstall"><a href="#5-打开nvim-在命令模式输入PlugInstall" class="headerlink" title="5. 打开nvim, 在命令模式输入PlugInstall"></a>5. 打开nvim, 在命令模式输入PlugInstall</h1>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title>如雪如山</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/%E6%88%91%E7%9A%84%E4%B9%A6%E5%BA%93/%E5%A6%82%E9%9B%AA%E5%A6%82%E5%B1%B1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如雪如山"><a href="#如雪如山" class="headerlink" title="如雪如山"></a>如雪如山</h1><p>ISBN: 9787020166930<br>丛书: 无<br>作者: 张天翼<br>册数: 1<br>出品方: 无<br>出版日: 2022/04/01<br>出版日期: 2022-4-1<br>出版社: 人民文学出版社<br>创建时间: January 30, 2023 9:57 PM<br>定价: 58<br>封面: <a href="https://img2.doubanio.com/view/subject/s/public/s34201041.jpg">https://img2.doubanio.com/view/subject/s/public/s34201041.jpg</a><br>时间: 2023/01/30<br>标签: 中国, 中国文学, 女性, 小说, 张天翼, 文学, 短篇, 短篇小说<br>装帧: 精装<br>豆瓣: <a href="https://book.douban.com/subject/35875393/">https://book.douban.com/subject/35875393/</a><br>阅读状态: 闲置<br>页数: 347</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>我的书库</category>
      </categories>
  </entry>
  <entry>
    <title>windows 编译Emscripten</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/WebAssembly/windows%20%E7%BC%96%E8%AF%91Emscripten/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="windows-编译Emscripten"><a href="#windows-编译Emscripten" class="headerlink" title="windows 编译Emscripten"></a>windows 编译Emscripten</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> git clone https:<span class="comment">//github.com/juj/emsdk.git</span></span><br><span class="line"><span class="number">2.</span> cd emsdk</span><br><span class="line"><span class="number">3.</span> ./emsdk.bat install latest</span><br><span class="line"><span class="number">4.</span> ./emsdk.py activate latest</span><br><span class="line"><span class="number">5.</span> ./emsdk_env.bat (暂时性环境配置)</span><br><span class="line"><span class="number">6.</span> 手动配置环境</span><br><span class="line"><span class="number">7.</span> 重启，输入: emcc -v</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>WebAssembly</category>
      </categories>
  </entry>
  <entry>
    <title>IndexedDB</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Database/IndexedDB/IndexedDB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h1><p>Created by: Siyu Long<br>Created time: January 28, 2023 2:47 PM<br>Last edited by: Siyu Long<br>Last edited time: February 2, 2023 9:15 PM</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p>
<p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>
<h3 id="IndexedDB-具有以下特点："><a href="#IndexedDB-具有以下特点：" class="headerlink" title="IndexedDB 具有以下特点："></a>IndexedDB 具有以下特点：</h3><p><strong>（1）键值对储存。</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<p><strong>（2）异步。</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p><strong>（3）支持事务。</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p><strong>（4）同源限制</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p><strong>（5）储存空间大</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
<p><strong>（6）支持二进制储存。</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
<aside>
💡 IndexedDB 是浏览器提供的本地数据库，允许储存大量数据，提供查找接口，可以建立索引，是非关系型数据库（NoSQL）。它采用键值对储存，操作异步，支持事务，受同源限制，储存空间大，支持二进制储存

</aside>

<p>[[notion/学习/Database/Oracle/All articles]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Database</category>
        <category>IndexedDB</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle 索引</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Database/Oracle/Oracle%20%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle-索引"><a href="#Oracle-索引" class="headerlink" title="Oracle 索引"></a>Oracle 索引</h1><blockquote>
<p>1、 索引介绍 索引是用于加速数据存取的数据对象，是对数据表中一个或多个列进行排序的结构。</p>
</blockquote>
<p>摘要：</p>
<p>合理使用索引可以大大减少 I/O 数量，从而提高数据访问性能。在表名上创建索引索引名称（列名 1，列名 2，…ALTERINDEX 索引名称 COALESCEallocateunused；注意：如果未添加 deallocateuused，合并后仍将保留更多空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、  索引介绍</span><br><span class="line">索引是用于加速数据存取的数据对象，是对数据表中一个或多个列进行排序的结构。</span><br><span class="line"></span><br><span class="line">合理的使用索引能够大大减少I/O次数，从而提高数据訪问性能。</span><br><span class="line">2、  问题：为什么须要索引？</span><br><span class="line">Select * from scott.emp where empno=’8379’   --遍历emp表？</span><br><span class="line">制约程序规模增大的两个瓶颈：网络和数据库，须要用更好的方式组织、管理数据。</span><br><span class="line"></span><br><span class="line">3、  索引分类</span><br><span class="line">   按索引列个数</span><br><span class="line">(1) 单列索引</span><br><span class="line">基于单个列所建立的索引，定义格式例如以下：</span><br><span class="line">Create index索引名on表名(列名);</span><br><span class="line">(2) 复合索引</span><br><span class="line">基于两列或是多列的索引。在同一张表上能够有多个索引，可是要求列的组合必须不同。</span><br><span class="line">Create index 索引名 on 表名(列名1, 列名2,…… ) ;</span><br><span class="line">   按索引列的唯一性</span><br><span class="line">(1) 唯一索引</span><br><span class="line">索引列上的取值唯一。</span><br><span class="line">Create unique index索引名on表名(列名1, 列名2,…… ) ;</span><br><span class="line">(2) 非唯一索引</span><br><span class="line">   索引列上的取值不唯一。</span><br><span class="line">Create index索引名on表名(列名1, 列名2,…… ) ;</span><br><span class="line">   按索引数据的存储方式</span><br><span class="line">(1) B*树索引</span><br><span class="line">   特点：全部的叶子节点都在同一层，也就是不管查找哪一条数据。须要运行的I/O数据是一样的。适合进行区间扫描。</span><br><span class="line"></span><br><span class="line">   定义语法：</span><br><span class="line">CREATE [UNIQUE] INDEX [方案名.]索引名 ON  [方案名.]表名</span><br><span class="line">     (列名1[ASC|DESC] [,列名2[ASC|DESC]] …)</span><br><span class="line">[TABLESPACE 表空间名]</span><br><span class="line">     [PCTFREE]</span><br><span class="line">     [INITRANS]</span><br><span class="line">     [MAXTRANS]</span><br><span class="line">     [STORAGE CLAUSE]</span><br><span class="line">     [LOGGING|NOLOGGING]</span><br><span class="line">(2) 位图索引</span><br><span class="line">   特点：对索引列有少数不同值的大表，特别适合用位图索引，因为位图索引的更新代价更大，所以适合非常少更新键值的表。</span><br><span class="line">   定义语法：</span><br><span class="line">CREATE BITMAP INDEX [方案名.]索引名 ON  [方案名.]表名</span><br><span class="line">     (列名1[ASC|DESC] [,列名2[ASC|DESC]] …)</span><br><span class="line">[TABLESPACE 表空间名]</span><br><span class="line">     [PCTFREE]</span><br><span class="line">     [INITRANS]</span><br><span class="line">     [MAXTRANS]</span><br><span class="line">     [STORAGE CLAUSE]</span><br><span class="line">     [LOGGING|NOLOGGING]</span><br><span class="line">(3) 逆向索引</span><br><span class="line">   特点：适合建在递增或递减的列上，从而减少批量插入数据时造成的索引块竞争。可是无法进行区间扫描。</span><br><span class="line">   定义语法：</span><br><span class="line">CREATE [UNIQUE] INDEX [方案名.]索引名 ON  [方案名.]表名</span><br><span class="line">     (列名[ASC|DESC]) reverse</span><br><span class="line">[TABLESPACE 表空间名]</span><br><span class="line">     [PCTFREE]</span><br><span class="line">     [INITRANS]</span><br><span class="line">     [MAXTRANS]</span><br><span class="line">     [STORAGE CLAUSE]</span><br><span class="line">     [LOGGING|NOLOGGING]</span><br><span class="line">(4) 函数索引</span><br><span class="line">   特点：适合于查询对表中字段的引用中使用了函数的情况。</span><br><span class="line">   举例：Select * from scott.emp where upper(ename) = &#x27;SMITH&#x27;;</span><br><span class="line">4、  索引的使用原则</span><br><span class="line">(1) 在大表上建立索引才有意义</span><br><span class="line">(2) 在where子句或是连接条件上常常引用的列上建立索引</span><br><span class="line">5、  索引缺点分析</span><br><span class="line">(1) 建立索引，系统要占用大约为表的1.2倍的硬盘和内存空间来保存索引。</span><br><span class="line"></span><br><span class="line">(2) 更新数据的时候，系统必须要有额外的时间同一时候对索引进行更新，以维持数据和索引的一致性。</span><br><span class="line"></span><br><span class="line">6、  合并与重建索引</span><br><span class="line">随着对表的不断更新，表中的索引会产生越来越多的存储碎片，要对碎片进行整理有两种方式：重建索引或合并索引。</span><br><span class="line">   合并索引：将B树索引中的叶节点存储碎片进行合并。</span><br><span class="line">ALTER INDEX 索引名 COALESCE deallocate unused;</span><br><span class="line">注：不加deallocate unused则合并后仍保留多于的空间。</span><br><span class="line"></span><br><span class="line">   重建索引：即进行又一次建立，并且能够改动之前的各种參数；可将索引移入另外的表空间。因为重建的过程中移除了逻辑删除的索引。能够提高空间利用率。</span><br><span class="line">    ALTER INDEX索引名REBUILD 又一次配置參数;</span><br><span class="line">注：在改变属性时还能够改动REVERSE參数，改为反向，或反向改为正向。</span><br><span class="line"></span><br><span class="line">7、  删除索引</span><br><span class="line">   作用</span><br><span class="line">(1)  不再须要的索引；</span><br><span class="line">(2)  通过一段时间观察。发现非常少使用该索引；</span><br><span class="line">(3)  该索引无效，必须在重建之前删除。</span><br><span class="line">(4)  该索引包括过多存储碎片，须要在重建之前删除该索引；</span><br><span class="line">(5) 索引没有提供所期望的性能改善。</span><br><span class="line">(6) 在批量加载数据之前，先删除索引然后重建。</span><br><span class="line">   语法：</span><br><span class="line">DROP INDEX 方案名.索引名;</span><br><span class="line">8、  案例</span><br><span class="line">--运行系统提前定义的存储过程来创建PLAN_TABLE表</span><br><span class="line">SQL&gt;@ F:appAdministratorproduct11.2.0dbhome_1RDBMSADMINutlxplan.sql</span><br><span class="line">SQL&gt; grant all on plan_table to public;</span><br><span class="line">--运行系统提前定义的存储过程来创建角色plustrace并赋予查询动态性能视图的权限</span><br><span class="line">SQL&gt;@F:appAdministratorproduct11.2.0dbhome_1sqlplusadminplustrce.sql</span><br><span class="line">SQL&gt;set autotrace on exp</span><br><span class="line">SQL&gt;create table student</span><br><span class="line">(</span><br><span class="line">Sno char(9) primary key,</span><br><span class="line">Sname char(20) unique,</span><br><span class="line">Ssex char(2),</span><br><span class="line">Sage smallint,</span><br><span class="line">Sdept char(20)</span><br><span class="line">);</span><br><span class="line">SQL&gt; insert into student values(&#x27;201010121&#x27;, &#x27;李勇&#x27;, &#x27;男&#x27;,20, &#x27;IS&#x27;);</span><br><span class="line">SQL&gt;insert into student values(&#x27;201010122&#x27;, &#x27;刘晨&#x27;, &#x27;男&#x27;,19, &#x27;IS&#x27;);</span><br><span class="line">SQL&gt;insert into student values(&#x27;201010123&#x27;, &#x27;张力&#x27;, &#x27;男&#x27;,20, &#x27;MA&#x27;);</span><br><span class="line">SQL&gt;insert into student values(&#x27;201010124&#x27;, &#x27;李颖&#x27;, &#x27;女&#x27;,20, &#x27;IS&#x27;);</span><br><span class="line">--对照以下三条查询语句的运行计划。观察TABLE ACCESS上的差别</span><br><span class="line">SQL&gt;select * from student where sno=&#x27;201010122&#x27;;</span><br><span class="line">SQL&gt;select * from student where sname=&#x27;刘晨&#x27;;</span><br><span class="line">SQL&gt;select * from student where sage=19;</span><br><span class="line">SQL&gt;set autotrace off</span><br><span class="line">--查询STUDENT表上的索引信息，如今有两个索引</span><br><span class="line">SQL&gt;select index_name, index_type, table_name, uniqueness from user_indexes where table_name=&#x27;STUDENT&#x27;;</span><br><span class="line">--如果index_name各自是SYS_C0011054和SYS_C0011053</span><br><span class="line">--以下进行B*树索引监控</span><br><span class="line">SQL&gt;alter index SYS_C0011054 MONITORING USAGE;</span><br><span class="line">--SYS_C0011054为student表上一个索引的index_name</span><br><span class="line">SQL&gt;select * from student where sno=&#x27;201010122&#x27;;</span><br><span class="line">SQL&gt;select * from student where sname=&#x27;刘晨&#x27;;</span><br><span class="line">SQL&gt;select * from v$object_usage;</span><br><span class="line">--创建位图索引</span><br><span class="line">SQL&gt;create bitmap index bidx_sex on student(ssex);</span><br><span class="line">--以下进行位图索引监控</span><br><span class="line">SQL&gt;alter index bidx_sex MONITORING USAGE;</span><br><span class="line">SQL&gt;select * from student where ssex =&#x27;男&#x27;;</span><br><span class="line">SQL&gt;select * from v$object_usage;</span><br><span class="line">说明：关闭索引监控需运行语句为</span><br><span class="line">SQL&gt;alter index SYS_C0011054 NOMONITORING USAGE;</span><br><span class="line">当中，SYS_C0011054为待关闭监控的索引名。</span><br><span class="line"></span><br><span class="line">9、  显示索引列</span><br><span class="line">创建索引时，须要提供相应的表列。通过查询数据字典dba_ind_columns能够显示全部的索引的表列信息。通过查询数据字典all_ind_columns能够显示当前用户可訪问的全部的索引表列信息。通过查询数据字典user_ind_columns能够显示当前用户索引的表列信息。</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">SQL&gt; Select column_name, column_length from user_ind_columns where index_name=&#x27;BIDX_SEX&#x27;;</span><br><span class="line">10、显示索引段位置及大小</span><br><span class="line">建立索引时。oracle会为索引分配相应的索引字段，索引数据被存放在索引段中。并且段名与索引名全然相同。比如：</span><br><span class="line">SQL&gt; Select tablespace_name, segment_type, bytes from user_segments where segment_name=&#x27;BIDX_SEX&#x27;;</span><br><span class="line">11、显示函数索引</span><br><span class="line">建立函数索引时，oracle会将函数索引的信息存放到数据字典中。通过查询数据字典dba_ind_expressions能够显示数据库全部函数索引所相应的函数或表达式。</span><br><span class="line"></span><br><span class="line">通过查询数据字典user_ind_expressions能够显示当前用户函数索引所相应的函数或表达式。</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">SQL&gt; Create index fun_ind_sdept on student(upper(Sdept));</span><br><span class="line">SQL&gt; Select column_expression from user_ind_expressions where index_name=&#x27;FUN_IND_SDEPT&#x27;;</span><br><span class="line">12、索引使用的限制情况</span><br><span class="line">(1) 使用不等于操作符（&lt;&gt;、!=）</span><br><span class="line">以下的查询即使在sno列有一个索引，查询语句仍然运行一次全表扫描。</span><br><span class="line">SQL&gt;  select * from student where sno&lt;&gt;&#x27;1&#x27;;</span><br><span class="line">把上面的语句改成例如以下的查询语句。在採用基于规则的优化器而不是基于代价的优化器时，将会使用索引。</span><br><span class="line">SQL&gt;  select * from student where sno &lt; &#x27;1&#x27; or sno &gt; &#x27;1&#x27;;</span><br><span class="line">注：通过把不等于操作符改成OR条件。就能够使用索引。以避免全表扫描。</span><br><span class="line">(2) 使用IS NULL 或IS NOT NULL</span><br><span class="line">使用IS NULL 或IS NOT NULL相同会限制索引的使用。因为NULL值并没有被定义。 在SQL语句中使用NULL会有非常多的麻烦。</span><br><span class="line"></span><br><span class="line">因此建议开发者在建表时，把须要索引的列设成NOT NULL。 如果被索引的列在某些行中存在NULL值，就不会使用这个索引，除非索引是一个位图索引。</span><br><span class="line">(3) 比較不匹配的数据类型</span><br><span class="line">比較不匹配的数据类型也是比較难于发现的性能问题之中的一个。</span><br><span class="line">注意以下查询的样例。sno是一个CHAR类型，在sno字段上有索引。以下的语句将运行全表扫描。</span><br><span class="line"></span><br><span class="line">SQL&gt;  select * from student where sno=1;</span><br><span class="line">Oracle能够自己主动把where子句变成to_number(sno)=1，这样就限制了索引的使用,改成以下的查询就能够使用索引：</span><br><span class="line">       SQL&gt;  select * from student where sno=&#x27;1&#x27;;</span><br><span class="line">(4) 当使系统数据字典或视图</span><br><span class="line">系统的数据字典表都未被分析过。可能导致极差的“运行计划”。</span><br><span class="line"></span><br><span class="line">可是不要擅自对数据字典表做分析，否则可能导致死锁。或系统性能下降。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本文由简悦 SimpRead 转码</p>
</blockquote>
<p>合理使用索引可以大大减少 I/O 数量，从而提高数据访问性能，Oracle提供了多种索引类型，如单列索引、复合索引、唯一索引、非唯一索引、B*树索引、位图索引、逆向索引和函数索引，以满足不同的数据访问需求。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Database</category>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title>数据源（Data Source）：是对数据来源信息的描述，宜搭支持文件、数据库等类型数据源的管理与维护。</title>
    <url>/2023/07/04/notion/Other/%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Untitled%20Database/%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%88Data%20Source%EF%BC%89%EF%BC%9A%E6%98%AF%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%AE%9C%E6%90%AD%E6%94%AF%E6%8C%81%E6%96%87%E4%BB%B6%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AD%89%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4%E3%80%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据源（Data-Source）：是对数据来源信息的描述，宜搭支持文件、数据库等类型数据源的管理与维护。"><a href="#数据源（Data-Source）：是对数据来源信息的描述，宜搭支持文件、数据库等类型数据源的管理与维护。" class="headerlink" title="数据源（Data Source）：是对数据来源信息的描述，宜搭支持文件、数据库等类型数据源的管理与维护。"></a>数据源（Data Source）：是对数据来源信息的描述，宜搭支持文件、数据库等类型数据源的管理与维护。</h1><p>名称: <a href="https://www.yuque.com/yida/support/duy0wi">https://www.yuque.com/yida/support/duy0wi</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
        <category>钉钉宜搭低代码平台分析报告</category>
        <category>Untitled Database</category>
      </categories>
  </entry>
  <entry>
    <title>对当前应用内的所有单表数据源、视图表（多表关联）、数据准备（大数据离线方案）、跨应用（表单）数据源等进行统一管理，是宜搭在数据互联场景下的标准数据控制单元。</title>
    <url>/2023/07/04/notion/Other/%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Untitled%20Database/%E5%AF%B9%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E8%A7%86%E5%9B%BE%E8%A1%A8%EF%BC%88%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94%EF%BC%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87%EF%BC%88%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%A6%BB%E7%BA%BF%E6%96%B9%E6%A1%88%EF%BC%89%E3%80%81%E8%B7%A8%E5%BA%94%E7%94%A8%EF%BC%88%E8%A1%A8%E5%8D%95%EF%BC%89%E6%95%B0%E6%8D%AE%E6%BA%90%E7%AD%89%E8%BF%9B%E8%A1%8C%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%EF%BC%8C%E6%98%AF%E5%AE%9C%E6%90%AD%E5%9C%A8%E6%95%B0%E6%8D%AE%E4%BA%92%E8%81%94%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E3%80%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对当前应用内的所有单表数据源、视图表（多表关联）、数据准备（大数据离线方案）、跨应用（表单）数据源等进行统一管理，是宜搭在数据互联场景下的标准数据控制单元。"><a href="#对当前应用内的所有单表数据源、视图表（多表关联）、数据准备（大数据离线方案）、跨应用（表单）数据源等进行统一管理，是宜搭在数据互联场景下的标准数据控制单元。" class="headerlink" title="对当前应用内的所有单表数据源、视图表（多表关联）、数据准备（大数据离线方案）、跨应用（表单）数据源等进行统一管理，是宜搭在数据互联场景下的标准数据控制单元。"></a>对当前应用内的所有单表数据源、视图表（多表关联）、数据准备（大数据离线方案）、跨应用（表单）数据源等进行统一管理，是宜搭在数据互联场景下的标准数据控制单元。</h1><p>名称: <a href="https://www.yuque.com/yida/support/roe3o1">https://www.yuque.com/yida/support/roe3o1</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
        <category>钉钉宜搭低代码平台分析报告</category>
        <category>Untitled Database</category>
      </categories>
  </entry>
  <entry>
    <title>视图表通过单表或多表关联，将已有的表单数据进行预处理，同时也支持中间表模式，提升数据加工处理能力。目前，报表数据可视化、表单联动等场景可直接调用视图表中的数据。</title>
    <url>/2023/07/04/notion/Other/%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Untitled%20Database/%E8%A7%86%E5%9B%BE%E8%A1%A8%E9%80%9A%E8%BF%87%E5%8D%95%E8%A1%A8%E6%88%96%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94%EF%BC%8C%E5%B0%86%E5%B7%B2%E6%9C%89%E7%9A%84%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B9%9F%E6%94%AF%E6%8C%81%E4%B8%AD%E9%97%B4%E8%A1%A8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%8F%90%E5%8D%87%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E3%80%82%E7%9B%AE%E5%89%8D%EF%BC%8C%E6%8A%A5%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E3%80%81%E8%A1%A8%E5%8D%95%E8%81%94%E5%8A%A8%E7%AD%89%E5%9C%BA%E6%99%AF%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E8%A7%86%E5%9B%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="视图表通过单表或多表关联，将已有的表单数据进行预处理，同时也支持中间表模式，提升数据加工处理能力。目前，报表数据可视化、表单联动等场景可直接调用视图表中的数据。"><a href="#视图表通过单表或多表关联，将已有的表单数据进行预处理，同时也支持中间表模式，提升数据加工处理能力。目前，报表数据可视化、表单联动等场景可直接调用视图表中的数据。" class="headerlink" title="视图表通过单表或多表关联，将已有的表单数据进行预处理，同时也支持中间表模式，提升数据加工处理能力。目前，报表数据可视化、表单联动等场景可直接调用视图表中的数据。"></a>视图表通过单表或多表关联，将已有的表单数据进行预处理，同时也支持中间表模式，提升数据加工处理能力。目前，报表数据可视化、表单联动等场景可直接调用视图表中的数据。</h1><p>名称: <a href="https://www.yuque.com/yida/support/oim554">https://www.yuque.com/yida/support/oim554</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
        <category>钉钉宜搭低代码平台分析报告</category>
        <category>Untitled Database</category>
      </categories>
  </entry>
  <entry>
    <title>通常也叫【跨应用取数】，即在本应用内调用其他宜搭应用的表单数据，用于宜搭应用间的数据互联。</title>
    <url>/2023/07/04/notion/Other/%E9%92%89%E9%92%89%E5%AE%9C%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/Untitled%20Database/%E9%80%9A%E5%B8%B8%E4%B9%9F%E5%8F%AB%E3%80%90%E8%B7%A8%E5%BA%94%E7%94%A8%E5%8F%96%E6%95%B0%E3%80%91%EF%BC%8C%E5%8D%B3%E5%9C%A8%E6%9C%AC%E5%BA%94%E7%94%A8%E5%86%85%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%AE%9C%E6%90%AD%E5%BA%94%E7%94%A8%E7%9A%84%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%AE%9C%E6%90%AD%E5%BA%94%E7%94%A8%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%92%E8%81%94%E3%80%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="通常也叫【跨应用取数】，即在本应用内调用其他宜搭应用的表单数据，用于宜搭应用间的数据互联。"><a href="#通常也叫【跨应用取数】，即在本应用内调用其他宜搭应用的表单数据，用于宜搭应用间的数据互联。" class="headerlink" title="通常也叫【跨应用取数】，即在本应用内调用其他宜搭应用的表单数据，用于宜搭应用间的数据互联。"></a>通常也叫【跨应用取数】，即在本应用内调用其他宜搭应用的表单数据，用于宜搭应用间的数据互联。</h1><p>名称: <a href="https://www.yuque.com/yida/support/btrtnt">https://www.yuque.com/yida/support/btrtnt</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
        <category>钉钉宜搭低代码平台分析报告</category>
        <category>Untitled Database</category>
      </categories>
  </entry>
  <entry>
    <title>Untitled Database</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/SQL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94left%20join%20on%20%E5%A4%9A%E6%9D%A1%E4%BB%B6_minixuezhen%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/Untitled%20Database/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[[2]]<br>[[3]]<br>[[4]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
        <category>SQL语法——left join on 多条件_minixuezhen的博客-CSDN博客</category>
      </categories>
  </entry>
  <entry>
    <title>ProGrids</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/Unity%20Addition%20Plugin/ProGrids/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ProGrids"><a href="#ProGrids" class="headerlink" title="ProGrids"></a>ProGrids</h1><p>Installation: <strong>com.unity.progrids</strong></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
        <category>Unity Addition Plugin</category>
      </categories>
  </entry>
  <entry>
    <title>Class</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/Class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>ES6 类可以通过使用 <code>class</code> 关键字来创建更清晰的语法结构，以及构造函数、静态方法和 getter 和 setter 等其他功能。使用 <code>class</code> 关键字可以让开发人员创建更有组织性且易于维护的对象，并且还可以享受内置优化带来的更好的性能。</p>
<p>使用 <code>class</code> 关键字可以更加优雅而简洁的定义类和类的方法，以及创建实例化的对象。首先，需要定义一个类，然后再在类中定义构造函数和其他方法，像执行类方法，定义静态方法，定义 getter 和 setter 等。接下来，你可以使用 <code>new</code> 关键字来实例化类，并调用它们的方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  static staticMethod() &#123;</span><br><span class="line">    // do something</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myClass = new MyClass(&#x27;MyClass&#x27;);</span><br><span class="line">let myName = myClass.getName();</span><br><span class="line">MyClass.staticMethod();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如，你可以使用 <code>class</code> 关键字为类和方法创建简单的抽象，用于实例化对象。下面是一个<strong>示例</strong>，演示了如何使用 <code>class</code> 关键字来定义一个类，添加构造函数、静态方法、getter 和 setter 等：</p>
<h1 id="Class-知识点"><a href="#Class-知识点" class="headerlink" title="Class 知识点"></a>Class 知识点</h1><p>类是一种特殊的函数，可用于创建对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyExampleClass &#123;</span><br><span class="line">  constructor(exampleName) &#123;</span><br><span class="line">    this.exampleName = exampleName;</span><br><span class="line">  &#125;</span><br><span class="line">  getExampleName() &#123;</span><br><span class="line">    return this.exampleName;</span><br><span class="line">  &#125;</span><br><span class="line">  static staticExampleMethod() &#123;</span><br><span class="line">    // do something</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类创建实例，并调用它们的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myExampleClass = new MyExampleClass(&#x27;MyExampleClass&#x27;);</span><br><span class="line">let myExampleName = myExampleClass.getExampleName();</span><br><span class="line">MyExampleClass.staticExampleMethod();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>💡</p>
<ol>
<li><p>每个函数都有prototype这个属性，指向一个对象，即该函数的原型</p>
</li>
<li><p>每个构造函数的实例都有proto这个属性，这个属性指向构造函数函数的prototype</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">A构造方法的prototype就是<span class="built_in">Object</span></span><br><span class="line">a实例的proto就是也是<span class="built_in">Object</span></span><br><span class="line">换种说法就是类的prototype代表的就是类的实例的原型</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250954084.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Generator</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/Generator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p><code>Generator</code> 函数是 ES6 提供的一种<code>异步编程</code>解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个<code>状态机</code>，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的<code>遍历器对象</code>，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，<code>Generator</code>函数是一个<code>普通函数</code>，但是有两个特征。一是， function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（ yield 在英语里的意思就是“<strong>产出</strong>”）。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<p><strong>第一次调用</strong>，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。 next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello ， done 属性的值 false ，表示遍历还没有结束。</p>
<p><strong>第二次调用</strong>，Generator 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式。 next 方法返回的对象的 value 属性就是当前 yield 表达式的值 world ， done 属性的值 false ，表示遍历还没有结束。</p>
<p><strong>第三次调用</strong>，Generator 函数从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。 next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined ）， done 属性的值 true ，表示遍历已经结束。</p>
<p><strong>第四次调用</strong>，此时 Generator 函数已经运行完毕， next 方法返回对象的 value 属性为 undefined ， done 属性为 true 。以后再调用 next 方法，返回的都是这个值。</p>
<p><strong>总结一下</strong>，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值； done 属性是一个布尔值，表示是否遍历结束。</p>
<p>Generator 函数可以不用 yield 表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;执行了！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> generator = f();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	generator.next()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<strong>函数 f 如果是普通函数，在为变量 generator 赋值时就会执行。但是，函数 f 是一个 Generator 函数，就变成只有调用 next 方法时，函数 f 才会执行</strong>。</p>
<p>看一个例子。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二次运行 next 方法的时候不带参数，导致 y 的值等于 2 * undefined （即 NaN ），除以 3 以后还是 NaN ，因此返回对象的 value 属性也等于 NaN 。第三次运行 Next 方法的时候不带参数，所以 z 等于 undefined ，返回对象的 value 属性等于 5 + NaN + undefined ，即 NaN 。</p>
<p>如果向 next 方法提供参数，返回结果就完全不一样了。上面代码第一次调用 b 的 next 方法时，返回 x+1 的值 6 ；第二次调用 next 方法，将上一次 yield 表达式的值设为 12 ，因此 y 等于 24 ，返回 y / 3 的值 8 ；第三次调用 next 方法，将上一次 yield 表达式的值设为 13 ，因此 z 等于 13 ，这时 x 等于 5 ， y 等于 24 ，所以 return 语句的值等于 42 。</p>
<p>注意，由于 next 方法的参数表示上一个 yield 表达式的返回值，所以在第一次使用 next 方法时，传递参数是无效的。V8 引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Symbol</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/Symbol/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p><code>ES5</code>的对象属性名都是<code>字符串</code>，这容易造成<code>属性名</code>的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，<strong>这样就从根本上防止属性名的冲突</strong>。这就是 ES6 引入 Symbol 的原因。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p><code>[Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)</code>是一个对象，它代表了一个异步操作的最终完成或者失败。</p>
<p>在过去，要想做多重的异步操作，会导致经典的回调地狱：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(result, <span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">    doThirdThing(newResult, <span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br><span class="line">Copy to Clipboard</span><br></pre></td></tr></table></figure>

<p>现在，我们可以把回调绑定到返回的 Promise 上，形成一个 Promise 链：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doThirdThing(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race()</a> 是并行运行异步操作的两个组合式工具。</p>
<p>我们可以发起并行操作，然后等多个操作全部结束后进行下一步操作，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([func1(), func2(), func3()])</span><br><span class="line">.then(<span class="function">(<span class="params">[result1, result2, result3]</span>) =&gt;</span> &#123; <span class="comment">/* use result1, result2 and result3 */</span> &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>基础用法</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/Pinia/%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h1><ol>
<li><p>state的访问</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">引入并实例化</span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useStore <span class="keyword">from</span> <span class="string">&#x27;XXX/xx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = useStore()</span><br><span class="line"><span class="keyword">const</span> &#123; linkList &#125; = storeToRefs(store) <span class="comment">//解析成响应式数据</span></span><br></pre></td></tr></table></figure></li>
<li><p>state的重置</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useStore()</span><br><span class="line"></span><br><span class="line">store.$reset()</span><br></pre></td></tr></table></figure></li>
<li><p>state的订阅（监听）</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在patch 后只触发一次</span></span><br><span class="line">store.$subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  linkListData.value = toRaw(state).linkList</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//toRaw()用来获取proxy的数据</span></span><br></pre></td></tr></table></figure></li>
<li><p>state的更新</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">store.$patch(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  state.linkList.push(data[i]) <span class="comment">//操作对应数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
        <category>Pinia</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Python 和 OpenCV 读取图片</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Python/OpenCV/%E4%BD%BF%E7%94%A8%20Python%20%E5%92%8C%20OpenCV%20%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用-Python-和-OpenCV-读取图片"><a href="#使用-Python-和-OpenCV-读取图片" class="headerlink" title="使用 Python 和 OpenCV 读取图片"></a>使用 Python 和 OpenCV 读取图片</h1><p>import cv2</p>
<h1 id="首先，我们需要调用-OpenCV-的函数，以便从文件系统中读取图像，我们可以指定文件的路径，以及文件名称"><a href="#首先，我们需要调用-OpenCV-的函数，以便从文件系统中读取图像，我们可以指定文件的路径，以及文件名称" class="headerlink" title="首先，我们需要调用 OpenCV 的函数，以便从文件系统中读取图像，我们可以指定文件的路径，以及文件名称"></a>首先，我们需要调用 OpenCV 的函数，以便从文件系统中读取图像，我们可以指定文件的路径，以及文件名称</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;[filename]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="如果图像被正确读取，则返回一个值，表示图像已经被正确读取，但如果出现异常，则返回一个空值"><a href="#如果图像被正确读取，则返回一个值，表示图像已经被正确读取，但如果出现异常，则返回一个空值" class="headerlink" title="如果图像被正确读取，则返回一个值，表示图像已经被正确读取，但如果出现异常，则返回一个空值"></a>如果图像被正确读取，则返回一个值，表示图像已经被正确读取，但如果出现异常，则返回一个空值</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> img is not None:</span><br><span class="line"># 如果图像被正确读取，则我们可以对图像进行更多的处理，例如缩放，调整大小，旋转等操作，以达到我们想要的效果</span><br><span class="line"># 另外，我们还可以在图像上绘制形状或者文字，以便增强图像的表现力</span><br><span class="line"># 同时，我们也可以使用 OpenCV 提供的函数处理图像，例如使用颜色空间转换，滤波器，图像金字塔等功能，以达到更好的效果</span><br><span class="line"><span class="attr">else</span>:</span><br><span class="line">print(<span class="string">&quot;Error loading image&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Python</category>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>OpenCV</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Python/OpenCV/OpenCV/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h1 id="什么是opencv"><a href="#什么是opencv" class="headerlink" title="什么是opencv?"></a>什么是opencv?</h1><p>OpenCV（Open Source Computer Vision）是一个开源的计算机视觉库，它可以为各种应用提供实时图像处理功能，从而在许多方面改善了我们的生活。它提供了一些有用的功能，包括图像构建、边缘检测、形态学操作、目标检测、图像分类和跟踪等功能。此外，它还可以用来检测和识别图像中的物体，以及处理视频和图像流，从而达到实时监控的目的。通过使用OpenCV，可以轻松访问各种算法，从而提高应用的效率和性能。</p>
<p>[[all about opencv]]</p>
<p>OpenCV可以通过官方网站（<a href="https://opencv.org/%EF%BC%89%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8GitHub%E4%B8%8A%E4%B8%8B%E8%BD%BD%EF%BC%88https://github.com/opencv/opencv%EF%BC%89%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E4%BD%BF%E7%94%A8OpenCV%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BB%8ECocoaPods%E3%80%81Homebrew%E6%88%96Python%E7%9A%84pip%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B8%AD%E5%AE%89%E8%A3%85%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E5%BC%80%E5%8F%91%E8%80%85%E6%9B%B4%E8%BD%BB%E6%9D%BE%E5%9C%B0%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%A1%E7%90%86OpenCV%E3%80%82">https://opencv.org/）下载，也可以在GitHub上下载（https://github.com/opencv/opencv）。另外，使用OpenCV还可以从CocoaPods、Homebrew或Python的pip包管理器中安装，它们可以帮助开发者更轻松地安装和管理OpenCV。</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Python</category>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>安装Python OpenCV</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Python/OpenCV/%E5%AE%89%E8%A3%85Python%20OpenCV/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装Python-OpenCV"><a href="#安装Python-OpenCV" class="headerlink" title="安装Python OpenCV"></a>安装Python OpenCV</h1><p>本文提供了关于如何安装Python OpenCV的指南。OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉库，可以在Python中使用它来处理图像和视频，提供了一组算法，可以用来检测和识别图像中的物体，分析图像，以及进行图像和视频处理。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>要安装Python OpenCV，首先需要安装Python和OpenCV，因此，在安装Python OpenCV之前，需要先准备Python和OpenCV的安装环境。</p>
<h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><p>要安装Python，首先需要下载并安装Python解释器。有几种Python发行版可供选择，但是推荐使用<a href="https://www.anaconda.com/distribution/#download-section">Anaconda Python</a>，这是用于Python科学计算的最流行的发行版，它提供了许多内置库，可以有效地满足Python科学计算的要求。</p>
<h3 id="安装OpenCV"><a href="#安装OpenCV" class="headerlink" title="安装OpenCV"></a>安装OpenCV</h3><p>OpenCV可以通过<a href="https://anaconda.org/anaconda/opencv">Anaconda Cloud</a>从Anaconda Cloud获得。只需打开终端（在Linux和macOS中）或命令提示符（在Windows中），然后输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c anaconda opencv</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装OpenCV后，可以在Python环境中使用OpenCV的功能，例如图像处理、视频处理、图像分析等。</p>
<h2 id="安装Python-OpenCV-1"><a href="#安装Python-OpenCV-1" class="headerlink" title="安装Python OpenCV"></a>安装Python OpenCV</h2><p>安装OpenCV后，可以使用pip安装Python OpenCV包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装完成后，可以在Python程序中导入OpenCV：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>导入OpenCV后，就可以在Python程序中使用OpenCV的功能，例如图像处理、视频处理、图像分析、物体检测等。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文介绍了如何安装Python OpenCV。首先，需要准备Python和OpenCV的安装环境，然后安装Python和OpenCV，最后，使用pip安装Python OpenCV包，安装完成后，可以在Python程序中导入OpenCV，从而在Python程序中使用OpenCV的功能，实现计算机视觉的应用。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Python</category>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>跨盘cd</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Python/Anaconda/%E8%B7%A8%E7%9B%98cd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="跨盘cd"><a href="#跨盘cd" class="headerlink" title="跨盘cd"></a>跨盘cd</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">cd **<span class="regexp">/d** xx/</span>xxx/xx</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Python</category>
        <category>Anaconda</category>
      </categories>
  </entry>
  <entry>
    <title>2</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/SQL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94left%20join%20on%20%E5%A4%9A%E6%9D%A1%E4%BB%B6_minixuezhen%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/Untitled%20Database/2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>1: 2<br>100: 200<br>null 1: 22<br>null 2: 0</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
        <category>SQL语法——left join on 多条件_minixuezhen的博客-CSDN博客</category>
        <category>Untitled Database</category>
      </categories>
  </entry>
  <entry>
    <title>null</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/SQL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94left%20join%20on%20%E5%A4%9A%E6%9D%A1%E4%BB%B6_minixuezhen%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/Untitled%20Database/null/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="null"><a href="#null" class="headerlink" title="null"></a>null</h1><p>1: 3<br>100: 300<br>null 1: null<br>null 2: null</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
        <category>SQL语法——left join on 多条件_minixuezhen的博客-CSDN博客</category>
        <category>Untitled Database</category>
      </categories>
  </entry>
  <entry>
    <title>4</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Development/SQL%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94left%20join%20on%20%E5%A4%9A%E6%9D%A1%E4%BB%B6_minixuezhen%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/Untitled%20Database/4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>1: 4<br>100: 400<br>null 1: 44<br>null 2: 1</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Development</category>
        <category>SQL语法——left join on 多条件_minixuezhen的博客-CSDN博客</category>
        <category>Untitled Database</category>
      </categories>
  </entry>
  <entry>
    <title>1-什么是经济学</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Lessons/all%20lessons/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-什么是经济学"><a href="#1-什么是经济学" class="headerlink" title="1-什么是经济学"></a>1-什么是经济学</h1><p>Created: January 26, 2023 11:51 PM<br><a href="http://player.bilibili.com/player.html?aid=62120450&bvid=BV1gt411g7RU&cid=107964696&page=1">http://player.bilibili.com/player.html?aid=62120450&amp;bvid=BV1gt411g7RU&amp;cid=107964696&amp;page=1</a></p>
<h1 id="经济学的三类问题"><a href="#经济学的三类问题" class="headerlink" title="经济学的三类问题"></a>经济学的三类问题</h1><ol>
<li>人们如何做出决策？- how people make decision?</li>
<li>人们如何相互作用？- how people interact?</li>
<li>整体经济如何运行？- how the economy as a whole works?</li>
</ol>
<h1 id="经济学10个原理-人们如何做出决策"><a href="#经济学10个原理-人们如何做出决策" class="headerlink" title="经济学10个原理-人们如何做出决策"></a>经济学10个原理-人们如何做出决策</h1><ol>
<li><p>人们面临得失交换、</p>
</li>
<li><p>某物的成本是为此所放弃的东西</p>
</li>
<li><p>理性人思考边际量</p>
</li>
<li><p>人们会对激励做出反应</p>
<hr>
</li>
<li><p>贸易能使人人受益</p>
</li>
<li><p>市场通常是组织经济活动的好方式</p>
</li>
<li><p>政府有时可以改进市场结果</p>
<hr>
</li>
<li><p>一国的生活水平取决于他的生产</p>
</li>
<li><p>当政府发行了过多的货币时物价上涨</p>
</li>
<li><p>社会面临通货膨胀和失业之间的短期得失交换</p>
</li>
</ol>
<blockquote>
<p>个人决策</p>
</blockquote>
<blockquote>
<p>个人和个人之间，企业和企业之间，企业和个人之间，国家和国家之间相互的作用</p>
</blockquote>
<blockquote>
<p>经济作为一个整体</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Lessons</category>
        <category>all lessons</category>
        <category>清华大学-经济学原理</category>
      </categories>
  </entry>
  <entry>
    <title>乐理学习</title>
    <url>/2023/07/22/notion/%E5%AD%A6%E4%B9%A0/Long-term%20Target/targets/Piano%20Learning/%E4%B9%90%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="乐理学习"><a href="#乐理学习" class="headerlink" title="乐理学习"></a>乐理学习</h1><p>高音谱号在五线谱上的四间分别是FACE(face脸)。</p>
<p>高音谱号在五线谱上的五线分别是EGBDF(every good boys deserve fudge)。</p>
<p>低音谱号在五线谱上的四间分别是ACEG(all cows eat grass)。</p>
<p>高音谱号在五线谱上的五线分别是GBDFA(green birds dont fly away)。</p>
<p>上加三间和下加三线都是ACE(啦哆咪)。</p>
<p>音程学习是为了更快读谱</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Long-term Target</category>
        <category>targets</category>
        <category>Piano Learning</category>
      </categories>
  </entry>
  <entry>
    <title>{.vscode}</title>
    <url>/2023/06/24/VS%20Code/%7B.vscode%7D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>VS Code</category>
      </categories>
  </entry>
</search>
