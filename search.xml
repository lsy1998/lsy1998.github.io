<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Home</title>
    <url>/2023/06/24/Home/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快去-Git-Pull-一下"><a href="#快去-Git-Pull-一下" class="headerlink" title="快去 Git Pull  一下"></a>快去 <mark style="background: #FF5582A6;">Git Pull </mark> 一下</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var i = [dv.pages().length,dv.pages().length,dv.pages().length,</span><br><span class="line">         dv.pages().file.etags.distinct().length]</span><br><span class="line">dv.paragraph(`总共有 **$&#123;i[0]&#125;** 个文件`)</span><br><span class="line">dv.paragraph(`==标签== **$&#123;i[3]&#125;**个`)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var y = &quot;2023&quot;</span><br><span class="line">var m = Array(12).fill(0).map(function(v,i)&#123;return i&#125;);</span><br><span class="line">var d = [31,29,31,30,31,30,31,31,30,31,30,31]</span><br><span class="line"></span><br><span class="line">for(let i of m)</span><br><span class="line">&#123;</span><br><span class="line">    var n = Array(d[i]).fill(0).map(function(v,i)&#123;return i+1&#125;);</span><br><span class="line">    var data = Array(d[i]).fill(0);</span><br><span class="line"></span><br><span class="line">    for(let j of dv.pages().filter(p=&gt;String(p.file.cday).split(&quot;-&quot;)[0]==y &amp;&amp; String(p.file.cday).split(&quot;-&quot;)[1]==i+1).groupBy(p=&gt;String(p.file.cday).split(&quot;-&quot;)[2].slice(0,2)))</span><br><span class="line">         data[j.key-1] = dv.pages().filter(p=&gt;String(p.file.cday).split(&quot;-&quot;)[2].slice(0,2)==j.key).length;</span><br><span class="line"></span><br><span class="line">    if(data.every(p=&gt;p==0))</span><br><span class="line">        continue</span><br><span class="line">    dv.header(4, i+1+&quot;月&quot;);</span><br><span class="line">    dv.paragraph(`\`\`\`chart</span><br><span class="line">type: line</span><br><span class="line">labels: [$&#123;n&#125;]</span><br><span class="line">series:</span><br><span class="line">- title: 笔记数量</span><br><span class="line">  data: [$&#123;data&#125;]</span><br><span class="line">labelColors: true</span><br><span class="line">\`\`\``)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Home</category>
      </categories>
  </entry>
  <entry>
    <title>CSS知识点</title>
    <url>/2023/06/24/CSS/CSS%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID: ID_h1w7</span><br><span class="line">Number of Columns: 4</span><br><span class="line">Largest Column: standard</span><br></pre></td></tr></table></figure>

<ul>
<li>[[SVG]]</li>
<li>[[@font-face]]</li>
<li> [[grid-template-columns]]</li>
<li>[[margin-inline]]</li>
</ul>
<p>— end-column —</p>
<ul>
<li>[[可变字体]]</li>
<li>[[@media]]</li>
<li>[[fr]]</li>
<li>[[margin-inline]]</li>
</ul>
<p>— end-column —</p>
<ul>
<li>[[自定义属性]]</li>
<li>[[place-items]]</li>
<li>[[align-content,justify-content,align-items,justify-items]]</li>
</ul>
<p>— end-column —</p>
<ul>
<li>[[hsl()和hsla()]]</li>
<li>[[focus-visible 和 focus]]</li>
<li> [[aspect-ratio]]</li>
</ul>
<p>— end-multi-column</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID: ID_uezt</span><br><span class="line">Number of Columns: 3</span><br><span class="line">Largest Column: standard</span><br></pre></td></tr></table></figure>

<h2 id="分栏1"><a href="#分栏1" class="headerlink" title="分栏1"></a>分栏1</h2><ul>
<li>[[CSS 单位]]</li>
</ul>
<p>— column-end —</p>
<h2 id="分栏2"><a href="#分栏2" class="headerlink" title="分栏2"></a>分栏2</h2><p>— column-end —</p>
<h2 id="分栏3"><a href="#分栏3" class="headerlink" title="分栏3"></a>分栏3</h2><p>— end-multi-column</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS代码规范</title>
    <url>/2023/06/24/CSS/CSS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="class-命名"><a href="#class-命名" class="headerlink" title="class 命名"></a>class 命名</h2><p>避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。<br>class 名称应当尽可能短，并且意义明确。<br>随着项目模块增多，防止因为不同页面或者组件中定义的 css 冲突，所以规范 css 语法也变得至关重要，推荐:BEM，分别代表着:<strong>Block(块)、Element(元素)、Modifier(修饰符)</strong></p>
<blockquote>
<p>.user-info {} # user-info 是一个块，我理解是一个模块<br>.user-info–feature {} # user-info–feature 是一个修饰符，用来表示这个块的不同状态<br>.user-info__title{} # user-info__title 是一个元素，属于userinfo模块下的，多个元素组成块</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;user-info&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;user-info__title&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;user-info__age&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabs&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab tab-active&quot;</span>&gt;</span>选中的标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab &quot;</span>&gt;</span>标签二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab &quot;</span>&gt;</span>标签三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="css-属性声明顺序"><a href="#css-属性声明顺序" class="headerlink" title="css 属性声明顺序"></a>css 属性声明顺序</h2><ol>
<li>Positioning</li>
<li>Box model</li>
<li>Typographic</li>
<li>Visual</li>
<li>Misc<br>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。<br>其他属性只是影响组件的 内部 或者是不影响前两组属性，因此排在后面。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.declaration-order</span> &#123;</span><br><span class="line">  <span class="comment">/* Positioning  定位和层级等属性*/</span></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Box-model 盒子模型或者浮动相关*/</span></span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Typography 字体配置*/</span></span><br><span class="line">  <span class="attribute">font</span>: normal <span class="number">13px</span> <span class="string">&quot;Helvetica Neue&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Visual 背景色边框等*/</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Misc 透明度和动画等*/</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>什么是Post CSS？</title>
    <url>/2023/07/30/CSS/%E4%BB%80%E4%B9%88%E6%98%AFPost%20CSS%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-postcss是什么？"><a href="#1-postcss是什么？" class="headerlink" title="1. postcss是什么？"></a>1. postcss是什么？</h2><p>postcss是一个JavaScript 工具，可以用来转换 CSS 代码。postcss可以使用不同插件实现自动添加浏览器前缀，代码合并，代码压缩等等效果。</p>
<h2 id="2-postcss安装"><a href="#2-postcss安装" class="headerlink" title="2. postcss安装"></a>2. postcss安装</h2><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i postcss -g</span><br><span class="line"></span><br><span class="line">npm i postcss-cli -g</span><br></pre></td></tr></table></figure>

<p>运行指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postcss 输入文件路径 -o 输出文件路径</span><br></pre></td></tr></table></figure>

<p>postcss 输入文件路径 -o 输出文件路径。</p>
<p>后面添加 -w ， 可以实时监听。</p>
<h2 id="3-postcss的常用插件"><a href="#3-postcss的常用插件" class="headerlink" title="3. postcss的常用插件"></a>3. postcss的常用插件</h2><h3 id="3-1-自动前缀"><a href="#3-1-自动前缀" class="headerlink" title="3.1 自动前缀"></a>3.1 自动前缀</h3><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i autoprefixer </span><br></pre></td></tr></table></figure>

<p>方式1：创建postcss.config.js文件，配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const autoprefixer = require(&#x27;autoprefixer&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        autoprefixer(&#123;</span><br><span class="line">            browsers:[&quot;&gt;0.5%&quot;]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：使用“browserslist”键在 package.json 文件中配置Browserslist</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;browserslist&quot;: [ </span><br><span class="line">    &quot;defaults&quot;  </span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源文件：</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307301715910.png" alt="image.png"></p>
<p>输出文件：</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307301715744.png" alt="image.png"></p>
<p>常用浏览器前缀：</p>
<ul>
<li>-ms-：IE浏览器私有属性</li>
<li>-moz-： 火狐浏览器私有属性</li>
<li>-o-：Opera浏览器私有属性</li>
</ul>
<h3 id="3-2-检测规范内容"><a href="#3-2-检测规范内容" class="headerlink" title="3.2 检测规范内容"></a>3.2 检测规范内容</h3><p><code>stylelint</code>插件<br>可以参照官网上详细说明：<a href="https://www.npmjs.com/package/stylelint">https://www.npmjs.com/package/stylelint</a></p>
<h3 id="3-3-图片整合"><a href="#3-3-图片整合" class="headerlink" title="3.3 图片整合"></a>3.3 图片整合</h3><p><code>postcss-sprites</code>插件<br>可以参照官网上详细说明：<a href="https://www.npmjs.com/package/postcss-sprites">https://www.npmjs.com/package/postcss-sprites</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「白桃与猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_52395343/article/details/128017872">https://blog.csdn.net/qq_52395343/article/details/128017872</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>Electron webContents</title>
    <url>/2023/08/05/Electron/Electron%20webContents/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是使用webContents的一些示例：</p>
<p><strong>打开开发者工具：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的WebContents</span></span><br><span class="line"><span class="keyword">const</span> webContents = mainWindow.webContents;</span><br><span class="line"><span class="comment">// 打开开发者工具</span></span><br><span class="line">webContents.openDevTools();</span><br></pre></td></tr></table></figure>


<p><strong>导航到指定URL：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的WebContents</span></span><br><span class="line"><span class="keyword">const</span> webContents = mainWindow.webContents;</span><br><span class="line"><span class="comment">// 导航到指定URL</span></span><br><span class="line">webContents.loadURL(<span class="string">&#x27;https://www.example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>发送消息给渲染进程：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ipcMain, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主进程发送消息给渲染进程</span></span><br><span class="line">webContents.send(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;Hello from main process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在渲染进程中接收消息</span></span><br><span class="line">ipcMain.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event, message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message); <span class="comment">// 输出：Hello from main process</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p><strong>捕获页面加载完成事件：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的WebContents</span></span><br><span class="line"><span class="keyword">const</span> webContents = mainWindow.webContents;</span><br><span class="line"><span class="comment">// 页面加载完成事件</span></span><br><span class="line">webContents.on(<span class="string">&#x27;did-finish-load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;页面加载完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p><strong>注入JavaScript到页面中：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的WebContents</span></span><br><span class="line"><span class="keyword">const</span> webContents = mainWindow.webContents;</span><br><span class="line"><span class="comment">// 注入JavaScript到页面中</span></span><br><span class="line">webContents.executeJavaScript(<span class="string">&#x27;alert(&quot;Hello from injected JavaScript&quot;)&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Electron</category>
      </categories>
  </entry>
  <entry>
    <title>生词本1</title>
    <url>/2023/07/19/English/%E7%94%9F%E8%AF%8D%E6%9C%AC1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>[!note]+<br>oriented adj 以…为方向<br>orient v 朝向、面对<br>hood n 兜帽、头巾、暴徒、街区<br>make use of 利用<br>robust adj 强壮的、强健的、健壮的<br>under the hood 在底层<br>myriad adj 无数的 n 无数<br>underlying adj 根本的、底层的 v 位于…之下、构成…的基础<br>philosophy n 哲学、基本原理<br>superb adj 极佳的、质量极高的<br>architecture n 架构、建筑设计<br>out-of-the-box 开箱即用<br>loose adj 松动的、松散的 v 释放、松开、发泄<br>coupled adj 耦合的、成对的、共轭的<br>loosely coupled 低耦合的<br>scaffold v 给…搭脚手架 n 脚手架<br>conventional adj 依照惯例的、常规的<br>populate v 给文件增添数据、居住于<br>invention n 发明物、发明<br>alternative n 替代物、替代选择<br>flavor n 风情、味道<br>boilerplate n 样板文件<br>a lot of ground at 大部分<br>sth be compatible with sth 与…兼容<br>takes advantage of 利用<br>advantage n 优势<br>vanilla adj 普通的<br>requisite n 必需品、必备品<br>fulfill v 实现<br>inbound adj 入境的 n 入站<br>minimalist n 温和政治改良主义者；极简抽象派艺术家<br>overhead n 开销、支出<br>respectively adv 分别地，依次地<br>specify v 明确指出、具体说明<br>exclusively adv 单独地、专门地、仅仅<br>prompt n 提示符<br>at scale 大规模<br>be responsible for 负责…<br>purpose n 目的<br>perform v 执行、表演、表现<br>decorator n 装饰器<br>corresponding adj 相关的<br>validation n 生效、验证<br>repetitive adj 重复的<br>portion n 一部分<br>correspond v 相当于、类似于<br>concatenate v 连接<br>arbitrary adj 随意的、任意的<br>significance n 重要性、意义<br>manipulate v 操纵、操作<br>thus adv 因此<br>furthermore adv 此外、而且<br>except for 除了…<br>signature n 签名<br>compatibility n 兼容性<br>hang v 挂起<br>wildcard n 通配符<br>pattern n 模式<br>asterisk n 星号<br>hyphen n 连字符（-）</p>
</blockquote>
<blockquote>
<p>omit v 省略<br>intercept v 拦截<br>singleton n 单例、单件<br>hence adv 所以<br>for instant 例如<br>multi-tenancy 多租户<br>tenancy n 租期、租用、租约<br>deferred adj 延期的<br>payload n 负荷、载荷<br>transpilation n 转译<br>preserve v 保存、保留 n 保护区<br>reserve v 保存、保留<br>liquidity n 现金、液体<br>thereafter adv 此后<br>breed v 饲养 n 品种<br>separate adj 单独的、分开的 v 分开<br>schema n 模式、架构、纲要、方案<br>wiring up 接线<br>delegate v 授权、委托<br>retrieval n 找回、取回、检索<br>inversion n 相反、倒置、转换<br>occasionally adv 偶然、偶尔<br>tedious adj 冗长的、单调乏味的<br>thus far 迄今<br>circumstance n 情况、环境<br>theoretically adv 理论上地<br>emphasize  v 强调<br>emphasis n 重要性、重调<br>encapsulating  n 封装 v 封进内部<br>capabilities n 能力、力量<br>demonstrate v 演示、游行<br>as seen above 如上所示<br>circular adj 圆形的、环形的<br>elsewhere adv 在别处、去别处<br>ubiquitous adj 普遍存在的、无处不在的<br>manner n 方式、风格、习俗、态度、举止、礼貌</p>
</blockquote>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>生词本</title>
    <url>/2023/07/12/English/%E7%94%9F%E8%AF%8D%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><input disabled="" type="checkbox"> make use of 利用</li>
<li><input disabled="" type="checkbox"> changes over time 随着时间改变</li>
<li><input disabled="" type="checkbox"> prefix it with 以…开头</li>
<li><input disabled="" type="checkbox"> take the opportunity to 抓住机会，借此机会</li>
<li><input disabled="" type="checkbox"> dive right in 立即投入、立即开始做某事</li>
<li><input disabled="" type="checkbox"> to do so 去做、就这么</li>
<li><input disabled="" type="checkbox"> more on this later 稍后详述</li>
<li><input disabled="" type="checkbox"> to recap 回顾</li>
<li><input disabled="" type="checkbox"> get a sense of 了解、感受</li>
<li><input disabled="" type="checkbox"> a taste of 尝试、一点点</li>
<li><input disabled="" type="checkbox"> aim to 目标是… 旨在</li>
<li><input disabled="" type="checkbox"> for instance 例如</li>
<li><input disabled="" type="checkbox"> turn … into … 使…变成…</li>
<li><input disabled="" type="checkbox"> some of the terms 一些术语</li>
<li><input disabled="" type="checkbox"> take place on 发生</li>
<li><input disabled="" type="checkbox"> opt to 选择</li>
<li><input disabled="" type="checkbox"> from scratch 从零开始</li>
<li><input disabled="" type="checkbox"> put … in the pit of 形容一种状态或情感</li>
<li><input disabled="" type="checkbox"> in tens of thousands of 成千上万</li>
<li><input disabled="" type="checkbox"> so far 到目前为止</li>
<li><input disabled="" type="checkbox"> go back and forth 来回走动</li>
</ul>
<blockquote>
<p>interactivity n 交互性<br>possible adj 可能的 n 可能性<br>descriptive adj 描述性的<br>confidence n 信心、自信<br>invaluable adj 极其有用的、极其宝贵的<br>adopt v 接受、领养<br>enable 使、令、使得、启用、允许<br>excel v 擅长、优于<br>scalable adj 可拓展的<br>advanced adj 先进的、高级的 v 发展、前进<br>transition n 转变、过渡、转换<br>auto n 汽车 adj 汽车的<br>instantaneous adj 瞬间发生的<br>recap v 摘要说明 n 概述<br>recap v 扼要重述<br>reduction n 减少、降价、折扣、规约<br>primitives n 基元<br>essential adj 基础的、必要的、本质的<br>summarize v 总结<br>continuing adj 继续的、持续的<br>familiar adj 熟悉的<br>foundation n 地基、基础、基金会<br>basic adj 基础的、简单的 n 基本原则、基本要素<br>structure n 结构、组织、结构体、机构 v 组织、计划、安排<br>integration n 集成、整合<br>performant adj 性能好的、运行良好的<br>consideration n 考量、注意事项<br>compiler n 编译器<br>compiling n 编译、汇编<br>compilation n 编译 、编绘 、汇编 、编制<br>readability n 可读性<br>large-scale 大规模<br>massive adj 大规模的、大而重的<br>resolve v 分解、解析<br>bundle n 捆绑包<br>chunk n 快、区块<br>built-in 内置<br>redundant adj 冗余的、被解雇的<br>appropriate adj 合适的 v 挪用<br>contrast n 差异、对照物 v 对比、对照<br>incremental adj 递增的<br>basis n 基础、基本、要素、方法、理由<br>capable adj 能干的 n 能力、帆<br>geographically adv 在地理上<br>fringe n 边缘、刘海、穗 adj 次要的<br>generalized adj 广义的<br>latency n 延迟、潜在因素</p>
</blockquote>
<blockquote>
<p>scratch v 挠、轻抓 n 划痕<br>otherwise adv 否则、不然<br>pit n 坑、洼<br>intuitive adj 直接的、易懂的<br>prefetch n 预先载入<br>specific adj 明确的、特定的<br>quiz n 小测验<br>quizzes n 小测验（复数）<br>stuck adj 卡住的 v 粘、贴<br>iterate v 迭代</p>
</blockquote>
<blockquote>
<p>forth adv 离去、外出、带来、拿出、自……以后，向前<br>near-instant 几乎即时的<br>serve sth to 送…去…<br>penalize v 惩罚，处罚<br>cumulative adj 积累的，渐增的<br>shift v 移动、转移 n 改变<br>vital adj  至关重要的，必不可少的 n 关键<br>aspect n 方面、层面、角度<br>desire n 期望、渴望、欲望</p>
</blockquote>
<blockquote>
<p>substitution n 代替、替换、代替物<br>registry n 注册处<br>facilitate v 方便、促进、遍历<br>scenarios n 场景、情节、脚本<br>applicable adj 适当的、适用的<br>idle adj 空闲的<br>variety n 多样化、种类、各种各样<br>unintentionally adv 无意地<br>intention n 意图、目的<br>polish v 润色</p>
</blockquote>
<blockquote>
<p>equivalent adj 等同的，等效的 n 对等的人（或事物），对应的人（或事物）</p>
</blockquote>
<blockquote>
<p>sequentially adv 顺序地、从而<br>hierarchy n 等级制度、体系</p>
</blockquote>
<blockquote>
<p>standalone adj 独立的、独立运行的<br>utility n 公共服务、公共事务、实用、有用 adj 有用的、多功能的、实用的</p>
</blockquote>
<h2 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h2><table>
<thead>
<tr>
<th>词组</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>make use of</td>
<td>利用</td>
</tr>
<tr>
<td>changes over time</td>
<td>随着时间改变</td>
</tr>
<tr>
<td>prefix it with</td>
<td>以…开头</td>
</tr>
<tr>
<td>take the opportunity to</td>
<td>抓住机会，借此机会</td>
</tr>
<tr>
<td>dive right in</td>
<td>立即投入、立即开始做某事</td>
</tr>
<tr>
<td>to do so</td>
<td>去做、就这么</td>
</tr>
<tr>
<td>more on this later</td>
<td>稍后详述</td>
</tr>
<tr>
<td>to recap</td>
<td>回顾</td>
</tr>
<tr>
<td>get a sense of</td>
<td>了解、感受</td>
</tr>
<tr>
<td>a taste of</td>
<td>尝试、一点点</td>
</tr>
<tr>
<td>aim to</td>
<td>目标是… 旨在</td>
</tr>
<tr>
<td>for instance</td>
<td>例如</td>
</tr>
<tr>
<td>turn … into …</td>
<td>使…变成…</td>
</tr>
<tr>
<td>some of the terms</td>
<td>一些术语</td>
</tr>
<tr>
<td>take place on</td>
<td>发生</td>
</tr>
<tr>
<td>opt to</td>
<td>选择</td>
</tr>
<tr>
<td>from scratch</td>
<td>从零开始</td>
</tr>
<tr>
<td>put … in the pit of</td>
<td>形容一种状态或情感</td>
</tr>
<tr>
<td>in tens of thousands of</td>
<td>成千上万</td>
</tr>
<tr>
<td>so far</td>
<td>到目前为止</td>
</tr>
<tr>
<td>go back and forth</td>
<td>来回走动</td>
</tr>
<tr>
<td>as well as</td>
<td>也、除、而且、和 、或者</td>
</tr>
<tr>
<td>in addition to</td>
<td>除了…</td>
</tr>
</tbody></table>
<h2 id="关联词"><a href="#关联词" class="headerlink" title="关联词"></a>关联词</h2><table>
<thead>
<tr>
<th>单词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>otherwise</td>
<td>否则</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>基础操作</title>
    <url>/2023/06/24/ESlint/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g eslint</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ESlint</category>
      </categories>
  </entry>
  <entry>
    <title>Drawing 2023-05-06 11.00.41.excalidraw</title>
    <url>/2023/06/24/Excalidraw/Drawing%202023-05-06%2011.00.41.excalidraw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p>
<p>%%</p>
<h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;excalidraw&quot;</span>,<span class="attr">&quot;version&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;source&quot;</span>:<span class="string">&quot;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.17&quot;</span>,<span class="attr">&quot;elements&quot;</span>:[],<span class="attr">&quot;appState&quot;</span>:&#123;<span class="attr">&quot;gridSize&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;viewBackgroundColor&quot;</span>:<span class="string">&quot;#ffffff&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>%%</p>
]]></content>
      <categories>
        <category>Excalidraw</category>
      </categories>
  </entry>
  <entry>
    <title>Drawing 2023-05-29 21.30.43.excalidraw</title>
    <url>/2023/06/24/Excalidraw/Drawing%202023-05-29%2021.30.43.excalidraw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p>
<p>%%</p>
<h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;excalidraw&quot;</span>,<span class="attr">&quot;version&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;source&quot;</span>:<span class="string">&quot;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.17&quot;</span>,<span class="attr">&quot;elements&quot;</span>:[],<span class="attr">&quot;appState&quot;</span>:&#123;<span class="attr">&quot;gridSize&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;viewBackgroundColor&quot;</span>:<span class="string">&quot;#ffffff&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>%%</p>
]]></content>
      <categories>
        <category>Excalidraw</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2023/06/24/Hexo/Hexo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/554333805">Obsidian+Git完美维护Hexo博客 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/daniel_wangt/article/details/107201959">(34条消息) Hexo + Gitee安装部署完整过程_gitee部署hexo_itnwork的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Drawing 2023-06-21 16.25.16.excalidraw</title>
    <url>/2023/06/24/Excalidraw/Drawing%202023-06-21%2016.25.16.excalidraw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p>
<p>%%</p>
<h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;excalidraw&quot;</span>,<span class="attr">&quot;version&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;source&quot;</span>:<span class="string">&quot;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.17&quot;</span>,<span class="attr">&quot;elements&quot;</span>:[],<span class="attr">&quot;appState&quot;</span>:&#123;<span class="attr">&quot;gridSize&quot;</span>:<span class="literal">null</span>,<span class="attr">&quot;viewBackgroundColor&quot;</span>:<span class="string">&quot;#ffffff&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>%%</p>
]]></content>
      <categories>
        <category>Excalidraw</category>
      </categories>
  </entry>
  <entry>
    <title>什么是形参和实参</title>
    <url>/2023/07/29/JS/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h2><p>函数定义的可接受参数</p>
<h4 id="获取形参"><a href="#获取形参" class="headerlink" title="获取形参"></a>获取形参</h4><ol>
<li>通过<code>fn.length</code>获取形参数量</li>
</ol>
<h2 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h2><p>传入函数的实际函数</p>
<h4 id="获取实参"><a href="#获取实参" class="headerlink" title="获取实参"></a>获取实参</h4><ol>
<li>通过<code>argument</code>获取所有的实参，</li>
<li><code>argument</code>是伪数组，有<code>length</code>属性，可通过下标获取参数，不能直接使用数组的方法</li>
</ol>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log(num1 + num2); </span><br><span class="line">&#125; </span><br><span class="line">sum(<span class="number">100</span>, <span class="number">200</span>); </span><br><span class="line"><span class="comment">// 形参和实参个数相等，输出正确结果 sum(100, 400, 500, 700); </span></span><br><span class="line"><span class="comment">// 实参个数多于形参，只取到形参的个数 sum(200); </span></span><br><span class="line"><span class="comment">// 实参个数少于形参，多的形参定义为undefined，结果为NaN</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>bind函数的作用和用法</title>
    <url>/2023/07/29/JS/bind%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Function.prototype.bind() bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.temp);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c, d)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> demo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = hello.bind(demo, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">h(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// out &#x27;demo&#x27; &#x27;1 2 3 4 &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，bind方法实现了更改原函数内部的this指向并返回了一个新函数出来。所以后面要有一个小括号，也就是执行后才会得到对应的结果。bind中里第一个括号里面的第一个参数被当做函数的this，其余参数包括后面执行函数时传入的参数依次被原函数使用（[[什么是柯里化？]]）。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>rest参数的作用和用法</title>
    <url>/2023/07/29/JS/rest%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>…</p>
</blockquote>
<p>在JavaScript中，省略号(…)表示剩余参数语法，可以将多个参数表示为数组。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b, ...args</span>) </span>&#123;   </span><br><span class="line">	<span class="built_in">console</span>.log(args); </span><br><span class="line">&#125; </span><br><span class="line">myFunction(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>


<p>这将输出：[3, 4, 5]</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>理解依赖注入</title>
    <url>/2023/07/21/Others/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>依赖注入(<code>Dependency injection</code>，简称DI)是Angular中的一个基本概念。DI被连接到Angular框架中，它允许带有Angular装饰器的类(比如<code>component</code>、<code>directive</code>、<code>Pipes</code>和<code>Injectables</code>)配置它们需要的依赖项。</p>
<p>依赖依赖系统中存在两个主要角色:<strong>依赖消费者</strong>和<strong>依赖提供者</strong>。</p>
<p>Angular通过一个叫做注入器的抽象来促进依赖消费者和依赖提供者之间的交互。当一个依赖项被请求时，注入器会检查它的注册表，看看那里是否已经有可用的实例。如果没有，则创建一个新实例并将其存储在注册表中。Angular会在应用的引导过程中创建一个应用级注入器(也称为“root”注入器)，还会根据需要创建其他注入器。在大多数情况下，你不需要手动创建注入器，但你应该知道有一个连接提供者和消费者的层。</p>
<p>本主题涵盖了类如何作为依赖项的基本场景。Angular还允许你使用函数、对象、基本类型(如string或Boolean)或任何其他类型作为依赖项。有关更多信息，请参见<a href="https://angular.io/guide/dependency-injection-providers">依赖提供程序</a>。</p>
<h2 id="提供的依赖"><a href="#提供的依赖" class="headerlink" title="提供的依赖"></a>提供的依赖</h2><p>想象一下，有一个叫做<code>HeroService</code>的类需要作为组件中的依赖项。</p>
<p>第一步是添加<code>@Injectable</code>装饰器，以显示该类可以被注入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下一步是通过provide它来使它在DI中可用。一个依赖可以在多个地方provide:</p>
<ul>
<li>在组件级别，使用<code>@Component</code>装饰器的providers字段。在这种情况下，<code>HeroService</code>对该组件的所有实例以及模板中使用的其他组件和指令都是可用的。例如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;hero-list&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">providers</span>: [HeroService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroListComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当您在组件级别注册提供者时，每个组件的新实例都会获得该服务的新实例。</p>
<ul>
<li>在NgModule级别，使用@NgModule装饰器的providers字段。在这种情况下，HeroService对本NgModule或其他NgModule中声明的所有组件、指令和管道都是可用的，只要这些组件、指令和管道位于适用于本NgModule的同一个ModuleInjector中。当你在某个特定的NgModule中注册了一个提供商时，所有组件、指令和管道都可以使用同一个服务实例。要了解所有边缘情况，请参见分层注入器。例如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">  <span class="attr">declarations</span>: [HeroListComponent]</span><br><span class="line">  <span class="attr">providers</span>: [HeroService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroListModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在应用程序根级，这允许将其注入到应用程序中的其他类中。这可以通过在@Injectable装饰器中添加providedIn: ‘root’字段来实现:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Injectable(&#123;</span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当你在根级提供该服务时，Angular会创建一个单独的、共享的<code>HeroService</code>实例，并把它注入到任何请求它的类中。在<code>@Injectable</code>元数据中注册该提供商还允许Angular通过从编译后的应用中删除未使用的服务来优化应用，这个过程被称为<code>tree-shaking</code>。</p>
<h2 id="注入依赖项"><a href="#注入依赖项" class="headerlink" title="注入依赖项"></a>注入依赖项</h2><p>注入依赖项最常见的方法是在类构造函数中声明它。当Angular创建一个组件、指令或管道类的新实例时，它会通过查看构造函数的参数类型来确定该类需要哪些服务或其他依赖项。例如，如果<code>HeroListComponent</code>需要<code>HeroService</code>，它的构造函数可以是这样的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Component(&#123; … &#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroListComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private service: HeroService</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个选择是使用inject方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Component(&#123; … &#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroListComponent</span> </span>&#123;</span><br><span class="line">  private service = inject(HeroService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Angular发现某个组件依赖于某个服务时，它首先会检查注入器中是否存在该服务的实例。如果被请求的服务实例还不存在，注入器就会使用已注册的提供商创建一个，并在将该服务返回给Angular之前把它添加到注入器中。</p>
<p>当所有请求的服务都被解析并返回后，Angular就可以用这些服务作为参数来调用组件的构造函数。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250945448.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>什么是柯里化?</title>
    <url>/2023/07/29/JS/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addOne = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addOneAndTwo = addOne(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> addOneAndTwoAndThree = addOneAndTwo(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addOneAndTwoAndThree);</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的<code>curry</code>帮助函数（<code>helper function</code>）使这类函数的定义和调用更加容易。</p>
<p>用<code>ES6</code>的箭头函数，我们可以将上面的<code>add</code>实现成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">z</span> =&gt;</span> x + y + z;</span><br></pre></td></tr></table></figure>

<p><mark style="background: #FF5582A6;">好像使用箭头函数更清晰了许多</mark>😒。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>#FF</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习路径</title>
    <url>/2023/06/24/React/React%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>React学习路径</p>
<p>React是一个用于构建用户界面的JavaScript库，它提供了一种声明式、组件化和高效的方式来开发前端应用。React的核心思想是使用组件来表示不同的UI元素，然后通过状态和属性来控制组件的渲染和交互。React还支持虚拟DOM技术，可以实现高性能的DOM更新。</p>
<p>如果你想学习React，那么你需要掌握以下几个方面的知识：</p>
<ul>
<li>基础知识：你需要了解JavaScript的基本语法和特性，包括变量、函数、对象、数组、字符串、运算符、条件语句、循环语句等。你还需要熟悉HTML和CSS的基本用法，以及如何在浏览器中使用开发者工具进行调试。</li>
<li>React基础：你需要学习React的基本概念和用法，包括如何创建组件、如何使用JSX语法、如何管理组件的状态和属性、如何使用事件处理器、如何使用生命周期方法等。你还需要了解React的设计原则和最佳实践，以及如何在不同场景下使用类组件或函数组件。</li>
<li>React进阶：你需要学习React的高级特性和技巧，包括如何使用Hooks来简化函数组件的逻辑和副作用管理、如何使用自定义Hooks来复用逻辑和状态、如何使用Context API来实现跨组件的数据共享、如何使用Ref API来访问DOM元素或子组件实例等。你还需要了解React的性能优化策略，以及如何利用DevTools工具进行分析和调试。</li>
<li>React生态：你需要学习React周边的一些库和工具，以及它们与React的集成方式。例如，你可以学习如何使用Redux或MobX来管理应用的全局状态，如何使用Router或Next.js来实现路由导航和服务端渲染，如何使用Material UI或Ant Design等UI框架来提升界面美观度和交互体验，如何使用Webpack或Create React App等构建工具来配置开发环境和打包部署等。</li>
<li>React实战：你需要通过一些项目案例来综合运用所学知识，并且掌握一些常见需求和问题的解决方案。例如，你可以尝试开发一个Todo List应用或一个电商网站，并且实现一些功能模块，比如登录注册、购物车结算、商品列表筛选排序等。你还可以参考一些优秀的开源项目或教程，并且尝试改进或扩展它们。</li>
</ul>
<p>以上就是一个简单而全面的React学习路径，当然这并不是唯一或最佳的路径，每个人根据自己的情况和目标可以有不同的选择。但无论怎样，在学习过程中要保持兴趣和耐心，并且多动手多思考多总结。希望这篇文章对你有所帮助！</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>react中的useEffect</title>
    <url>/2023/08/09/React/react%E4%B8%AD%E7%9A%84useEffect/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>是函数组件中执行的副作用，副作用就是指每次组件更新都会执行的函数，可以用来取代生命周期。</p>
<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;副作用&#x27;</span>);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="2-副作用分为需要清除的和不需要清除"><a href="#2-副作用分为需要清除的和不需要清除" class="headerlink" title="2. 副作用分为需要清除的和不需要清除"></a>2. 副作用分为需要清除的和不需要清除</h2><p>假如设置一个定时器，当组件卸载时需要将定时器关闭，这就是需要清除的。</p>
<p>需要清除的需要在副作用中返回一个函数即可，返回的函数编写需要的代码逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;执行代码逻辑&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不需要清除的就是正常的。</p>
<h2 id="3-传入第二个参数"><a href="#3-传入第二个参数" class="headerlink" title="3. 传入第二个参数"></a>3. 传入第二个参数</h2><p>不传入，则组件更新时就会执行。</p>
<ol>
<li>传入空数组[]</li>
</ol>
<p>则代表只运行一次(仅在组件挂载和卸载时执行),当副作用没有返回函数时可以当做生命周期<code>componentDidMount</code>使用，返回函数时可以当做生命周期<code>componentWillUnmount</code>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当做 componentDidMount使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;页面渲染完成&#x27;</span>);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当做 componentWillUnmount使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;组件卸载&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>传入数组 [item]<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> [ count, setCount ] = useEffect(<span class="number">1</span>);</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行了&#x27;</span>);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当数组不为空时，组件更新时，会检测count的值，若更新后的值与旧值不一样则会调用effect，若相同则会跳过执行。</p>
<p>若数组传入多个参数，只要有一项有变更就会执行effect。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>{.vscode}</title>
    <url>/2023/06/24/VS%20Code/%7B.vscode%7D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>VS Code</category>
      </categories>
  </entry>
  <entry>
    <title>搭建开发环境</title>
    <url>/2023/06/24/React/%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>[object Object]</title>
    <url>/2023/06/24/Template/front-matter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Template</category>
      </categories>
  </entry>
  <entry>
    <title>abstract</title>
    <url>/2023/06/24/TypeScript/abstract/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#面向对象</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>不能实例化，专门用来被继承的类</p>
<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>没有方法体，必须在抽象类中，子类必须重写</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>interface</title>
    <url>/2023/06/24/TypeScript/interface/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#面向对象<br>接口用来定义一个类的结构，或者用作类型声明</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">	age:int;</span><br><span class="line">	sayHello(name:<span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同名interface会合并，而type不会</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">	age:int;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">	<span class="attr">gender</span>:<span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等于</span><br><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">	age:int;</span><br><span class="line">	gender:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接口中的属性不能有实际的值</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>super</title>
    <url>/2023/06/24/TypeScript/super/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#面向对象<br>子类重写构造函数一定要在里面调用super</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>type</title>
    <url>/2023/06/24/TypeScript/type/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#面向对象 </p>
<p>声明一个对象的类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">	<span class="attr">age</span>:int</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj:myType</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>使用Webpack打包ts</title>
    <url>/2023/06/24/TypeScript/%E4%BD%BF%E7%94%A8Webpack%E6%89%93%E5%8C%85ts/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HTMLWebPackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cleanWebPackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 指定入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./index.ts&#x27;</span>,</span><br><span class="line">    <span class="comment">// 指定打包文件所在路径</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定webpack打包要使用哪些模块</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定要加载的规则</span></span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="comment">// 要使用的loader</span></span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//指定加载器</span></span><br><span class="line">                        <span class="attr">loader</span>:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>:&#123;</span><br><span class="line">                            <span class="attr">presets</span>:[</span><br><span class="line">                                <span class="comment">//指定环境的插件</span></span><br><span class="line">                                <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">                                <span class="comment">//配置信息</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">//要兼容的目标浏览器</span></span><br><span class="line">                                    <span class="attr">targets</span>: &#123;</span><br><span class="line">                                        <span class="string">&quot;chrome&quot;</span>:<span class="string">&quot;88&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;ie&quot;</span>:<span class="string">&quot;11&quot;</span></span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    <span class="comment">//指定core.js的版本</span></span><br><span class="line">                                    <span class="string">&quot;corejs&quot;</span>:<span class="string">&quot;3&quot;</span>,</span><br><span class="line">                                    <span class="comment">//使用corejs的方式&quot;usage&quot;表示按需加载</span></span><br><span class="line">                                    <span class="string">&quot;useBuiltIns&quot;</span>:<span class="string">&quot;usage&quot;</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&#x27;ts-loader&#x27;</span>],</span><br><span class="line">                <span class="comment">//要排除的文件</span></span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置webpack插件</span></span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="comment">//清除dist</span></span><br><span class="line">        <span class="keyword">new</span> cleanWebPackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HTMLWebPackPlugin(&#123;</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;自定义html文件的title&#x27;</span>,</span><br><span class="line">            <span class="comment">//指定一个模板</span></span><br><span class="line">            <span class="comment">// template: &#x27;&#x27;,</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//哪些文件可以当作模块引入</span></span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>小技巧</title>
    <url>/2023/06/24/TypeScript/%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-在构造函数里面直接声明属性"><a href="#1-在构造函数里面直接声明属性" class="headerlink" title="1.在构造函数里面直接声明属性"></a>1.在构造函数里面直接声明属性</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title">constructor</span> <span class="title">className</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span>, <span class="keyword">public</span> age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2023/06/24/TypeScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="number-string-boolean"><a href="#number-string-boolean" class="headerlink" title="number,string,boolean"></a>number,string,boolean</h2><p>数字，字符串，布尔型</p>
<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>表示任何类型</p>
<h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p>类型安全的any，unknown的变量不能直接赋值给其他变量</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b: unknown;</span><br><span class="line"><span class="keyword">let</span> bb: <span class="built_in">string</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// b = 123;  //success</span></span><br><span class="line"><span class="comment">// bb = b;  //error</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// b = &#x27;xiaomi&#x27;;</span></span><br><span class="line"><span class="comment">// bb = b;  //error</span></span><br><span class="line"><span class="comment">// 如何成功</span></span><br><span class="line"><span class="comment">/* 类型断言：用来告诉解析器变量的实际类型</span></span><br><span class="line"><span class="comment">    语法：</span></span><br><span class="line"><span class="comment">        变量 as 类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">b = <span class="string">&#x27;xiaomi&#x27;</span>;</span><br><span class="line">bb = b <span class="keyword">as</span> <span class="built_in">string</span>;  <span class="comment">//success</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) bb = b  <span class="comment">//success</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* any类型，不报错,怎么设置都可以，可以赋值给任意变量，可见any真的不到万不得已不能使用 */</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">any</span>;</span><br><span class="line">c = <span class="number">999</span>;</span><br><span class="line">bb = c; <span class="comment">//success  </span></span><br><span class="line"> </span><br><span class="line">c = [<span class="string">&#x27;123&#x27;</span>];</span><br><span class="line">bb = c; <span class="comment">//success</span></span><br></pre></td></tr></table></figure>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>表示没有值或者undefined</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return &#x27;123&#x27;;  //error</span></span><br><span class="line">    <span class="comment">// return &#x27;xiaomi&#x27;; //error</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//success</span></span><br><span class="line">    <span class="comment">// return undefined; //success</span></span><br><span class="line">    <span class="comment">// return null; //success</span></span><br><span class="line">    <span class="comment">//或者不写return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data: <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// data = &#x27;123&#x27;; //error</span></span><br><span class="line"><span class="comment">// data = [123]; //error</span></span><br><span class="line"><span class="comment">// data = undefined; //success</span></span><br><span class="line"><span class="comment">// data = null; //success</span></span><br></pre></td></tr></table></figure>
<h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>从不会出现的值，没有值，不能是任何值,永远不会有返回结果（返回“从不”的函数不能具有可访问的终结点）</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> good: <span class="built_in">never</span>;</span><br><span class="line"><span class="comment">// good = &#x27;123&#x27;; //error</span></span><br><span class="line"><span class="comment">// good = undefined; //error</span></span><br><span class="line"><span class="comment">// good = null; //error</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goodFun</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return &#x27;123&#x27;; //error</span></span><br><span class="line">    <span class="comment">// return;  //error</span></span><br><span class="line">    <span class="comment">// return undefined; //error</span></span><br><span class="line">    <span class="comment">// return null; //error</span></span><br><span class="line">    <span class="comment">// console.log(&#x27;123&#x27;); //error</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>); <span class="comment">//success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>需要留意这两个特殊点</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如要求 name属性，salary属性这两个属性必须要有，其他的属性随便添加修改</span></span><br><span class="line"><span class="comment">// job = &#123; name: &#x27;ios&#x27;, salary: 11, company: &#x27;阿里巴巴&#x27; &#125;; //error，多设置了属性名，此属性名并未在job中声明</span></span><br><span class="line"><span class="comment">// [propName: string]: type; type:any:表示任意类型的属性； type:string:表示属性的值只能为string 同理···</span></span><br><span class="line"><span class="keyword">let</span> job2: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">salary</span>: <span class="built_in">number</span>, [propName: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;</span><br><span class="line">job2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;ios&#x27;</span>, <span class="attr">salary</span>: <span class="number">11</span>, <span class="attr">company</span>: <span class="string">&#x27;阿里巴巴&#x27;</span>, <span class="attr">boss</span>: <span class="string">&#x27;马云&#x27;</span> &#125;;<span class="comment">//success</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如这个时候，我们只想设置一个name，salary不想设置，这个时候是报错的，修改如下</span></span><br><span class="line"><span class="comment">// job = &#123; name: &#x27;ios&#x27; &#125;; //error </span></span><br><span class="line"><span class="keyword">let</span> job1: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, salary?: <span class="built_in">number</span> &#125;  <span class="comment">//属性 ? : type  表示此属性可有可无</span></span><br><span class="line">job1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;android&#x27;</span> &#125;; <span class="comment">//success</span></span><br></pre></td></tr></table></figure>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>两种声明方式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="built_in">number</span>[];</span><br><span class="line"><span class="keyword">let</span> a:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>固定长度的数组，多了少了都不行</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:[<span class="built_in">string</span>,<span class="built_in">string</span>]</span><br><span class="line">a=[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>] <span class="comment">//success</span></span><br><span class="line">a=[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>] <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Gender &#123;</span><br><span class="line">    woman,</span><br><span class="line">    man,</span><br><span class="line">    <span class="comment">//woman = 0,</span></span><br><span class="line">    <span class="comment">//man=1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">gender</span>: Gender &#125;;</span><br><span class="line">person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;科比&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: Gender.man</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (person.gender === Gender.man) <span class="built_in">console</span>.log(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (person.gender === Gender.woman) <span class="built_in">console</span>.log(<span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>类型的就是值，不可变</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="number">10</span>;</span><br><span class="line">a = <span class="number">1</span> <span class="comment">//false</span></span><br><span class="line">a = <span class="string">&#x27;1&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>特殊点</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="string">&#x27;a&#x27;</span>|<span class="number">123</span>|<span class="literal">false</span>;</span><br><span class="line">a = <span class="string">&#x27;a&#x27;</span> <span class="comment">//true</span></span><br><span class="line">a = <span class="number">123</span> <span class="comment">//true</span></span><br><span class="line">a = <span class="literal">false</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>权限修饰符</title>
    <url>/2023/06/24/TypeScript/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>修饰的属性可以在任意位置访问和修改</p>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>私有属性，私有属性只能在类内部进行访问，<br>通过get/set方法可以被外部访问</p>
<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>受保护的属性，只能在当前类和当前类的子类中被访问，不能被实例访问</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>编译配置(tsconfig.json)</title>
    <url>/2023/06/24/TypeScript/%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE(tsconfig.json)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p>需要编译的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">**  <span class="comment">//表示任意目录</span></span><br><span class="line">* <span class="comment">//表示任意文件</span></span><br></pre></td></tr></table></figure>
<h2 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h2><p>不需要的文件</p>
<h2 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h2><p>编译器选项</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>使用的模块系统</p>
<h3 id="outDir"><a href="#outDir" class="headerlink" title="outDir"></a>outDir</h3><p>编译后产生的文件所在的目录</p>
<h3 id="outFile"><a href="#outFile" class="headerlink" title="outFile"></a>outFile</h3><p>编译到一个文件里面</p>
<h3 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h3><p>是否对js进行编译</p>
<h3 id="checkJs"><a href="#checkJs" class="headerlink" title="checkJs"></a>checkJs</h3><p>检查js是否符合规范</p>
<h3 id="removeComments"><a href="#removeComments" class="headerlink" title="removeComments"></a>removeComments</h3><p>是否移除注释</p>
<h3 id="noEmit"><a href="#noEmit" class="headerlink" title="noEmit"></a>noEmit</h3><p>不生成编译后的文件</p>
<h3 id="noEmitOnError"><a href="#noEmitOnError" class="headerlink" title="noEmitOnError"></a>noEmitOnError</h3><p>有错误时不编译</p>
<h3 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a>alwaysStrict</h3><p>编译后的文件是否使用严格模式，默认false</p>
<h3 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h3><p>不允许隐式的any</p>
<h3 id="noImplicitThis"><a href="#noImplicitThis" class="headerlink" title="noImplicitThis"></a>noImplicitThis</h3><p>不允许不明确类型的this</p>
<h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h3><p>严格的检查空值</p>
<h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h3><p>所有严格检查的总开关</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2023/06/26/Vue/Vuex/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="vuex-mutation和action的区别"><a href="#vuex-mutation和action的区别" class="headerlink" title="vuex mutation和action的区别"></a>vuex mutation和action的区别</h2><p>Vuex 中的 mutation 和 action 都是一种改变应用程序状态的方法，它们的目的不同。</p>
<p>Mutation 是 Vuex 中专门用于改变状态的方法。它是一个同步操作，通过 mutation 中定义的方法来修改 state，从而实现状态的响应式更新。Mutation 必须是同步函数，使得 Vuex 能够确保状态的响应式更新，同时也使得开发者能够更容易的去理解和追踪状态的变化记录。</p>
<p>Action 主要用于业务操作和异步操作。Action 可以包含任何异步操作，如发送网络请求或执行定时任务等。使用 Action 可以使代码更加模块化，易于维护。Action 中也可以调用 Mutation 来更新状态，但是当需要在异步操作结束后，才能对状态进行修改的时候，应该使用 Action。</p>
<p>在应用程序中，当需要执行异步操作或者一些复杂的操作时，使用 Action 是更好的选择。而当需要修改状态时，则应该使用 Mutation。</p>
<p>需要注意的是，<mark style="background: #FF5582A6;">Mutation 能够触发组件中的渲染，而 Action 不能触发组件中的渲染</mark>，因此在改变状态的时候，如果需要触发组件中的更新，应该使用 Mutation。</p>
<h2 id="commit和dispatch的区别"><a href="#commit和dispatch的区别" class="headerlink" title="commit和dispatch的区别"></a>commit和dispatch的区别</h2><p>在 Vuex 中，commit 和 dispatch 是用于触发 mutation 和 action 的两个方法，它们的区别如下：</p>
<p>commit：用于触发 mutation，并且只能触发 mutation。它的语法是 store.commit(‘mutationName’)，其中 mutationName 是对应的 mutation 名称。</p>
<p>dispatch：用于触发 action，同时也可以触发 mutation。它的语法是 store.dispatch(‘actionName’)，其中 actionName 是对应的 action 名称。</p>
<p>因此，<mark style="background: #FF5582A6;">dispatch 可以用于处理异步操作</mark>，例如从后端获取数据后再触发相应的 mutation 更新状态；而 <mark style="background: #FF5582A6;">commit 则适用于同步操作</mark>，例如更新状态时直接触发相应的 mutation。</p>
<h2 id="获取vuex的值"><a href="#获取vuex的值" class="headerlink" title="获取vuex的值"></a>获取vuex的值</h2><p>要获取 Vuex 的状态值，可以通过 store.state 访问任何已注册的模块的状态，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex 的状态值</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vuex 的 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; state &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问状态值</span></span><br><span class="line"><span class="built_in">console</span>.log(store.state.count); <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>

<p>如果需要获取某个模块下的状态值，可以使用 store.state.moduleName 的方式，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex 的模块状态值</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vuex 的 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问模块的状态值</span></span><br><span class="line"><span class="built_in">console</span>.log(store.state.moduleA.count); <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>

<p>如果需要获取派生状态值（计算属性），可以使用 store.getters 和 mapGetters 工具函数，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="function"><span class="title">countPlusFive</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.count + <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vuex 的 store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; state, getters &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mapGetters</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">&#x27;countPlusFive&#x27;</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.countPlusFive); <span class="comment">// 输出 5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>总之，获取 Vuex 的状态值应该根据具体的情况选择合适的方式，上面的代码片段只是提供了一些常见的方法。</p>
<h2 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h2><p>mapGetters 是一个辅助函数，可以将 store 中的 getters 映射到局部计算属性中。这个函数返回一个对象，对象的键是与 getters 名称相同，同时也会被映射为组件的局部计算属性。<br>如果你的 Vuex store 分成了多个模块，那么使用 mapGetters 也是类似的。你只需要根据模块的层级关系，按照格式 modulePath/getterName 来书写即可。<br>假设你有一个名为 myModule 的模块，其中有一个 getter 名为 doneTodosCount，那么在使用 mapGetters 时，应该这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// mapGetters 的第一个参数是一个对象，其中的键是新的计算属性的名称，</span></span><br><span class="line">    <span class="comment">// 值则是已声明的 Getter 函数名</span></span><br><span class="line">    ...mapGetters(<span class="string">&#x27;myModule&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// 这里的 &#x27;myModule&#x27; 是模块名称，用于区分 getter 是否为全局的。</span></span><br><span class="line">      <span class="comment">// 注意，如果你是在全局 getters 中定义的 getter，仍需要把模块命名为 &#x27;&#x27;（空字符串）</span></span><br><span class="line">      <span class="string">&#x27;newDoneTodosCount&#x27;</span>: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要同时使用多个 getter，则可以在传递第二个参数时，直接使用 getter 名称组成的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...mapGetters(<span class="string">&#x27;myModule&#x27;</span>, [</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子将 myModule 中的 doneTodosCount 和 anotherGetter 映射到了当前组件的计算属性中。<br>需要注意，如果你使用的是模块的 namespaced 特性，则在传入模块名称时需要加上命名空间前缀，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...mapGetters(<span class="string">&#x27;myModule&#x27;</span>, [</span><br><span class="line">      <span class="string">&#x27;myModule/doneTodosCount&#x27;</span>, <span class="comment">// 注意名字空间前缀</span></span><br><span class="line">      <span class="string">&#x27;myModule/anotherGetter&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，’myModule/‘ 表示模块命名空间前缀。由于 doneTodosCount 和 anotherGetter 函数是在 myModule 模块内定义的，因此需要在函数名称前面加上命名空间前缀 myModule/。这样做的目的是为了在多个模块互相调用时，确保每个函数的名称互不冲突。</p>
<h2 id="监听vuex"><a href="#监听vuex" class="headerlink" title="监听vuex"></a>监听vuex</h2><p>要使用 Vuex Store 的值并在其更改时触发组件上的响应，可以使用$store.watch方法监视 Store 的状态。</p>
<p>使用 this.$store.watch 可以监听 store 中 state 的属性，或者 getters 函数的返回值。watch 方法接收两个参数：</p>
<p>第一个参数是一个函数，用于获取 state 或 getters 的值。<br>第二个参数是回调函数，当监测到更改时会执行它，并传入新值和旧值。<br>例如，如果需要在 Store 中的 count 属性更改时触发组件上的方法，可以这样编写代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.watch(</span><br><span class="line">      <span class="comment">// 监视器函数</span></span><br><span class="line">      <span class="function">(<span class="params">state</span>) =&gt;</span> state.count,</span><br><span class="line">      <span class="comment">// 回调函数</span></span><br><span class="line">      <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 响应数据的更改</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;count 属性的值发生了变化，新值为：&#x27;</span>, newVal)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;旧值为：&#x27;</span>, oldVal)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，mapState 函数用于读取 count 属性的值。在 created 生命周期钩子中，我们通过 this.$store.watch 方法来监听 Store 中 count 属性的更改情况，当被监视的状态发生了变化时，回调函数将被触发。回调函数可以将新值和旧值作为参数传递，并在其中执行一些逻辑。</p>
<p>值得注意的是，除了 watch 方法，还有一些其他的方法可用于监视 Vuex 的状态变化。subscribe 和 subscribeAction 两个方法可用于监听 Mutations 和 Actions 的执行情况，subscribe 方法接受一个回调函数作为参数，而 subscribeAction 方法需要将要监听的 Action 函数名称作为参数。共同之处是，每当对应的 Mutations 或 Actions 执行时，回调函数都会被调用，可以在其中执行一些逻辑。但是，这两个方法都会返回一个用于解除监视的函数，使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = <span class="built_in">this</span>.$store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mutation:&#x27;</span>,mutation,<span class="string">&#x27;state:&#x27;</span>,state)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">unwatch() <span class="comment">// 取消监视</span></span><br><span class="line"><span class="keyword">const</span> unwatchAction = <span class="built_in">this</span>.$store.subscribeAction(<span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;action:&#x27;</span>,action,<span class="string">&#x27;state:&#x27;</span>,state)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">unwatchAction() <span class="comment">// 取消监视</span></span><br></pre></td></tr></table></figure>
<p>以上方法可以帮助你更好地掌控 Vuex Store 的状态，确保组件中能够及时响应 Store 中状态的变化。</p>
<p>我们也可以直接监听 Vuex Store 中的 count 属性，而不必声明额外的计算属性。<br>下面是使用 watch 监听 Vuex Store 中的 count 属性的示例代码：</p>
<p>Vue 组件代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前计数为: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">count</span>: <span class="built_in">this</span>.$store.state.count,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="string">&#x27;$store.state.count&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newCount, oldCount</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(<span class="string">&#x27;count属性的值发生了变化，新值为：&#x27;</span>, newCount)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(<span class="string">&#x27;旧值为：&#x27;</span>, oldCount)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.count = newCount</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>Vuex Store 代码同前面的示例。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>自定义指令1</title>
    <url>/2023/06/24/Vue/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A41/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line">  <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  <span class="function"><span class="title">beforeMount</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  <span class="function"><span class="title">beforeUpdate</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line">  <span class="function"><span class="title">updated</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  <span class="function"><span class="title">beforeUnmount</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  <span class="function"><span class="title">unmounted</span>(<span class="params">el, binding, vnode, prevVnode</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="钩子参数​"><a href="#钩子参数​" class="headerlink" title="钩子参数​"></a>钩子参数<a href="https://cn.vuejs.org/guide/reusability/custom-directives.html#hook-arguments">​</a></h3><p>指令的钩子会传递以下几种参数：</p>
<ul>
<li><code>el</code>：指令绑定到的元素。这可以用于直接操作 DOM。</li>
<li><code>binding</code>：一个对象，包含以下属性。<ul>
<li>  <code>value</code>：传递给指令的值。例如在 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，值是 <code>2</code>。</li>
<li>  <code>oldValue</code>：之前的值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用。无论值是否更改，它都可用。</li>
<li>  <code>arg</code>：传递给指令的参数 (如果有的话)。例如在 <code>v-my-directive:foo</code> 中，参数是 <code>&quot;foo&quot;</code>。</li>
<li>  <code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如在 <code>v-my-directive.foo.bar</code> 中，修饰符对象是 <code>&#123; foo: true, bar: true &#125;</code>。</li>
<li>  <code>instance</code>：使用该指令的组件实例。</li>
<li>  <code>dir</code>：指令的定义对象。</li>
</ul>
</li>
<li><code>vnode</code>：代表绑定元素的底层 VNode。</li>
<li>  <code>prevNode</code>：之前的渲染中代表指令所绑定元素的 VNode。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>国际化</title>
    <url>/2023/06/24/Vue/%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在页面重新加载时重新初始化i18n对象，需要从localstorage读取当前的语言，vuex在页面刷新时会被重置，所以不要通过vuex去初始化i18n</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">&#x27;vue-i18n&#x27;</span></span><br><span class="line"><span class="comment">// import Cookies from &#x27;js-cookie&#x27;</span></span><br><span class="line"><span class="keyword">import</span> locale <span class="keyword">from</span> <span class="string">&#x27;element-ui/lib/locale&#x27;</span></span><br><span class="line"><span class="keyword">import</span> elementEnLocale <span class="keyword">from</span> <span class="string">&#x27;element-ui/lib/locale/lang/en&#x27;</span> <span class="comment">// element-ui lang</span></span><br><span class="line"><span class="keyword">import</span> elementZhLocale <span class="keyword">from</span> <span class="string">&#x27;element-ui/lib/locale/lang/zh-CN&#x27;</span><span class="comment">// element-ui lang</span></span><br><span class="line"><span class="keyword">import</span> enLocale <span class="keyword">from</span> <span class="string">&#x27;./en&#x27;</span></span><br><span class="line"><span class="keyword">import</span> zhLocale <span class="keyword">from</span> <span class="string">&#x27;./zh&#x27;</span></span><br><span class="line">Vue.use(VueI18n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">  <span class="attr">en</span>: &#123;</span><br><span class="line">    ...enLocale,</span><br><span class="line">    ...elementEnLocale</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">zh</span>: &#123;</span><br><span class="line">    ...zhLocale,</span><br><span class="line">    ...elementZhLocale</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n(&#123;</span><br><span class="line">  <span class="comment">// 设置语言 选项 en | zh</span></span><br><span class="line">  <span class="comment">// locale: Cookies.get(&#x27;language&#x27;) || &#x27;en&#x27;,</span></span><br><span class="line">  <span class="attr">locale</span>: <span class="built_in">localStorage</span>.lang || <span class="string">&#x27;zh&#x27;</span>, <span class="comment">//初始默认 cn 中文</span></span><br><span class="line">  <span class="comment">// 设置文本内容</span></span><br><span class="line">  messages</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">locale.i18n(<span class="function">(<span class="params">key, value</span>) =&gt;</span> i18n.t(key, value)) <span class="comment">//兼容element</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n</span><br></pre></td></tr></table></figure>

<p>修改语言要通过全局的<code>this.$i18n.locale</code>对象来修改，同时要修改localstorage中语言的值</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>A股，B股，H股</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/A%E8%82%A1%EF%BC%8CB%E8%82%A1%EF%BC%8CH%E8%82%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A股：注册地在大陆境内，上海或深圳交易所，人民币买卖股票<br>B股：注册地在大陆境内，上海或深圳交易所，美元或港币交易<br>H股：注册地在大陆境内，香港交易所，港币进行交易</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>一级市场与二级市场</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E4%B8%80%E7%BA%A7%E5%B8%82%E5%9C%BA%E4%B8%8E%E4%BA%8C%E7%BA%A7%E5%B8%82%E5%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一级市场：投资者与上市公司交易的地方<br>二级市场：投资者与投资者交易的地方</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>上市公司与IPO</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E4%B8%8A%E5%B8%82%E5%85%AC%E5%8F%B8%E4%B8%8EIPO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IPO(首次公开募股)<br>IPO之后才是上市公司</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>公募基金与私募基金</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E5%85%AC%E5%8B%9F%E5%9F%BA%E9%87%91%E4%B8%8E%E7%A7%81%E5%8B%9F%E5%9F%BA%E9%87%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>私募基金只对指定人</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>开放基金、封闭基金、ETF基金</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E5%BC%80%E6%94%BE%E5%9F%BA%E9%87%91%E3%80%81%E5%B0%81%E9%97%AD%E5%9F%BA%E9%87%91%E3%80%81ETF%E5%9F%BA%E9%87%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开放基金申购赎回不受时间限制<br>封闭基金在封闭期间无法赎回</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>基金的投资方向</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E5%9F%BA%E9%87%91%E7%9A%84%E6%8A%95%E8%B5%84%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>股票型基金<br>债券型基金<br>混合型基金<br>货币型基金</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>注册制和核准制</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E6%B3%A8%E5%86%8C%E5%88%B6%E5%92%8C%E6%A0%B8%E5%87%86%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>核准制更严格，需要对公司价值做出评估</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>炒股最小单位</title>
    <url>/2023/06/24/%E7%90%86%E8%B4%A2/%E7%82%92%E8%82%A1%E6%9C%80%E5%B0%8F%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一手：100股</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
  </entry>
  <entry>
    <title>开始学习 Tailwind CSS</title>
    <url>/2023/07/29/CSS/Tailwind/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%20Tailwind%20CSS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Tailwind CSS的工作原理是扫描所有HTML文件、JavaScript组件和任何其他模板中的类名，生成相应的样式，然后将它们写入静态CSS文件。</p>
<p>它快速、灵活、可靠——运行时间为零。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Tailwind-CLI"><a href="#Tailwind-CLI" class="headerlink" title="Tailwind CLI"></a>Tailwind CLI</h3><p>从头开始使用 Tailwind CSS 的最简单和最快的方法是使用 Tailwind CLI 工具。如果您想在不安装 Node.js 的情况下使用它，那么 CLI 也可以作为独立的可执行文件使用。</p>
<ol>
<li>安装 Tailwind CSS<ol>
<li>通过 npm 安装 tailwindcss，创建你的<code>tailwind.config.js</code>文件</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss</span><br><span class="line">npx tailwindcss init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置你的模板路径<ol>
<li>将所有模板文件的路径添加到<code>tailwind.config.js</code>文件中。</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  content: [&quot;./src/**/*.&#123;html,js&#125;&quot;],</span><br><span class="line">  theme: &#123;</span><br><span class="line">    extend: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加 Tailwind 指令到你的 CSS<ol>
<li>将每个Tailwind层的<code>@tailwind</code>指令添加到你的主CSS文件中。</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@tailwind base;</span><br><span class="line">@tailwind components;</span><br><span class="line">@tailwind utilities;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开始 Tailwind CLI 构建过程<ol>
<li>运行CLI工具扫描模板文件中的类并构建CSS</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx tailwindcss -i ./src/input.css -o ./dist/output.css --watch</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>开始在你的 HTML 中使用 Tailwind CSS<ol>
<li>将编译好的CSS文件添加到<code>&lt;head&gt;</code>中，并开始使用Tailwind的实用程序类来设计内容的样式。</li>
</ol>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/dist/output.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-3xl font-bold underline&quot;</span>&gt;</span></span><br><span class="line">    Hello world!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-PostCSS"><a href="#使用-PostCSS" class="headerlink" title="使用 PostCSS"></a>使用 PostCSS</h2><p>将 Tailwind CSS 作为 PostCSS 插件安装是将其与<code>Webpack, Rollup, Vite和Parcel</code>等构建工具集成的最无缝的方式。</p>
<ol>
<li>安装 Tailwind CSS<ol>
<li>通过npm安装tailwindcss和它的同级依赖，并创建tailwind.config.js文件。</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss postcss autoprefixer</span><br><span class="line">npx tailwindcss init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将Tailwind CSS添加到你的PostCSS配置<ol>
<li>将tailwindcss和autoprefixer添加到<code>postcss.config.js</code>文件中，或者在项目中配置PostCSS的任何地方。</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    tailwindcss: &#123;&#125;,</span><br><span class="line">    autoprefixer: &#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置你的模板路径<ol>
<li>将这些路径添加到<code>tailwind.config.js</code>文件中的所有模板文件中。</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  content: [&quot;./src/**/*.&#123;html,js&#125;&quot;],</span><br><span class="line">  theme: &#123;</span><br><span class="line">    extend: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>添加Tailwind CSS指令到你的CSS<ol>
<li>将每个Tailwind层的<code>@tailwind</code>指令添加到你的主CSS文件中。</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@tailwind base;</span><br><span class="line">@tailwind components;</span><br><span class="line">@tailwind utilities;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>开始构建<ol>
<li>使用<code>npm run dev</code>或<code>package.json</code>中配置的任何命令运行构建过程。</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>开始在HTML中使用Tailwind<ol>
<li>确保编译后的CSS包含在<code>&lt;head&gt;</code>中(您的框架可能会为您处理此问题)，然后开始使用Tailwind的实用程序类来样式化您的内容。</li>
</ol>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/dist/main.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-3xl font-bold underline&quot;</span>&gt;</span></span><br><span class="line">    Hello world!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
        <category>Tailwind</category>
      </categories>
  </entry>
  <entry>
    <title>@font-face</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/@font-face/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>@media</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/@media/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>@media</strong> 规则在媒体查询中用于为不同的媒体类型/设备应用不同的样式。<br>媒体查询可用于检查许多事情，诸如：</p>
<blockquote>
<p>视口的宽度和高度<br>设备的宽度和高度<br>方向（手机或平板电脑处于横屏还是竖屏模式？）<br>分辨率</p>
</blockquote>
<h2 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h2><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>默认。用于所有媒体类型设备。</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机。</td>
</tr>
<tr>
<td>screen</td>
<td>用于计算机屏幕、平板电脑、智能手机等。</td>
</tr>
<tr>
<td>speech</td>
<td>用于朗读页面的屏幕阅读器。</td>
</tr>
</tbody></table>
<h2 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h2><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>any-hover</td>
<td>是否有任何可用的输入机制允许用户（将鼠标等）悬停在元素上？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>any-pointer</td>
<td>可用的输入机制中是否有任何指针设备，如果有，它的精度如何？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>aspect-ratio</td>
<td>视口（viewport）的宽高比。</td>
</tr>
<tr>
<td>color</td>
<td>输出设备每个像素的比特值，常见的有 8、16、32 位。如果设备不支持输出彩色，则该值为 0。</td>
</tr>
<tr>
<td>color-gamut</td>
<td>用户代理和输出设备大致程度上支持的色域。在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>color-index</td>
<td>输出设备的颜色查询表（color lookup table）中的条目数量。如果设备不使用颜色查询表，则该值为 0。</td>
</tr>
<tr>
<td>device-aspect-ratio</td>
<td>输出设备的宽高比。已在 Media Queries Level 4 中被弃用。</td>
</tr>
<tr>
<td>device-height</td>
<td>输出设备渲染表面（如屏幕）的高度。已在 Media Queries Level 4 中被弃用。</td>
</tr>
<tr>
<td>device-width</td>
<td>输出设备渲染表面（如屏幕）的宽度。已在 Media Queries Level 4 中被弃用。</td>
</tr>
<tr>
<td>display-mode</td>
<td>应用程序的显示模式，如 web app 的 manifest 中的 display 成员所指定在 Web App Manifest spec 被定义。</td>
</tr>
<tr>
<td>forced-colors</td>
<td>检测是用户代理否限制调色板。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>grid</td>
<td>输出设备使用网格屏幕还是点阵屏幕？</td>
</tr>
<tr>
<td>height</td>
<td>视口（viewport）的高度。</td>
</tr>
<tr>
<td>hover</td>
<td>主输入机制是否允许用户将鼠标悬停在元素上？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>inverted-colors</td>
<td>浏览器或者底层操作系统是否反转了颜色。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>light-level</td>
<td>当前环境光水平。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>max-aspect-ratio</td>
<td>显示区域的宽度和高度之间的最大比例。</td>
</tr>
<tr>
<td>max-color</td>
<td>输出设备每个颜色分量的最大位数。</td>
</tr>
<tr>
<td>max-color-index</td>
<td>设备可以显示的最大颜色数。</td>
</tr>
<tr>
<td>max-height</td>
<td>显示区域的最大高度，例如浏览器窗口。</td>
</tr>
<tr>
<td>max-monochrome</td>
<td>单色（灰度）设备上每种“颜色”的最大位数。</td>
</tr>
<tr>
<td>max-resolution</td>
<td>设备的最大分辨率，使用 dpi 或 dpcm。</td>
</tr>
<tr>
<td>max-width</td>
<td>显示区域的最大宽度，例如浏览器窗口。</td>
</tr>
<tr>
<td>min-aspect-ratio</td>
<td>显示区域的宽度和高度之间的最小比例。</td>
</tr>
<tr>
<td>min-color</td>
<td>输出设备每个颜色分量的最小位数。</td>
</tr>
<tr>
<td>min-color-index</td>
<td>设备可以显示的最小颜色数。</td>
</tr>
<tr>
<td>min-height</td>
<td>显示区域的最小高度，例如浏览器窗口。</td>
</tr>
<tr>
<td>min-monochrome</td>
<td>单色（灰度）设备上每种“颜色”的最小位数。</td>
</tr>
<tr>
<td>min-resolution</td>
<td>设备的最低分辨率，使用 dpi 或 dpcm。</td>
</tr>
<tr>
<td>min-width</td>
<td>显示区域的最小宽度，例如浏览器窗口。</td>
</tr>
<tr>
<td>monochrome</td>
<td>输出设备单色帧缓冲区中每个像素的位深度。如果设备并非黑白屏幕，则该值为 0。</td>
</tr>
<tr>
<td>orientation</td>
<td>视窗（viewport）的旋转方向（横屏还是竖屏模式）。</td>
</tr>
<tr>
<td>overflow-block</td>
<td>输出设备如何处理沿块轴溢出视口(viewport)的内容。在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>overflow-inline</td>
<td>沿内联轴溢出视口(viewport)的内容是否可以滚动？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>pointer</td>
<td>主要输入机制是一个指针设备吗？如果是，它的精度如何？在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>prefers-color-scheme</td>
<td>探测用户倾向于选择亮色还是暗色的配色方案。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-contrast</td>
<td>探测用户是否有向系统要求提高或降低相近颜色之间的对比度。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-reduced-motion</td>
<td>用户是否希望页面上出现更少的动态效果。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-reduced-transparency</td>
<td>用户是否倾向于选择更低的透明度。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>resolution</td>
<td>输出设备的分辨率，使用 dpi 或 dpcm。</td>
</tr>
<tr>
<td>scan</td>
<td>输出设备的扫描过程（适用于电视等）。</td>
</tr>
<tr>
<td>scripting</td>
<td>探测脚本（例如 JavaScript）是否可用。在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>update</td>
<td>输出设备更新内容的渲染结果的频率。在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>width</td>
<td>视窗（viewport）的宽度。</td>
</tr>
</tbody></table>
<h2 id="not、only-和-and-关键字的含义："><a href="#not、only-和-and-关键字的含义：" class="headerlink" title="not、only 和 and 关键字的含义："></a>not、only 和 and 关键字的含义：</h2><ol>
<li><strong>not</strong>：not 关键字反正整个媒体查询的含义。</li>
<li><strong>only</strong>：only 关键字可防止旧版浏览器应用指定的样式，这些浏览器不支持带媒体特性的媒体查询。它对现代浏览器没有影响。</li>
<li><strong>and</strong>：and 关键字将媒体特性与媒体类型或其他媒体特性组合在一起。</li>
</ol>
<p>它们都是可选的。但是，如果使用 not 或 only，则还必须指定媒体类型。</p>
<p>您还可以针对不同的媒体使用不同的样式表，就像这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width: 900px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;widescreen.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (max-width: 600px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;smallscreen.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-class">.example</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>@property</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/@property/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>@property是一个新增的CSS @规则(CSS at-rule)，它是<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini">CSS Houdini</a> API的一部分, 它允许开发者显式地定义css自定义属性，并允许进行属性类型检查、设定默认值以及定义该自定义属性是否可以被继承。@property可以直接在样式表中注册自定义属性，无需运行任何JS代码；同时也配备相应的JS语法注册自定义属性。@property自定义属性，是CSS变量(CSS variables)声明变量的升级版本，比CSS变量更加规范和严谨。</p>
<h2 id="基础语法规则"><a href="#基础语法规则" class="headerlink" title="基础语法规则"></a>基础语法规则</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> &lt;custom-property-name&gt; &#123;</span><br><span class="line">  &lt;declaration-list&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="declaration-list"><a href="#declaration-list" class="headerlink" title="declaration-list"></a>declaration-list</h3><p>声明字段包括 syntax 、inherits 和 initial-value</p>
<ol>
<li><strong>syntax</strong> ：类型string。定义自定义属性的类型。例如，number，color，percentage等</li>
<li><strong>inherits</strong>：类型boolean。定义自定义属性是否允许继承</li>
<li><strong>initial-value</strong>：类型符合 syntax 定义的类型，定义初始值</li>
<li><strong>syntax</strong> 和 <strong>inherits</strong> 描述符是必需的，其中任何一项缺失, 整条规则都将失效并且会被忽略</li>
<li><strong>initial-value</strong> 描述符仅在 syntax 描述符为通用syntax定义时是可选的，否则也是必需的</li>
</ol>
<h3 id="syntax-可用有效字段"><a href="#syntax-可用有效字段" class="headerlink" title="syntax 可用有效字段"></a>syntax 可用有效字段</h3><p>注册自定义属性时，可以使用CSS值和单位规范中的许多受支持的语法 - &lt; length &gt; - &lt; number &gt; - &lt; percentage &gt; - &lt; length-percentage &gt; - &lt; color &gt; - &lt; image &gt; - &lt; url &gt; - &lt; integer &gt; - &lt; angle &gt; - &lt; time &gt; - &lt; resolution &gt; - &lt; transform-list &gt; - &lt; transform-function &gt; - &lt; custom-ident &gt; (a custom identifier string)</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> --primary-color &#123;</span><br><span class="line">  syntax: <span class="string">&#x27;&lt;color&gt;&#x27;</span>;</span><br><span class="line">  inherits: false;</span><br><span class="line">  <span class="attribute">initial</span>-value: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    --primary-<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--primary-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/409933240">一起了解一下css新特性@property - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 单位</title>
    <url>/2023/07/22/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/CSS%20%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p><code>rem(root em)</code>是相对单位；rem单位是相对于HTML标签的字号计算结果；<code>1rem = 1HTML字号大小</code>。</p>
<p>如果<span style="background:#ff4d4f">html标签</span>的<strong>font-size是20px，那么1rem就是20</strong>。</p>
<h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p><strong>em(相对长度单位，相对于当前对象内文本的字体尺寸)<strong>：是一个相对长度单位，最初是指<code>字母M的宽度</code>，故名em。现指的是</strong>字符宽度的倍数</strong>，用法类似百分比，如：0.8em, 1.2em,2em等。通常1em=16px。em单位的大小是相对于<code>父元素</code>字体大小计算的，因此当父元素的字体大小设置改变时，em单位的值也会跟着变化。</p>
<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>**px (pixel，像素)**：是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果px要换算成物理长度，需要指定精度DPI(Dots Per Inch，每英寸像素数)，在扫描打印时一般都有DPI可选。Windows系统默认是96dpi，Apple系统默认是72dpi。</p>
<p><strong>px=1/dpi(英寸)</strong></p>
<h2 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h2><p>**pt (point，磅)**：是一个物理长度单位，指的是72分之一英寸。<code>pt=1/72(英寸), px=1/dpi(英寸)</code></p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>focus-visible 和 focus</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/focus-visible%20%E5%92%8C%20focus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>focus-visible</strong>用于使用键盘获得焦点时显示的样式</p>
<p><strong>focus</strong>用于使用鼠标时获得焦点显示的样式</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>SVG</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/SVG/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是SVG"><a href="#什么是SVG" class="headerlink" title="什么是SVG"></a>什么是SVG</h2><p><strong>SVG（Scalable Vector Graphics）是一种基于 XML 的标记语言，用于描述二维矢量图形</strong>。简单地说，<font color="#76923c">SVG 之于图像就像 HTML 之于文本</font>。顾名思义，与光栅图像（JPG、GIF 和 PNG）不同，SVG 允许您在不损失图像质量的情况下任意放大或缩小矢量图像。</p>
<blockquote>
<ul>
<li>  SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
<li>  SVG 用来定义用于网络的基于矢量的图形</li>
<li>  SVG 使用 XML 格式定义图形</li>
<li>  SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li>
<li>  SVG 是万维网联盟的标准</li>
<li>  SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li>
</ul>
</blockquote>
<hr>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><blockquote>
<ul>
<li>  [[SVG]] 可被非常多的工具读取和修改（比如记事本）</li>
<li>  SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。</li>
<li>  SVG 是可伸缩的</li>
<li>  SVG 图像可在任何的分辨率下被高质量地打印</li>
<li>  SVG 可在图像质量不下降的情况下被放大</li>
<li>  SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）</li>
<li>  SVG 可以与 JavaScript 技术一起运行</li>
<li>  SVG 是开放的标准</li>
<li>  SVG 文件是纯粹的 XML</li>
</ul>
</blockquote>
<hr>
<h2 id="svg在html中"><a href="#svg在html中" class="headerlink" title="svg在html中"></a>svg在html中</h2><p>通过以下标签嵌入 HTML 文档：<code>&lt;embed&gt;</code>、<code>&lt;object&gt;</code> 或者 <code>&lt;iframe&gt;</code><br>也可以直接嵌入到HTML页面中，或您可以直接链接到SVG文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;circle1.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;circle1.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;circle1.svg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;40&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;red&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;circle1.svg&quot;</span>&gt;</span>查看 SVG 文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SVG矩形"><a href="#SVG矩形" class="headerlink" title="SVG矩形"></a>SVG矩形</h2><p><code>&lt;rect&gt;</code> 标签可用来创建矩形，以及矩形的变种</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  rect 元素的 width 和 height 属性可定义矩形的高度和宽度</li>
<li>  style 属性用来定义 CSS 属性</li>
<li>  CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）</li>
<li>  CSS 的 stroke-width 属性定义矩形边框的宽度</li>
<li>  CSS 的 stroke 属性定义矩形边框的颜色</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;fill:blue; stroke :pink;stroke-width:5;fill-opacity:0.1;  </span></span></span><br><span class="line"><span class="string"><span class="tag">  stroke-opacity:0.9&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  x 属性定义矩形的左侧位置（例如，x=”0” 定义矩形到浏览器窗口左侧的距离是 0px）</li>
<li>  y 属性定义矩形的顶端位置（例如，y=”0” 定义矩形到浏览器窗口顶端的距离是 0px）</li>
<li>  CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1）</li>
<li>  CSS 的 stroke-opacity 属性定义轮廓颜色的透明度（合法的范围是：0 - 1）</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;fill:blue; stroke :pink;stroke-width:5;opacity:0.5&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  CSS opacity 属性用于定义了元素的透明值 (范围: 0 到 1)。</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;20&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;20&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;fill:red; stroke :black;stroke-width:5;opacity:0.5&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  rx 和 ry 属性可使矩形产生圆角。</li>
</ul>
</blockquote>
<h2 id="SVG圆形"><a href="#SVG圆形" class="headerlink" title="SVG圆形"></a>SVG圆形</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;40&quot;</span> <span class="attr">stroke</span> =<span class="string">&quot;black&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;red&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  cx和cy属性定义圆点的x和y坐标。如果省略cx和cy，圆的中心会被设置为(0, 0)</li>
<li>  r属性定义圆的半径</li>
</ul>
</blockquote>
<h2 id="SVG椭圆"><a href="#SVG椭圆" class="headerlink" title="SVG椭圆"></a>SVG椭圆</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;300&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;80&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;50&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:yellow; stroke :purple;stroke-width:2&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  CX属性定义的椭圆中心的x坐标</li>
<li>  CY属性定义的椭圆中心的y坐标</li>
<li>  RX属性定义的水平半径</li>
<li>  RY属性定义的垂直半径</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;240&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;100&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;220&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;30&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:purple&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;220&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;70&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;190&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;20&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:lime&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;210&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;45&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;170&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;15&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:yellow&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;240&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;220&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;30&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:yellow&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;220&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;190&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;20&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:white&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SVG直线"><a href="#SVG直线" class="headerlink" title="SVG直线"></a>SVG直线</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;200&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot; stroke :rgb(255,0,0);stroke-width:2&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>  x1 属性在 x 轴定义线条的开始</li>
<li>  y1 属性在 y 轴定义线条的开始</li>
<li>  x2 属性在 x 轴定义线条的结束</li>
<li>  y2 属性在 y 轴定义线条的结束</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>align-content,justify-content,align-items,justify-items</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/align-content,justify-content,align-items,justify-items/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>![[Pasted image 20230404194422.png]]</p>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><h2 id="Some-Questions"><a href="#Some-Questions" class="headerlink" title="Some Questions"></a>Some Questions</h2><h4 id="align-items-既能控制-flex-布局又能控制-grid-布局的对齐方向吗"><a href="#align-items-既能控制-flex-布局又能控制-grid-布局的对齐方向吗" class="headerlink" title="align-items 既能控制 flex 布局又能控制 grid 布局的对齐方向吗?"></a>align-items 既能控制 flex 布局又能控制 grid 布局的对齐方向吗?</h4><p><strong>答</strong>：是的，align-items 属性可以用于 flex 布局和 grid 布局，它们的作用是类似的，都是用来控制容器中的项目在交叉轴方向上的对齐方式。不过，它们也有一些区别，比如：</p>
<p>•  在 flex 布局中，交叉轴是与主轴垂直的轴，它的方向取决于 flex-direction 的值。在 grid 布局中，交叉轴是与网格行平行的轴，它的方向取决于 writing-mode 和 direction 的值。</p>
<p>•  在 flex 布局中，align-items 只能对齐单行或单列的 flex 项目，如果要对齐多行或多列的 flex 项目，需要使用 align-content 属性。在 grid 布局中，align-items 可以对齐任意数量的网格项，不需要使用 align-content 属性。</p>
<p>•  在 flex 布局中，align-items 的默认值是 stretch ，在 grid 布局中，align-items 的默认值是 normal </p>
<h4 id="什么是交叉轴？"><a href="#什么是交叉轴？" class="headerlink" title="什么是交叉轴？"></a>什么是交叉轴？</h4><p><strong>答</strong>：交叉轴是与主轴垂直的轴，它的方向取决于主轴的方向。在 flex 布局和 grid 布局中，交叉轴可以用来控制容器中的项目在垂直于主轴的方向上的对齐方式。(developer.mozilla.org)(developer.mozilla.org)</p>
<p>在 flex 布局中，如果主轴是水平方向（flex-direction: row 或 row-reverse），那么交叉轴就是从上至下地垂直走向的。如果主轴是垂直方向（flex-direction: column 或 column-reverse），那么交叉轴就是水平走向的。(developer.mozilla.org)(developer.mozilla.org)</p>
<p>在 grid 布局中，交叉轴是与网格行平行的轴，它的方向取决于 writing-mode 和 direction 的值。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>hsl()和hsla()</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/hsl()%E5%92%8Chsla()/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="hsl"><a href="#hsl" class="headerlink" title="hsl()"></a>hsl()</h2><p><strong>HSL</strong> 即：<strong>色相</strong>（Hue）、<strong>饱和度</strong>（ Saturation ）、<strong>亮度</strong>（ Lightness ）。</p>
<blockquote>
<p>色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。<br>饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取0 ~ 100%的数值。<br>亮度（L），取0 ~ 100%，增加亮度，颜色会向白色变化；减少亮度，颜色会像黑色变化。</p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hue - 色相</td>
<td>定义色相（0到360）-0（或360）为红色，120为绿色，240为蓝色</td>
</tr>
<tr>
<td>saturation - 饱和度</td>
<td>定义饱和度；0%为灰色，100%全白</td>
</tr>
<tr>
<td>lightness - 亮度</td>
<td>定义亮度0%为暗，50%为普通，100%为白</td>
</tr>
</tbody></table>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hsl(hue, saturation , lightness); </span><br></pre></td></tr></table></figure>

<h2 id="hsla"><a href="#hsla" class="headerlink" title="hsla()"></a>hsla()</h2><p><strong>HSLA</strong> 即：色相、饱和度、亮度、<strong>透明度</strong>（英语：Hue, Saturation , Lightness , Alpha ）。</p>
<blockquote>
<p>透明度（A） 取值 0~1 之间， 代表透明度。</p>
</blockquote>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hsla(hue, saturation , lightness ,alpha)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>place-items</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/place-items/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 中的 <strong><code>place-items</code></strong> 是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties">简写属性</a> ，它允许你在相关的布局（如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout">Grid</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">Flexbox</a>）中可以同时沿着块级和内联方向对齐元素 (例如：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-items"><code>justify-items</code></a> 属性) 。如果未提供第二个值，则第一个值作为第二个值的默认值。</p>
<blockquote>
<p><strong>先竖后横</strong></p>
</blockquote>
<h2 id="构成属性"><a href="#构成属性" class="headerlink" title="构成属性"></a>构成属性</h2><p>该属性是以下两个 CSS 属性的简写：</p>
<ul>
<li>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a></li>
<li>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-items"><code>justify-items</code></a></li>
</ul>
<h2 id="形式语法"><a href="#形式语法" class="headerlink" title="形式语法"></a>形式语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items =   </span><br><span class="line">  &lt;&#x27;<span class="attribute">align-items</span>&#x27;&gt; &lt;&#x27;justify-items&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><ul>
<li><code>auto</code></li>
</ul>
<p><code>auto</code> 实际的值继承父自元素的 <code>justify-items</code> 值，除非该元素没有父元素或是用了绝对定位。在这些示例中，<code>auto</code> 表示 <code>normal</code> 。</p>
<ul>
<li><code>normal</code></li>
</ul>
<p><code>normal</code> 的效果取决于我们使用哪种布局方式：</p>
<p>  在块级布局中，<code>normal</code> 和 <code>start</code> 一样。<br>  在绝对定位布局中，关键字在_被替换的_绝对定位元素上的行为类似于 <code>start</code>，在_所有其他_绝对定位的元素上表现类似 <code>stretch</code>。<br>  在表格单元格布局中，此关键字没有意义，因为该属性_被忽略_。<br>  在 flexbox 布局中，此关键字没有意义，因为该属性_被忽略_。<br>  在 grid 布局中，此关键字和 <code>stretch</code> 的行为相似，但是具有宽高比和固有尺寸的元素行为和 <code>start</code> 相似。</p>
<ul>
<li><code>start</code></li>
</ul>
<p>在适当的轴线上，元素块沿着对齐容器的起始边缘对齐。</p>
<ul>
<li><code>end</code></li>
</ul>
<p>在适当的轴线上，元素块沿着对齐容器的结束边缘对齐。</p>
<ul>
<li><code>flex-start</code></li>
</ul>
<p>对齐方式取决于 flex 容器的的开始方向。（水平和垂直两个方向） 这只对 flex 布局元素生效，对于不是 flex 容器的子元素，它被视为 <code>start</code> 。</p>
<ul>
<li><code>flex-end</code></li>
</ul>
<p>对齐方式取决于 flex 容器的的结束方向。（水平和垂直两个方向） 这只对 flex 布局元素生效，对于不是 flex 容器的子元素，它被视为 end。</p>
<ul>
<li><code>self-start</code></li>
</ul>
<p>沿着轴线的头部对齐。</p>
<ul>
<li><code>self-end</code></li>
</ul>
<p>沿着轴线的尾部对齐。</p>
<ul>
<li><code>center</code></li>
</ul>
<p>沿着对齐容器的中心对齐。</p>
<ul>
<li><code>left</code></li>
</ul>
<p>沿着对齐容器的左侧对齐，如果属性的轴不与内联轴平行，则该值的行为和 <code>start</code> 类似。</p>
<ul>
<li><code>right</code></li>
</ul>
<p>沿着对齐容器的右侧对齐，如果属性的轴不与内联轴平行，则该值的行为和 <code>start</code> 类似。</p>
<ul>
<li><code>baseline first baseline</code> <code>last baseline</code></li>
</ul>
<p>指定参与第一个或最后一个基线对齐：元素的第一个或最后一个基线集的对齐基线与基线共享组中所有框共享的第一个或最后一个基线集中相应的基线对齐。 <code>first baseline</code> 的回退对齐方式为 <code>start</code> ，<code>last baseline</code> 则为 <code>end</code>。</p>
<ul>
<li><code>stretch</code></li>
</ul>
<p>如果子项加起来的尺寸小于对齐容器的尺寸，则任何未尺寸为 <code>auto</code> 的项将增加同等的大小（不是按比例），但也会受到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-height"><code>max-height</code></a>/<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a> （或等同的功能）的限制，因此所有项刚好能填满对齐容器。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>可变字体</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8F%AF%E5%8F%98%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>-</p>
<h2 id="什么是可变字体"><a href="#什么是可变字体" class="headerlink" title="什么是可变字体"></a>什么是可变字体</h2><p><a href="https://new.qq.com/rain/a/20220304A04WFS00">突破限制，CSS font-variation 可变字体的魅力_腾讯新闻 (qq.com)</a></p>
<p>根据 MDN – Variable fonts，可变字体（Variable fonts）是 OpenType 字体规范上的演进，它允许将同一字体的多个变体统合进单独的字体文件中。从而无需再将不同字宽、字重或不同样式的字体分割成不同的字体文件。<strong>我们只需通过CSS与一行 @font-face 引用，即可获取包含在这个单一文件中的各种字体变体。</strong><br>与可变字体对应的，是标准（静态）字体。</p>
<p><strong>标准（静态）字体就是只代表字体的某一特定的宽度/字重/样式的组合的字体文件</strong>，通常我们在页面引入的字体文件都是这种，只代表这个字体的某一特定的宽度/字重/样式的组合。</p>
<p>而如果我们想引入一个字体家族（譬如 Roboto 字体族），它可能包含了 “Roboto Regular”(常规字重)、“Roboto Bold”（粗体），或是 “Roboto Bold Italic”（粗体+斜体） 等一系列字体文件。这意味着我们可能需要 20 或 30 个不同的字体文件才能算是有了一整个字体家族（对于有着不同宽度的大型字体来说，这个数量还要翻上几倍）。</p>
<p>而可变字体 —— font-variation，可以将它理解为 all in one，通过使用可变字体，所有字重、字宽、斜体等情况的排列组合都可以被装进一个文件中。当然，这个文件可能比常规的单个字体文件大一些。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>font-variation 的可变轴 —— <font color="#76923c">注册轴与自定义轴</font></p>
<p>回归到可变字体本身。上面提到了可变轴这个概念，它们分为注册轴与自定义轴，英文是：</p>
<ol>
<li>注册轴 - registered axes</li>
<li>自定义轴 - custom axes</li>
</ol>
<p>可变字体新格式的核心是可变轴的概念，其描述了字体设计中某一特性的允许变化范围。</p>
<blockquote>
<p>例如:<br>‘<strong>字重轴</strong>’描述了字体的粗细；<br>“<strong>宽度轴</strong>” 描述了字体的宽窄；<br>“<strong>斜体轴</strong>” 描述是否使用斜体字形并且可相应地开关等。<br>请注意，轴既可以是范围选择又可以是开关选择。字重可能在 1-999 之间，而斜体可能只是简单的 0 或 1（关闭或打开）。</p>
</blockquote>
<p>如规范中所定义，存在两种变形轴，注册轴和自定义轴：<br>注册轴最为常见，常见到制定规范的作者认为有必要进行标准化。<br>目前注册的五个轴是<strong>字重，宽度，倾斜度，斜体和光学尺寸</strong>。</p>
<p>上文其实已经罗列了 5 个注册轴，并且简单介绍了它们的使用。再罗列一次：</p>
<blockquote>
<p>**字重轴 “wght”**：对应 font-weight，控制字体的粗细<br>**宽度轴 “wdth”**：对应 font-stretch，控制字体的伸缩<br>**斜度轴 “slnt” (slant)**：对应字体的 font-style: oblique + angle，控制字体的倾斜<br>**斜体轴 “ital”**：对应字体的 font-style: italic，控制字体的倾斜（注意，和 font-style: oblique 是不一样的倾斜）<br>**光学尺寸轴 “opsz”**：对应字体的 font-optical-sizing，控制字体的光学尺寸</p>
</blockquote>
<hr>
<p>自定义轴实际上是无限的：字体设计师可以定义和界定他们喜欢的任何轴，并且只需要给它一个四个字母的标签以在字体文件格式本身中识别它。<br>我们来看一个 自定义轴 的例子：</p>
<p>上述 font-family: “Amstelvar VF” 是一个可变字体，而’GRAD’ 属于自定义轴的一个，意为等级轴。<br>等级轴’GRAD’：“等级”一词指的是字体设计的相对重量或密度，但与传统的 “重量” 不同之处在于文本占据的物理空间不会改变，因此改变文本等级并不会改变文本或其周围元素的整体布局。这使得等级成为有用的变化轴，因为它可以变化或动画而不会引起文本本身的回流。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>inherited和initial</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/inherited%E5%92%8Cinitial/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>任何样式都有两种值，一种加 inherited ，一种叫initial</p>
<h2 id="inherited"><a href="#inherited" class="headerlink" title="inherited"></a>inherited</h2><p>有些样式会被子元素继承但是有些样式无法被默认继承，则可以通过inherited自动要求继承，如<code>border</code><br>![[Pasted image 20230402203738.png]]<br>![[Pasted image 20230402203657.png]]</p>
<h2 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h2><p>采用浏览器默认样式，不接受被动继承来的样式</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>自定义属性</title>
    <url>/2023/06/24/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是自定义变量"><a href="#什么是自定义变量" class="headerlink" title="什么是自定义变量"></a>什么是自定义变量</h2><p>自定义属性（有时也被称作CSS变量或者级联变量）是由CSS作者定义的，它包含的值可以在整个文档中重复使用。<br>由自定义属性标记设定值（比如： –main-color: black;），由 var() 函数来获取值（比如： color: var(–main-color);）<br>复杂的网站都会有大量的CSS代码，通常也会有许多重复的值。<br>举例：同样一个颜色值可能在成千上百个地方被使用到，如果这个值发生了变化，需要全局搜索并且一个一个替换。<br>自定义属性在某个地方存储一个值，然后在其他许多地方引用它。另一个好处是语义化的标识。<br>如：–main-text-color 会比 <code>#00ff00</code> 更易理解，尤其是这个颜色值在其他上下文中也被使用到。<br>自定义属性受级联的约束，并从其父级继承其值。</p>
<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>声明一个自定义属性，属性名需要以两个减号（–）开始，属性值则可以是任何有效的CSS值。<br>和其他属性一样，自定义属性也是写在规则集之内的，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">element &#123;</span><br><span class="line">  --<span class="selector-tag">main</span>-bg-<span class="attribute">color</span>: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：规则集所指定的选择器定义了自定义属性的可见作用域。<br>通常的最佳实践是定义在根伪类 :root 下，这样就可以在HTML文档的任何地方访问到它了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --<span class="selector-tag">main</span>-<span class="attribute">color</span>: red;</span><br><span class="line">  --bg-<span class="attribute">color</span>: pink;</span><br><span class="line">  --<span class="selector-tag">main</span>-<span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这条规则不是绝对的，如果有理由去限制你的自定义属性，那么就应该限制。</p>
<blockquote>
<p>注意：自定义属性名是大小写敏感的。 –my-color 和 –My-color 会被认为是两个不同的自定义属性。</p>
</blockquote>
<h2 id="var-函数"><a href="#var-函数" class="headerlink" title="var() 函数"></a>var() 函数</h2><p>读取变量</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。<br>==第二个参数不处理内部的逗号或空格，都视作参数的一部分。==</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">var</span>(--el-height,<span class="number">400px</span>);</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="built_in">var</span>(--font-stack, <span class="string">&quot;Roboto&quot;</span>, <span class="string">&quot;Helvetica&quot;</span>);</span><br><span class="line">  <span class="attribute">padding</span>:<span class="built_in">var</span>(--pad, <span class="number">10px</span> <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的声明</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --length: <span class="number">400px</span>;</span><br><span class="line">  --mian-<span class="attribute">width</span>:<span class="built_in">var</span>(--length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：变量值只能用作属性值，不能用作属性名。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  --side: margin-top;</span><br><span class="line">  <span class="selector-tag">var</span>(--side): <span class="number">20px</span>;  <span class="comment">/* 无效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/2023/06/24/Java/Springboot/AOP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>AOP</strong>为<font color="#4f81bd">Aspect Oriented Programming</font>的缩写，意为：面向切面编程。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ol>
<li><strong>Aspect</strong>（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li>
<li><strong>Joint point</strong>（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li>
<li><strong>Pointcut</strong>（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li>
<li><strong>Advice</strong>（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li>
<li><strong>Target</strong>（目标对象）：织入 Advice 的目标对象.。</li>
<li><strong>Weaving</strong>（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在 Spring AOP 中 Joint point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 Joint point, 通过 point cut, 我们就可以确定哪些 Joint point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问.<br>为什么可以这样类比呢?</p>
<ul>
<li><p>Joint point ： 爪哇的小县城里的百姓: 因为根据定义, Joint point 是所有可能被织入 Advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 Joint point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.</p>
</li>
<li><p>Pointcut ：男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 Advice, 但是我们并不希望在所有方法上都织入 Advice, 而 Pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里 凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.</p>
</li>
<li><p>Advice ：抓过来审问, Advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.</p>
</li>
<li><p>Aspect:：Aspect 是 point cut 与 Advice 的组合, 因此在这里我们就可以类比: “根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问” 这一整个动作可以被认为是一个 Aspect.</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307271144110.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Springboot</category>
      </categories>
  </entry>
  <entry>
    <title>new Date()小知识点</title>
    <url>/2023/07/29/JS/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/new%20Date()%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307271138137.png" alt="image.png"></p>
<p><a href="https://juejin.cn/post/7221884988492382267">new Date() 我忍你很久了！ - 掘金 (juejin.cn)</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>小知识点</category>
      </categories>
  </entry>
  <entry>
    <title>Linux find 命令</title>
    <url>/2023/07/29/Linux/%E5%91%BD%E4%BB%A4/Linux%20find%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h2><p><code>find 搜索路径 [选项] 搜索内容</code></p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><code>find</code> 命令可以根据不同的选项指定按照不同类型的搜索内容进行查找。选项的可选值如下：</p>
<h3 id="1-按照文件名搜索"><a href="#1-按照文件名搜索" class="headerlink" title="1. 按照文件名搜索"></a>1. 按照文件名搜索</h3><ul>
<li>-name：按照文件名搜索；</li>
<li>-iname：按照文件名搜索，不区分文件名大小；</li>
<li>-inum：按照 inode 号搜索。</li>
</ul>
<blockquote>
<p>注意，在使用 find 命令进行搜索时，搜索的文件名必须和搜索的内容一致才能找到；Linux 中的文件名是区分大小写的，因此可以用 -iname 来搜索；每个文件都有 inode 号，如果我们知道 inode 号，也可以按照 inode 号来搜索文件。</p>
</blockquote>
<h3 id="2-按照文件大小搜索"><a href="#2-按照文件大小搜索" class="headerlink" title="2. 按照文件大小搜索"></a>2. 按照文件大小搜索</h3><ul>
<li>-size [+|-]n：按照指定大小搜索文件，查找大小大于 +n、小于 -n 或等于 n 的文件。n 代表 512 字节大小的数据块个数。</li>
</ul>
<h3 id="3-按照修改时间搜索"><a href="#3-按照修改时间搜索" class="headerlink" title="3. 按照修改时间搜索"></a>3. 按照修改时间搜索</h3><ul>
<li>-atime [+|-]n：按照文件访问时间搜索，查找访问时间已经超过 +n 天、低于 -n 天或正好等于 n 天的文件；</li>
<li>-mtime [+|-]n：按照文件更改时间搜索，查找更改时间是在 +n 天之前、不到 -n 天或正好在 n 天之前的文件。</li>
</ul>
<h3 id="4-按照所有者和所属组搜索"><a href="#4-按照所有者和所属组搜索" class="headerlink" title="4. 按照所有者和所属组搜索"></a>4. 按照所有者和所属组搜索</h3><ul>
<li>-uid 用户ID：按照用户 ID 查找所有者是指定 ID 的文件。</li>
<li>-gid 组ID：按照用户组 ID 查找所属组是指定 ID 的文件。</li>
<li>-user 用户名：按照用户名查找所有者是指定用户的文件。</li>
<li>-group 组名：按照组名查找所属组是指定用户组的文件。</li>
<li>-nouser：查找没有所有者的文件。</li>
</ul>
<h3 id="5-按照文件类型搜索"><a href="#5-按照文件类型搜索" class="headerlink" title="5. 按照文件类型搜索"></a>5. 按照文件类型搜索</h3><ul>
<li>-type d：查找目录。</li>
<li>-type f：查找普通文件。</li>
<li>-type l：查找软链接文件。</li>
</ul>
<h3 id="6-逻辑运算符"><a href="#6-逻辑运算符" class="headerlink" title="6. 逻辑运算符"></a>6. 逻辑运算符</h3><ul>
<li>-a：意思为“and逻辑与”。-a 代表逻辑与运算，-a 的两个条件都成立，find 搜索的结果才成立。</li>
<li>-o：意思为“or逻辑或”。-o 选项代表逻辑或运算，-o 的两个条件只要其中一个成立，find 命令就可以找到结果。</li>
<li>-not：意思为“not逻辑非”。-not 是逻辑非，也就是取反。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bogon demo]# find / -name test</span><br><span class="line">/lib/alsa/init/test</span><br><span class="line">/root/demo/test</span><br><span class="line">/root/demo/test/test</span><br><span class="line">/root/linux/test1/test</span><br><span class="line">/usr/lib64/python2.6/test</span><br><span class="line">/usr/bin/test</span><br></pre></td></tr></table></figure>


<p>————————————————<br>版权声明：本文为CSDN博主「没用的阿_吉」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wml00876/article/details/121381208">https://blog.csdn.net/wml00876/article/details/121381208</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>命令</category>
      </categories>
  </entry>
  <entry>
    <title>Linux rm 命令</title>
    <url>/2023/07/29/Linux/%E5%91%BD%E4%BB%A4/Linux%20rm%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.runoob.com/linux/linux-command-manual.html"><img src="https://www.runoob.com/images/up.gif" alt="Linux 命令大全"> Linux 命令大全</a></p>
<p>Linux rm（英文全拼：remove）命令用于删除一个文件或者目录。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [options] name...</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong>：</p>
<ul>
<li>  -i 删除前逐一询问确认。</li>
<li>  -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li>
<li>  -r 将目录及以下之档案亦逐一删除。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  test.txt </span><br></pre></td></tr></table></figure>
<p>rm：是否删除 一般文件 “test.txt”? y  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  homework</span><br></pre></td></tr></table></figure>
<p>rm: 无法删除目录”homework”: 是一个目录  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -r  homework  </span><br></pre></td></tr></table></figure>
<p>rm：是否删除 目录 “homework”? y </p>
<p>删除当前目录下的所有文件及目录，命令行为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -r  * </span><br></pre></td></tr></table></figure>
<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>删除当前目录下的所有文件及目录，并且是直接删除，无需逐一确认命令行为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -rf  要删除的文件名或目录</span><br></pre></td></tr></table></figure>
<p>删除文件名 test.txt:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -rf   test.txt</span><br></pre></td></tr></table></figure>
<p>删除目录 test，不管该目录下是否有子目录或文件，都直接删除:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -rf   test/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>命令</category>
      </categories>
  </entry>
  <entry>
    <title>SOLID</title>
    <url>/2023/07/21/Others/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/SOLID/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式中的SOLID原则，分别是<code>单一原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则</code>。前辈们总结出来的，遵循五大原则可以使程序解决紧耦合，更加健壮。</p>
<p>SOLID原则是由5个设计原则组成，SOLID对应每个原则英文字母的开头：</p>
<ul>
<li>单一职责原则（<strong>S</strong>ingle Responsiblity Principle）</li>
<li>开闭原则(<strong>O</strong>pen Close Principle)</li>
<li>里式替换原则(<strong>L</strong>iskov Substitution Principle)</li>
<li>接口隔离原则(<strong>I</strong>nterface Segregation Principle)</li>
<li>依赖反转原则(<strong>D</strong>ependency Inversion Principle)</li>
</ul>
<table>
<thead>
<tr>
<th>缩写</th>
<th>原则</th>
</tr>
</thead>
<tbody><tr>
<td>SRP</td>
<td>单一责任原则</td>
</tr>
<tr>
<td>OCP</td>
<td>开放封闭原则</td>
</tr>
<tr>
<td>LSP</td>
<td>里氏替换原则</td>
</tr>
<tr>
<td>ISP</td>
<td>接口隔离原则</td>
</tr>
<tr>
<td>DIP</td>
<td>依赖倒置原则</td>
</tr>
</tbody></table>
<h2 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h2><p>指的是一个类或者一个方法只做一件事。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能抑制或者削弱这个类完成其他职责的能力。例如餐厅服务员负责把订单给厨师去做，而不是服务员又要订单又要炒菜。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250946787.png" alt="image.png"></p>
<p>一个协议翻译类，在协议翻译的过程中如果出现了异常，则把异常写入文件日志中。粗略看来这个类没有问题，但是如果我们需要把日志写入数据库，那么我么就需要改变代码。按照单一职责原则，这个类的设计就没有达到要求，因为日志规范的修改，确需要修改协议翻译类。为此我们可以引入专门的日志类来解决这个问题。如果再遇到日志相关的需求变更，我们只需要修改日志类就好了。</p>
<h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p>对扩展开放，对修改关闭。意为一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。例如一开始做了普通计算器程序，突然添加新需求，要再做一个程序员计算器，这时不应该修改普通计算器内部，应该使用面向接口编程，组合实现扩展。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250946406.png" alt="image.png"></p>
<p>程序 AnimalCounter 负责统计动物的腿数，如果我们要增加一种新动物比如 Sheep，我们就需要给 AnimalCounter 的 countFeet 函数增加一个判断，判断数组中是不是有 Sheep 实例，这就是说当有新的需求来的时候，我们得修改 AnimalCounter 代码，而不是扩展它。</p>
<p>下面的代码可以解决这个问题。我们使用了一个接口，鸡类和狗类都继承了这个接口，在 AnimalCounter 中我们只要调用这个接口就可以知道动物有多少只脚了。无论是再有绵羊类或者是昆虫类，它们只要继承了这个接口，AnimalCounter 都可以计算出动物的总脚数。也就是我们通过扩展 IAnimal 接口就可以满足需求，而不用修改 AnimalCounter 类。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。例如机动车必须有轮胎和发动机，子类宝马和奔驰不应该改写没轮胎或者没发动机。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250946407.png" alt="image.png"></p>
<p>我们定义了一个类叫 Bird，这个接口有四个方法，然后我们有一个天鹅类，一个鸡类。可以看到，Bird 的四个方法用 Swan 类来代替是没有问题的，但是用 Chicken 类来代替当调用到 fly 方法的时候就会抛出异常。这个就不符合 Liskov 原则，因为作为 Bird 类的子类的 Chicken 类没有做到替换父类 Bird 类而不影响程序运行。解决方法是拆分Bird类的功能，因为家禽是不会飞的。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>类不应该依赖不需要的接口，知道越少越好。例如电话接口只约束接电话和挂电话，不需要让依赖者知道还有通讯录。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250947802.png" alt="image.png"></p>
<p>类不应该被强迫去依赖它用不到的方法。大的原则是很多小而精的接口，要好于一个大一统的接口。比如下面的 ICar 接口，我们不应该为了大一统把加油 (fuel) 和 (Charge) 充电都放在里面，因为烧汽油的汽车才需要加油，使用电池驱动的电动车才需要充电。如果子类继承了父类中用不到的方法，子类也会打破上面的 Liskov 原则，也不利于将来的重构和优化。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖反转说了两点：</p>
<p>高层模块不应该依赖低层模块，双方应该依赖抽象。<br>抽象不应该依赖细节，而细节应该依赖抽象。<br>听起来很绕口，不过这个确实是面向对象编程里解决紧耦合问题最重要的原则之一。通常的解决方案就是大名鼎鼎的依赖注入！</p>
<p>指的是高级模块不应该依赖低级模块，而是依赖抽象。抽象不能依赖细节，细节要依赖抽象。比如类A内有类B对象，称为类A依赖类B，但是不应该这样做，而是选择类A去依赖抽象。例如垃圾收集器不管垃圾是什么类型，要是垃圾就行。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250947239.png" alt="image.png"></p>
<p>比如 物品交易，我有牛，你有羊， 以物换物，相互依赖， 如果改为统一用货币来交易，则彼此不依赖，而是都依赖于各自的物品抽象–货币。</p>
<p>下面的代码的任务是打印一个指定路径的文件，打印完成后发出 email。这个代码就违反了依赖反转原则，所有的 new 语句处都表示高层模块需要知道低层模块的细节，比如 <code>Program</code> 类就需要如何生成 <code>PrinterService</code> 和 <code>EMailService</code>，<code>PrinterService</code> 和 <code>EMailService</code> 的功能也没有被抽象出来。这样程序的功能在需要重构、扩展或者替换时高层模块和低层模块都需要知道对方的细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Program &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> filePath = args[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">var</span> printerService = <span class="keyword">new</span> PrinterService();</span><br><span class="line">		printerService.print(filePath);</span><br><span class="line">		<span class="keyword">var</span> emailService = <span class="keyword">new</span> EMailService();</span><br><span class="line">		emailService.send(<span class="string">&quot;surfirst@example.com&quot;</span>, <span class="string">&quot;File printed&quot;</span>, filePath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Logger logger;</span><br><span class="line">	PrinterService()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.logger = <span class="keyword">new</span> Logger();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// process print task</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">this</span>.logger.log(filePath + <span class="string">&quot; printed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">log</span><span class="params">(String content)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(String email, String subject, String content)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Email %s has been sent to %s. &quot;</span>, subject, email);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决上面的方法可以是依赖注入，也可以通过类工厂的方法来解决。由于篇幅有限，我们在这里使用类工厂来展示解决方案。首先我们抽象出我们用到的组件的接口，然后我们通过类工厂来实现这些接口，最后通过类工厂来解决依赖问题。</p>
<p>下面是我们抽象出来的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inteface IPrinterService &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String filePath)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILogger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEmailService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String email, String subject, String content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是类工厂的代码，虽然看上去很简单，但是通过类工厂，我们就解决了抽象到实现细节的问题，这使我们的业务逻辑独立于我们的依赖项。依赖项可以来自外部文件，对 Java 来说就是不同的 JAR 文件，对 .Net 来说可以是不同的 DLL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPrinterService <span class="title">CreatePrinterService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PrinterService();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILogger <span class="title">CreateLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Logger();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEmailService <span class="title">CreateEmailService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EmailService();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用了类工厂以后的业务逻辑代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Program &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> filePath = args[<span class="number">0</span>];</span><br><span class="line">		IPrinterService printerService = Factory.CreatePrinterService();</span><br><span class="line">		printerService.print(filePath);</span><br><span class="line">		IEmailService emailService = Factory.CreateEmailService();</span><br><span class="line">		emailService.send(<span class="string">&quot;surfirst@example.com&quot;</span>, <span class="string">&quot;File printed&quot;</span>, filePath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterService</span> <span class="keyword">implements</span> <span class="title">IPrinterService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Logger logger;</span><br><span class="line">	PrinterService()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.logger = Factory.CreateLogger();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// process print task</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">this</span>.logger.log(filePath + <span class="string">&quot; printed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> <span class="keyword">implements</span> <span class="title">ILogger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">log</span><span class="params">(String content)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(String email, String subject, String content)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Email %s has been sent to %s. &quot;</span>, subject, email);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>没人写一款程序能完全遵守SOLID原则，甚至有些设计模式是违反SOLID原则。如何权衡就要看利是否大于弊。不足之处望指教。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「Peter_Gao_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_42672770/article/details/117650871">https://blog.csdn.net/qq_42672770/article/details/117650871</a></p>
]]></content>
      <categories>
        <category>Others</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>1. Nest.js 介绍</title>
    <url>/2023/07/29/Node/NestJS/1.%20Nest.js%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Nest (NestJS)是一个用于构建高效、可扩展的Node.js服务器端应用程序的框架。它使用渐进式JavaScript，构建并完全支持TypeScript(但仍然允许开发人员使用纯JavaScript编写代码)，并结合了OOP(面向对象编程)，FP(函数式编程)和FRP(函数式响应式编程)的元素。</p>
<p>在底层，Nest使用了健壮的HTTP服务器框架，比如<code>Express</code>(默认的)，也可以选择配置使用<code>fasttify</code> !</p>
<p>Nest在这些常见的Node.js框架(Express/ fasttify)之上提供了一个抽象层次，但也直接向开发人员公开了它们的api。这使得开发人员可以自由地使用底层平台可用的无数第三方模块。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>近年来，由于Node.js, JavaScript已经成为web前端和后端应用程序的“通用语言”。这催生了像<code>Angular、React和Vue</code>这样令人敬畏的项目，它们提高了开发人员的生产力，并使创建快速、可测试和可扩展的前端应用成为可能。然而，尽管有大量优秀的库、助手和工具用于Node(和服务器端JavaScript)，但它们都没有有效地解决架构的主要问题。</p>
<p>Nest提供了一种开箱即用的应用程序架构，允许开发人员和团队创建高度可测试、可扩展、松耦合和易于维护的应用程序。架构很大程度上受到了Angular的启发。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，您可以使用<a href="https://docs.nestjs.com/cli/overview">Nest CLI</a>构建项目，也可以克隆一个初始项目(两者都会产生相同的结果)。</p>
<p>要使用Nest CLI构建项目，请运行以下命令。这将创建一个新的项目目录，并用初始核心Nest文件和支持模块填充该目录，为您的项目创建一个常规的基本结构。建议首次使用Nest CLI创建新项目。我们将在第一步中继续使用这种方法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i -g @nestjs/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nest new project-name</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>要创建一个具有更严格特性集的新TypeScript项目，将——strict标志传递给下一个新命令。</p>
</blockquote>
<h2 id="替代选择"><a href="#替代选择" class="headerlink" title="替代选择"></a>替代选择</h2><p>或者，用Git安装TypeScript starter项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/nestjs/typescript-starter.git project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run start</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>如果想克隆没有git历史记录的存储库，可以使用degit。</p>
</blockquote>
<p>打开浏览器并导航到<a href="http://localhost:3000/">http://localhost:3000/</a>。</p>
<p>要安装启动器项目的JavaScript版本，请使用<code>javascript-starter.git</code>在上面的命令序列中。</p>
<p>你也可以用npm(或yarn)安装核心和支持文件，从头开始手动创建一个新项目。当然，在这种情况下，您将负责自己创建项目样板文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i --save @nestjs/core @nestjs/common rxjs reflect-metadata</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>2. Nest.js 第一步</title>
    <url>/2023/07/29/Node/NestJS/2.%20Nest.js%20%E7%AC%AC%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>在这组文章中，您将学习Nest的核心基础知识。为了熟悉Nest应用程序的基本构建块，我们将构建一个基本的CRUD应用程序，其功能涵盖了入门级的许多基础知识。</p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>Nest利用了最新的语言特性，所以要在普通JavaScript中使用它，我们需要一个Babel编译器。</p>
<p>在我们提供的示例中，我们将主要使用TypeScript，但你也可以将代码片段切换为普通的JavaScript语法(只需单击每个代码片段右上角的语言按钮即可)。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>请确保在您的操作系统上安装了Node.js(<strong>版本&gt;= 16</strong>)。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Nest CLI设置新项目非常简单。安装npm后，你可以在你的操作系统终端上用下面的命令创建一个新的Nest项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i -g @nestjs/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nest new project-name</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>要用TypeScript更严格的特性集创建一个新项目，把<code>--strict</code>标志传递给<code>nest new</code>命令。</p>
</blockquote>
<p>将创建<code>project-name</code>目录，安装节点模块和其他一些样板文件，并创建一个<code>src/</code>目录并填充几个核心文件。</p>
<blockquote>
<p>src<br>|——app.controller.spec.ts<br>|——app.controller.ts<br>|——app.module.ts<br>|——app.service.ts<br>|——main.ts</p>
</blockquote>
<p>以下是这些核心文件的简要概述:</p>
<p><code>app.controller.ts</code></p>
<p>具有单个路由的基本控制器。</p>
<hr>
<p><code>app.controller.spec.ts</code></p>
<p>控制器的单元测试。</p>
<hr>
<p><code>app.module.ts</code></p>
<p>应用程序的根模块。</p>
<hr>
<p><code>app.service.ts</code></p>
<p>使用单一方法的基本服务。</p>
<hr>
<p><code>main.ts</code></p>
<p>应用程序的入口文件，它使用核心函数<code>NestFactory</code>来创建一个Nest应用程序实例。</p>
<hr>
<p><code>main.ts</code>包含一个<code>async</code>函数，它将引导我们的应用程序:</p>
<figure class="highlight js"><figcaption><span>main.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure>

<p>要创建一个Nest应用程序实例，我们使用核心的<code>NestFactory</code>类。<code>NestFactory</code>公开了一些允许创建应用程序实例的静态方法。<code>create()</code>方法返回一个应用程序对象，该对象满足<code>INestApplication</code>接口。这个对象提供了一组方法，这些方法将在后面的章节中描述。基本上。在上面的例子中，我们只需启动HTTP侦听器，让应用程序等待入站HTTP请求。</p>
<p>请注意，使用 <code>Nest CLI</code> 搭建的项目会创建一个初始项目结构，鼓励开发人员遵循将每个模块保留在其自己的专用目录中的约定。</p>
<blockquote>
<p>[!hint]<br>默认情况下，如果在创建应用程序时发生任何错误，应用程序将以代码<code>1</code>退出。如果你想让它抛出一个错误，那就不能禁用选项<code>abortOnError</code>(例如，<code>NestFactory.create(AppModule， &#123;abortOnError: false&#125;)</code>)。</p>
</blockquote>
<h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>Nest的目标是成为一个平台无关的框架。平台独立性使得创建可重用的逻辑部分成为可能，开发人员可以跨几种不同类型的应用程序利用这些逻辑部分。从技术上讲，一旦创建了适配器，Nest就能够与任何Node HTTP框架一起工作。有两种开箱即用的HTTP平台:express和fastify。你可以选择一个最适合你需要的。</p>
<p><code>platform-express</code></p>
<p><a href="https://expressjs.com/">Express</a>是一个著名的node极简web框架。它是一个经过实战测试的、可用于生产的库，其中包含许多由社区实现的资源。默认情况下使用<code>@nestjs/platform-express</code>包。许多用户都可以很好地使用Express，并且不需要采取任何操作来启用它。</p>
<hr>
<p><code>platform-fastify</code></p>
<p><a href="https://www.fastify.io/">Fastify</a>是一个高性能和低开销的框架，高度专注于提供最大的效率和速度。点击<a href="https://docs.nestjs.com/techniques/performance">这里</a>阅读如何使用它。</p>
<p>无论使用哪种平台，它都公开自己的应用程序接口。它们分别被看作是<code>NestExpressApplication</code>和<code>NestFastifyApplication</code>。</p>
<p>当你将一个类型传递给<code>NestFactory.create()</code>方法时，如下面的例子所示，应用对象将拥有专门用于该特定平台的方法。但是请注意，除非您确实想要访问底层平台API，否则您不需要指定类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>安装过程完成后，您可以在操作系统命令提示符下运行以下命令，启动侦听入站HTTP请求的应用程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm run start</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]+<br>为了加快开发过程(构建速度提高20倍)，您可以通过向启动脚本传递<code>-b swc</code>标志来使用<a href="https://docs.nestjs.com/recipes/swc">SWC构建器</a>，如下所示:<code>npm run start -- -b swc</code>。</p>
</blockquote>
<p>该命令启动应用时，HTTP服务器监听<code>src/main.ts</code>中定义的端口。应用程序运行后，打开浏览器并导航到<a href="http://localhost:3000/">http://localhost:3000/</a>。您应该看到<code>Hello World!</code>消息。</p>
<p>要观察文件中的变化，可以运行以下命令来启动应用程序:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run start:dev</span><br></pre></td></tr></table></figure>

<p>该命令将监视您的文件，自动重新编译并重新加载服务器(<strong>热重载</strong>)。</p>
<h2 id="Linting-和-formatting"><a href="#Linting-和-formatting" class="headerlink" title="Linting 和 formatting"></a>Linting 和 formatting</h2><p><a href="https://docs.nestjs.com/cli/overview">CLI</a>尽最大努力构建可靠的大规模开发工作流。因此，生成的Nest项目附带了预安装的代码检查器和格式化器(分别是<a href="https://eslint.org/">eslint</a><a href="https://prettier.io/">和prettier</a>)。</p>
<blockquote>
<p>[!hint]+<br>不确定formatters和linters的作用?在<a href="https://prettier.io/docs/en/comparison.html">这里</a>了解它们的区别。</p>
</blockquote>
<p>为了确保最大的稳定性和可扩展性，我们使用了基本的<code>eslint</code>和<code>prettier</code>的cli包。这种设置允许通过设计将IDE与官方扩展集成在一起。</p>
<p>对于没有IDE的环境(持续集成、Git钩子等)，Nest项目提供了现成的npm脚本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Lint and autofix with eslint</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run lint</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Format with prettier</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run format</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>3. Nest.js Controller</title>
    <url>/2023/07/29/Node/NestJS/3.%20Nest.js%20Controller/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>控制器负责处理传入的请求并向客户端返回响应。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250926656.png" alt="image.png"></p>
<p>控制器的目的是接收应用程序的特定请求。路由机制控制哪个控制器接收哪些请求。通常情况下，每个控制器都有多条路由，不同的路由可以执行不同的动作。</p>
<p>为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据关联起来，并使Nest能够创建路由映射(将请求绑定到相应的控制器)。</p>
<p>为了快速创建带有内置验证的CRUD控制器，您可以使用CLI的CRUD生成器:<code>nest g resource [name]</code>。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在下面的示例中，我们将使用<code>@Controller()</code>装饰器，它是定义基本控制器所必需的。我们将指定一个可选的路由路径前缀<code>cats</code>。在<code>@Controller()</code>装饰器中使用路径前缀可以让我们轻松地对一组相关的路由进行分组，并尽量减少重复的代码。例如，我们可以选择将一组管理与cat实体交互的路由分组在路由<code>/cats</code>下。在这种情况下，我们可以在<code>@Controller()</code>装饰器中指定路径前缀<code>cats</code>，这样我们就不必为文件中的每个路由重复路径的那一部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  findAll(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action returns all cats&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>使用命令行创建控制器，只需执行<code>$ nest g controller [name]</code>命令。</p>
</blockquote>
<p><code>findAll()</code>方法之前的<code>@Get()</code> HTTP请求方法装饰器告诉Nest为HTTP请求的特定端点创建处理程序。端点对应于HTTP请求方法(在本例中为GET)和路由路径。路线是什么?处理程序的路由路径是通过连接为控制器声明的(可选的)前缀和方法装饰器中指定的任何路径来确定的。因为我们已经为每个路由声明了一个前缀(cats)，并且没有在装饰器中添加任何路径信息，所以Nest会将GET <code>/cats</code>请求映射到这个处理程序。如前所述，该路径既包括可选的控制器路径前缀，也包括在请求方法装饰器中声明的任何路径字符串。例如，一个由cats组成的路径前缀加上装饰器<code>@Get(&#39;breed&#39;)</code>，就会为GET <code>/cats/breed</code>这样的请求生成一个路由映射。</p>
<p>在上面的示例中，当向该端点发出GET请求时，Nest将请求路由到用户定义的<code>findAll()</code>方法。注意，我们在这里选择的方法名是完全任意的。显然，我们必须声明一个方法来绑定路由，但是Nest对所选择的方法名不在意。</p>
<p>该方法将返回一个200状态码和相关的响应，在本例中只是一个字符串。为什么会这样呢?为了解释这一点，我们将首先介绍Nest使用两种不同选项来操纵响应的概念:</p>
<hr>
<p><code>Standard (recommended)</code></p>
<p>使用这个内置方法，当请求处理程序返回JavaScript对象或数组时，它将自动序列化为JSON。然而，当它返回一个JavaScript基本类型(例如，字符串，数字，布尔值)时，Nest将只发送值而不尝试序列化它。这使得响应处理变得简单:只返回值，Nest负责其余的工作。</p>
<p>此外，响应的状态码默认总是<code>200</code>，除了使用<code>201</code>的POST请求。我们可以通过在处理程序级别添加<code>@HttpCode(…)</code>装饰器来轻松改变这种行为(参见<a href="https://docs.nestjs.com/controllers#status-code">状态代码</a>)。</p>
<hr>
<p><code>Library-specific</code></p>
<p>我们可以使用特定于库的(例如Express)响应对象，它可以使用方法处理程序签名中的@Res()装饰器注入(例如findAll(@Res() response))。通过这种方法，您可以使用该对象公开的本机响应处理方法。例如，对于Express，您可以使用<code>response.status(200).send()</code>这样的代码来构造响应。</p>
<hr>
<blockquote>
<p>[!warning]<br>Nest检测处理程序何时使用@Res()或@Next()，指示您选择了<code>library-specific</code>选项。如果同时使用这两种方法，标准方法将自动对这条路由禁用，并且不再像预期的那样工作。要同时使用这两种方法(例如，通过注入响应对象来只设置cookie /headers，而将其余部分留给框架)，你必须在<code>@Res(&#123;passthrough: true&#125;)</code>装饰器中将<code>passthrough</code>选项设置为true。</p>
</blockquote>
<h2 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h2><p>处理程序通常需要访问客户端请求的详细信息。Nest提供对底层平台(默认情况下是Express)的请求对象的访问。我们可以通过在处理器的签名中添加<code>@Req()</code>装饰器来指示Nest注入请求对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Req &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  findAll(@Req() request: Request): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action returns all cats&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>为了利用express类型(如上面的<code>request: Request</code>参数示例)，安装<code>@types/express</code>包。</p>
</blockquote>
<p>请求对象表示HTTP请求，并具有请求查询字符串、参数、HTTP头和正文的属性(在这里阅读更多内容)。在大多数情况下，不需要手动获取这些属性。我们可以使用专门的装饰器，比如<code>@Body()</code>或<code>@Query()</code>，它们都是现成的。下面是所提供的装饰器和它们所代表的平台特定对象的列表。</p>
<table>
<thead>
<tr>
<th>decorator</th>
<th>object</th>
</tr>
</thead>
<tbody><tr>
<td>@Request(),@Req()</td>
<td>req</td>
</tr>
<tr>
<td>@Response(),@Res()*</td>
<td>res</td>
</tr>
<tr>
<td>@Next</td>
<td>next</td>
</tr>
<tr>
<td>@Session</td>
<td>req.session</td>
</tr>
<tr>
<td>@Param(key?:string)</td>
<td>req.params / req.params[key]</td>
</tr>
<tr>
<td>@Body(key?:string)</td>
<td>req.body / req.body[key]</td>
</tr>
<tr>
<td>@Query(key?:string)</td>
<td>req.query / req.query[key]</td>
</tr>
<tr>
<td>@Header(name?:string)</td>
<td>req.ip</td>
</tr>
<tr>
<td>@HostParam()</td>
<td>req.hosts</td>
</tr>
</tbody></table>
<p>为了兼容底层HTTP平台(例如Express和fasttify)的类型，Nest提供了<code>@Res()</code>和<code>@Response()</code>装饰器。<code>@Res()</code>只是<code>@Response()</code>的别名。两者都直接公开底层的本机平台响应对象接口。在使用它们时，您还应该导入底层库的类型(例如，<code>@types/express</code>)以充分利用它们。请注意，当您在方法处理程序中注入<code>@Res()</code>或<code>@Response()</code>时，您将为该处理程序将Nest置于<code>Library-specific</code>模式，并且您将负责管理响应。当这样做时，你必须通过调用响应对象(例如，<code>res.json(…)</code>或<code>res.send(…)</code>)发出某种响应，否则HTTP服务器将挂起。</p>
<blockquote>
<p>[!hint]<br>要了解如何创建自己的自定义装饰器，请访问<a href="https://docs.nestjs.com/custom-decorators">本章</a>。</p>
</blockquote>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>前面，我们定义了一个端点来获取cat资源(GET路由)。我们通常还希望提供一个端点来创建新记录。为此，让我们创建POST处理程序:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Post()</span><br><span class="line">  create(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  findAll(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action returns all cats&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是这么简单。Nest为所有标准HTTP方法提供了装饰器:<code>@Get()、@Post()、@Put()、@Delete()、@Patch()、@Options()和@Head()</code>。此外，<code>@All()</code>定义了一个端点来处理它们全部。</p>
<h2 id="路由通配符"><a href="#路由通配符" class="headerlink" title="路由通配符"></a>路由通配符</h2><p>也支持基于模式的路由。例如，星号用作通配符，可以匹配任何字符组合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">&#x27;ab*cd&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">findAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This route uses a wildcard&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&#39;ab*cd&#39;</code>路由路径将匹配<code>abcd, ab_cd, abecd</code>，等等。字符<code>?</code>、<code>+</code>、<code>*</code>和<code>()</code>可以在路由路径中使用，它们是对应正则表达式的子集。连字符(-)和点(.)由基于字符串的路径逐字解释。</p>
<blockquote>
<p>[!warning]<br>路由中间的通配符只有<code>express</code>支持</p>
</blockquote>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>如上所述，响应状态码在默认情况下总是200，除了POST请求是201。通过在处理程序级别添加<code>@HttpCode(…)</code>装饰器，我们可以很容易地改变这种行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Post()</span><br><span class="line">@HttpCode(<span class="number">204</span>)</span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>从<code>@nestjs/common</code>包中导入<code>HttpCode</code>。</p>
</blockquote>
<p>通常，您的状态码不是静态的，而是取决于各种因素。在这种情况下，您可以使用<code>library-specific</code>的响应(使用@Res()注入)对象(或者，在出现错误的情况下，抛出异常)。</p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>去指定一个自定义的相应头，你可以使用<code>@Header</code>或者特定库的响应对象（直接调用<code>res.header()</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Post()</span><br><span class="line">@Header(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>从<code>@nestjs/common</code>导入<code>Header</code></p>
</blockquote>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>要将响应重定向到特定的URL，您可以使用<code>@Redirect()</code>装饰器或特定于库的响应对象(并直接调用<code>res.redirect()</code>)。<br><code>@Redirect()</code>有两个参数，<code>url</code>和<code>statusCode</code>，它们都是可选的。如果省略，statusCode的默认值是<code>302</code> (Found)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line">@Redirect(<span class="string">&#x27;https://nestjs.com&#x27;</span>, <span class="number">301</span>)</span><br></pre></td></tr></table></figure>

<p>有时，您可能希望动态地确定HTTP状态码或重定向URL。要做到这一点，可以从路由处理程序方法中返回一个具有如下形状的对象:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;url&quot;</span>: string,</span><br><span class="line">  <span class="string">&quot;statusCode&quot;</span>: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的值将覆盖传递给@Redirect()装饰器的任何参数。例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">&#x27;docs&#x27;</span>)</span><br><span class="line">@Redirect(<span class="string">&#x27;https://docs.nestjs.com&#x27;</span>, <span class="number">302</span>)</span><br><span class="line"><span class="function"><span class="title">getDocs</span>(<span class="params">@Query(<span class="string">&#x27;version&#x27;</span>) version</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (version &amp;&amp; version === <span class="string">&#x27;5&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">url</span>: <span class="string">&#x27;https://docs.nestjs.com/v5/&#x27;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h2><p>当你需要接受动态数据作为请求的一部分时，带有静态路径的路由将无法工作(例如，GET <code>/cats/1</code>获取id为1的cat)。为了定义带有参数的路由，我们可以在路由的路径中添加路由参数令牌，以捕获请求URL中该位置的动态值。下面<code>@Get()</code>装饰器示例中的路由参数令牌演示了这种用法。以这种方式声明的路由参数可以使用<code>@Param()</code>装饰器访问，该装饰器应该添加到方法签名中。</p>
<blockquote>
<p>[!hint]<br>带参数的路由应该在任何静态路径之后声明。这可以防止参数化路径拦截发往静态路径的流量。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">findOne(@Param() params: any): string &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(params.id);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;params.id&#125;</span> cat`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Param()</code>用于修饰方法参数(在上面的例子中是<code>params</code>)，并使路由参数在方法体中作为修饰过的方法参数的属性可用。如上面的代码所示，我们可以通过引用<code>params.id</code>来访问id形参。你也可以将一个特定的参数标记传递给装饰器，然后在方法体中直接通过名称引用路由参数</p>
<blockquote>
<p>[!hint]<br>从@nestjs/common包中导入Param。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">findOne(@Param(<span class="string">&#x27;id&#x27;</span>) id: string): string &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子域路由"><a href="#子域路由" class="headerlink" title="子域路由"></a>子域路由</h2><p><code>@Controller</code>装饰器可以使用一个<code>host</code>选项来要求传入请求的HTTP主机匹配某个特定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Controller(&#123; <span class="attr">host</span>: <span class="string">&#x27;admin.example.com&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  index(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Admin page&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>由于<strong>Fastify</strong>缺乏对嵌套路由器的支持，所以在使用子域路由时，应该使用(默认的)Express适配器。</p>
</blockquote>
<p>与路由路径类似，<code>hosts</code>选项可以使用令牌来捕获主机名中该位置的动态值。下面的<code>@Controller()</code>装饰器示例中的主机参数令牌演示了这种用法。以这种方式声明的主机参数可以使用<code>@HostParam()</code>装饰器访问，该装饰器应该添加到方法签名中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Controller(&#123; <span class="attr">host</span>: <span class="string">&#x27;:account.example.com&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">  @Get()</span><br><span class="line">  <span class="function"><span class="title">getInfo</span>(<span class="params">@HostParam(<span class="string">&#x27;account&#x27;</span>) account: string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>对于来自不同编程语言背景的人来说，可能会惊讶地发现，在Nest中，几乎所有内容都是在传入请求之间共享的。我们有一个连接到数据库的连接池，具有全局状态的单例服务等等。请记住，Node.js不遵循请求/响应多线程无状态模型，在这种模型中，每个请求都由一个单独的线程处理。因此，使用单例实例对我们的应用程序是完全安全的。</p>
<p>然而，在某些特殊情况下，基于请求的控制器生命周期可能是期望的行为，例如GraphQL应用程序中的每个请求缓存、请求跟踪或多租户。在<a href="https://docs.nestjs.com/fundamentals/injection-scopes">这里</a>了解如何控制作用域。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>我们喜欢现代JavaScript，我们知道数据提取大多是异步的。这就是为什么Nest支持并能很好地使用异步函数的原因。</p>
<blockquote>
<p>[!hint]<br>Learn more about <code>async / await</code> feature <a href="https://kamilmysliwiec.com/typescript-2-1-introduction-async-await">here</a></p>
</blockquote>
<p>每个async函数都必须返回一个<code>Promise</code>。这意味着您可以返回一个延迟的值，Nest将能够自己解析该值。让我们来看一个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line"><span class="keyword">async</span> findAll(): <span class="built_in">Promise</span>&lt;any[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是完全有效的。此外，通过能够返回<strong>RxJS</strong><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html">可观察流</a>，Nest路由处理程序甚至更加强大。Nest将自动订阅下面的源并获取最后发出的值(一旦流完成)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line">findAll(): Observable&lt;any[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">of</span>([]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两种方法都有效，您可以使用任何适合您需求的方法。</p>
<h2 id="请求载荷"><a href="#请求载荷" class="headerlink" title="请求载荷"></a>请求载荷</h2><p>我们前面的POST路由处理程序示例不接受任何客户端参数。让我们通过在这里添加<code>@Body()</code>装饰器来修复这个问题。</p>
<p>但首先(如果你使用TypeScript)，我们需要确定DTO(数据传输对象)模式。DTO是定义如何通过网络发送数据的对象。我们可以通过使用TypeScript接口或简单的类来确定DTO模式。有趣的是，我们建议在这里使用类。为什么?类是JavaScript ES6标准的一部分，因此它们在编译后的JavaScript中被保存为真实的实体。另一方面，由于TypeScript接口在编译过程中被删除，所以Nest不能在运行时引用它们。这一点很重要，因为<code>Pipes</code>等特性为在运行时访问变量的元类型时启用了其他可能性。</p>
<p>让我们创建CreateCatDto类:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateCatDto</span> </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">  breed: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只有三个基本性质。之后，我们可以在CatsController中使用新创建的DTO:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Post()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">@Body() createCatDto: CreateCatDto</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>我们的<code>ValidationPipe</code>可以过滤掉不应该被方法处理程序接收的属性。在这种情况下，我们可以将可接受的属性列入白名单，并且任何未包含在白名单中的属性都会自动从结果对象中删除。在<code>CreateCatDto</code>示例中，我们的白名单是name、age和breed属性。点击<a href="https://docs.nestjs.com/techniques/validation#stripping-properties">这里</a>了解更多。</p>
</blockquote>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>这里有一个关于处理错误(即处理异常)的单独<a href="https://docs.nestjs.com/exception-filters">章节</a>。</p>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Query, Post, Body, Put, Param, Delete &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateCatDto, UpdateCatDto, ListAllEntities &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Post()</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params">@Body() createCatDto: CreateCatDto</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action adds a new cat&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="function"><span class="title">findAll</span>(<span class="params">@Query() query: ListAllEntities</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action returns all cats (limit: <span class="subst">$&#123;query.limit&#125;</span> items)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">findOne</span>(<span class="params">@Param(<span class="string">&#x27;id&#x27;</span>) id: string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Put(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">@Param(<span class="string">&#x27;id&#x27;</span>) id: string, @Body() updateCatDto: UpdateCatDto</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action updates a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Delete(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">@Param(<span class="string">&#x27;id&#x27;</span>) id: string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action removes a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>Nest CLI提供了一个生成器(示意图)，它自动生成所有样板代码，以帮助我们避免做所有这些事情，并使开发人员的体验更简单。在<a href="https://docs.nestjs.com/recipes/crud-generator">这里</a>阅读有关此功能的更多信息。</p>
</blockquote>
<h2 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h2><p>在完全定义了上述控制器之后，Nest仍然不知道CatsController存在，因此不会创建该类的实例。</p>
<p>控制器总是属于一个模块，这就是为什么我们在<code>@Module()</code>装饰器中包含了<code>controllers</code>数组。因为除了根模块<code>AppModule</code>之外，我们还没有定义任何其他模块，所以我们将用它来引入<code>CatsController</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.controller&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>@Module()</code>装饰器将元数据附加到模块类中，Nest现在可以很容易地反映出哪些控制器必须被挂载。</p>
<h2 id="特定库方法"><a href="#特定库方法" class="headerlink" title="特定库方法"></a>特定库方法</h2><p>到目前为止，我们已经讨论了操作响应的Nest标准方法。操纵响应的第二种方法是使用特定于库的响应对象。为了注入特定的响应对象，我们需要使用<code>@Res()</code>装饰器。为了显示不同之处，让我们重写CatsController如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post, Res, HttpStatus &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Response &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  @Post()</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params">@Res() res: Response</span>)</span> &#123;</span><br><span class="line">    res.status(HttpStatus.CREATED).send();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="function"><span class="title">findAll</span>(<span class="params">@Res() res: Response</span>)</span> &#123;</span><br><span class="line">     res.status(HttpStatus.OK).json([]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这种方法是有效的，并且实际上通过提供对响应对象的完全控制(头文件操作、库特定的特性等)在某些方面提供了更大的灵活性，但是应该谨慎使用。一般来说，这种方法不太明确，而且确实有一些缺点。主要的缺点是，您的代码变得依赖于平台(因为底层库可能在响应对象上具有不同的api)，并且更难测试(您必须模拟响应对象，等等)。</p>
<p>此外，在上面的例子中，你失去了与依赖于Nest标准响应处理的Nest特性的兼容性，比如拦截器和<code>@HttpCode()</code> / <code>@Header()</code>装饰器。要解决这个问题，你可以将<code>passthrough</code>选项设置为<code>true</code>，如下所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Get()</span><br><span class="line"><span class="function"><span class="title">findAll</span>(<span class="params">@Res(&#123; passthrough: <span class="literal">true</span> &#125;) res: Response</span>)</span> &#123;</span><br><span class="line">  res.status(HttpStatus.OK);</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，您可以与原生响应对象进行交互(例如，根据特定条件设置cookie或header)，但将其余部分留给框架。</p>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>4. Nest.js Providers</title>
    <url>/2023/07/29/Node/NestJS/4.%20Nest.js%20Providers/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Providers是Nest中的一个基本概念。许多基本的Nest类可以被视为提供者——服务、存储库、工厂、助手等等。提供者的主要思想是它可以作为依赖注入;这意味着对象可以创建彼此之间的各种关系，并且“连接”对象实例的功能可以在很大程度上委托给Nest运行时系统。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250927115.png" alt="image.png"></p>
<p>在前一章中，我们构建了一个简单的<code>CatsController</code>。控制器应该处理HTTP请求，并将更复杂的任务委托给提供商。提供程序是在模块中声明为提供程序的普通JavaScript类。</p>
<blockquote>
<p>[!hint]<br>由于Nest允许以更面向对象的方式设计和组织依赖项，因此我们强烈建议遵循<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a>原则([[SOLID]])。</p>
</blockquote>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>让我们从创建一个简单的<code>CatsService</code>开始。该服务将负责数据存储和检索，并被设计为由<code>CatsController</code>使用，因此将其定义为提供者是一个很好的候选者。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Cat &#125; <span class="keyword">from</span> <span class="string">&#x27;./interfaces/cat.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsService</span> </span>&#123;</span><br><span class="line">  private readonly cats: Cat[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params">cat: Cat</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cats.push(cat);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findAll(): Cat[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.cats;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>要使用CLI创建服务，只需执行<code>$ nest g service cats</code>命令。</p>
</blockquote>
<p>我们的<code>CatsService</code>是一个具有一个属性和两个方法的基本类。唯一的新特性是它使用了<code>@Injectable()</code>装饰器。<code>@Injectable()</code>装饰器附加了元数据，它声明<code>CatsService</code>是一个可以由Nest IoC容器管理的类。顺便说一下，这个例子也使用了一个<code>Cat</code>接口，它看起来可能是这样的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface Cat &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">  breed: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们有了一个检索猫的服务类，让我们在<code>CatsController</code>中使用它:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post, Body &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateCatDto &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto/create-cat.dto&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Cat &#125; <span class="keyword">from</span> <span class="string">&#x27;./interfaces/cat.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Controller(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private catsService: CatsService</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Post()</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">@Body() createCatDto: CreateCatDto</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.catsService.create(createCatDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Get()</span><br><span class="line">  <span class="keyword">async</span> findAll(): <span class="built_in">Promise</span>&lt;Cat[]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.catsService.findAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CatsService</code>是通过类构造函数注入的。注意这里使用了私有语法。这种简写允许我们在同一位置立即声明和初始化<code>catsService</code>成员。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>Nest是围绕通常称为依赖注入的强大设计模式构建的。我们建议在Angular官方文档中阅读一篇关于这个概念的<a href="https://angular.io/guide/dependency-injection">好文章</a>([[理解依赖注入]])。</p>
<p>在Nest中，由于TypeScript的功能，管理依赖非常容易，因为它们只按类型解析。在下面的示例中，Nest将通过创建和返回<code>catsService</code>的实例来解析<code>catsService</code>(或者，在单例的正常情况下，如果已经在其他地方请求了它，则返回现有的实例)。这个依赖被解析并传递给你的控制器的构造函数(或分配给指定的属性):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">private catsService: CatsService</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>Providers通常有一个与应用程序生命周期同步的生命周期(“作用域”)。当应用程序被引导时，必须解析每个依赖项，因此必须实例化每个提供者。类似地，当应用程序关闭时，每个提供程序都将被销毁。然而，也有一些方法可以使您的提供者生命周期限定在<code>request-scoped</code>内。你可以在<a href="https://docs.nestjs.com/fundamentals/injection-scopes">这里</a>阅读更多关于这些技术的内容。</p>
<h2 id="自定义-Providers"><a href="#自定义-Providers" class="headerlink" title="自定义 Providers"></a>自定义 Providers</h2><p>Nest有一个内置的控制反转(IoC)容器来解析providers之间的关系。这个特性是上述依赖注入特性的基础，但实际上比我们目前所描述的要强大得多。有几种方法可以定义提供程序:您可以使用普通值、类以及异步或同步工厂。这里提供了更多<a href="https://docs.nestjs.com/fundamentals/dependency-injection">示例</a>。</p>
<h2 id="Optional-providers"><a href="#Optional-providers" class="headerlink" title="Optional providers"></a>Optional providers</h2><p>偶尔，您可能会有不需要解析的依赖项。例如，您的类可能依赖于配置对象，但如果没有传递，则应使用默认值。在这种情况下，依赖项成为可选的，因为缺少配置提供程序不会导致错误。</p>
<p>要指出一个提供程序是可选的，可以在构造函数的签名中使用<code>@Optional()</code>装饰器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, Optional, Inject &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">@Optional() @Inject(<span class="string">&#x27;HTTP_OPTIONS&#x27;</span>) private httpClient: T</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在上面的示例中，我们使用的是自定义provider，这就是我们包含<code>HTTP_OPTIONS</code>自定义令牌的原因。前面的例子展示了基于构造函数的注入，通过构造函数中的类 表示 依赖项。在<a href="https://docs.nestjs.com/fundamentals/custom-providers">这里</a>阅读有关自定义提供程序及其相关令牌的更多信息。</p>
<h2 id="基于属性的注入"><a href="#基于属性的注入" class="headerlink" title="基于属性的注入"></a>基于属性的注入</h2><p>到目前为止，我们使用的技术被称为基于构造函数的注入，因为提供程序是通过构造函数方法注入的。在一些非常特殊的情况下，基于属性的注入可能很有用。例如，如果您的顶级类依赖于一个或多个提供程序，那么通过从构造函数调用子类中的<code>super()</code>来传递它们可能非常繁琐。为了避免这种情况，你可以在属性级别使用<code>@Inject()</code>装饰器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, Inject &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  @Inject(<span class="string">&#x27;HTTP_OPTIONS&#x27;</span>)</span><br><span class="line">  private readonly httpClient: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>如果你的类没有扩展其他providers，你应该总是使用基于构造函数的注入。</p>
</blockquote>
<h2 id="Provider-registration"><a href="#Provider-registration" class="headerlink" title="Provider registration"></a>Provider registration</h2><p>现在我们已经定义了一个<code>provider(CatsService)</code>，并且有了该服务的消费者(<code>CatsController</code>)，我们需要向Nest注册该服务，以便它可以执行注入。我们通过编辑模块文件(<code>app.module.ts</code>)并将服务添加到<code>@Module()</code>装饰器的<code>provider</code>s数组中来实现这一点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Nest现在可以解析<code>CatsController</code>类的依赖关系了。</p>
<p>现在我们的目录结构应该是这样的:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250928067.png" alt="image.png"></p>
<h2 id="手动实例化"><a href="#手动实例化" class="headerlink" title="手动实例化"></a>手动实例化</h2><p>到目前为止，我们已经讨论了Nest如何自动处理解析依赖项的大部分细节。在某些情况下，你可能需要走出内置的依赖注入系统，手动检索或实例化提供商。下面我们将简要讨论两个这样的主题。</p>
<ul>
<li>要获取现有实例或动态实例化提供程序，可以使用 <a href="https://docs.nestjs.com/fundamentals/module-ref">Module reference</a>.</li>
<li>要在<code>bootstrap()</code>函数中获取提供商(例如，对于没有控制器的独立应用程序，或在引导期间使用配置服务)，请参阅<a href="https://docs.nestjs.com/standalone-applications">独立应用程序</a>。</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>5. Nest.js Modules</title>
    <url>/2023/07/29/Node/NestJS/5.%20Nest.js%20Modules/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Module是一个带有<code>@Module()</code>装饰器的类。<code>@Module()</code>装饰器提供了Nest用来组织应用程序结构的元数据。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250928592.png" alt="image.png"></p>
<p><code>@Module()</code>装饰器接受一个对象，该对象的属性描述了该模块:</p>
<table>
<thead>
<tr>
<th>Properties</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Providers</td>
<td>这些提供商将被Nest注入器实例化，并且至少可以在整个模块中共享</td>
</tr>
<tr>
<td>controllers</td>
<td>在此模块中定义的控制器集，必须实例化</td>
</tr>
<tr>
<td>imports</td>
<td>导出该模块中所需的provider的导入模块列表</td>
</tr>
<tr>
<td>exports</td>
<td>提供程序的子集，由该模块提供，并且应该在导入该模块的其他模块中可用。您既可以使用提供者本身，也可以只使用它的令牌(提供值)</td>
</tr>
</tbody></table>
<p>该模块默认封装provider。这意味着不可能注入既不是当前模块的直接组成部分，也不是从导入模块导出的provider。因此，您可以将从模块导出的provider视为模块的公共接口或API。</p>
<h2 id="Feature-modules"><a href="#Feature-modules" class="headerlink" title="Feature modules"></a>Feature modules</h2><p><code>CatsController</code>和<code>CatsService</code>属于同一个应用程序域。由于它们密切相关，因此将它们移到特性模块中是有意义的。功能模块只是组织与特定功能相关的代码，保持代码的组织性并建立清晰的边界。这有助于我们管理复杂性，并使用<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a>原则进行开发，特别是当应用程序和/或团队的规模增长时。</p>
<p>为了演示这一点，我们将创建<code>CatsModule</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>要使用CLI创建一个模块，只需执行<code>$ nest g module cats</code>命令。</p>
</blockquote>
<p>上面，我们在<code>cats.module.ts</code>文件中定义了<code>CatsModule</code>，并将与该模块相关的所有内容移动到<code>cats</code>目录中。我们需要做的最后一件事是将这个模块导入根模块(<code>AppModule</code>，定义在<code>app.module.ts</code>文件中)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们的目录结构:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250928069.png" alt="image.png"></p>
<h2 id="Shared-modules"><a href="#Shared-modules" class="headerlink" title="Shared modules"></a>Shared modules</h2><p>在Nest中，模块默认是单例的，因此你可以毫不费力地在多个模块之间共享任何提供者的相同实例。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250929399.png" alt="image.png"></p>
<p>每个模块自动成为一个共享模块。一旦创建，它就可以被任何模块重用。假设我们想要在其他几个模块之间共享<code>CatsService</code>的一个实例。为了做到这一点，我们首先需要通过将其添加到模块的<code>exports</code>数组中来导出<code>CatsService</code>提供商，如下所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">  <span class="attr">exports</span>: [CatsService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，任何导入<code>CatsModule</code>的模块都可以访问<code>CatsService</code>，并将与导入它的所有其他模块共享同一个实例。</p>
<h2 id="Module-re-exporting"><a href="#Module-re-exporting" class="headerlink" title="Module re-exporting"></a>Module re-exporting</h2><p>如上所述，模块可以导出它们的内部provider。此外，它们还可以重新导出它们导入的模块。在下面的例子中，<code>CommonModule</code>被导入<code>CoreModule</code>并从<code>CoreModule</code>中导出，使得它可以被其他导入这个模块的模块使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CommonModule],</span><br><span class="line">  <span class="attr">exports</span>: [CommonModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dependency-injection"><a href="#Dependency-injection" class="headerlink" title="Dependency injection"></a>Dependency injection</h2><p>模块类也可以注入provider(例如，用于配置目的):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private catsService: CatsService</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，由于循环依赖，模块类本身不能作为provider注入。</p>
<h2 id="Global-modules"><a href="#Global-modules" class="headerlink" title="Global modules"></a>Global modules</h2><p>如果必须在任何地方导入相同的模块集，就会变得很繁琐。与Nest不同，angular的providers是在全局作用域中注册的。一旦定义，它们就随处可见。然而，Nest将提供程序封装在模块作用域中。如果不先导入封装模块，就不能在其他地方使用模块的提供程序。</p>
<p>当你想要提供一组在任何地方都可以使用的提供程序(例如，帮助程序、数据库连接等)时，使用<code>@Global()</code>装饰器将模块设置为全局。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, Global &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Global()</span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [CatsController],</span><br><span class="line">  <span class="attr">providers</span>: [CatsService],</span><br><span class="line">  <span class="attr">exports</span>: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Global()</code>装饰器使模块成为全局作用域。全局模块应该只注册一次，通常由根模块或核心模块注册。在上面的例子中，<code>CatsService</code>提供者将是无处不在的，并且希望注入该服务的模块将不需要在其imports数组中导入<code>CatsModule</code>。</p>
<blockquote>
<p>[!hint]<br>让所有东西都是全局的并不是一个好的设计决策。可以使用全局模块来减少必要的样板文件的数量。<code>imports</code>数组通常是让消费者可以使用模块API的首选方式。</p>
</blockquote>
<h2 id="Dynamic-modules"><a href="#Dynamic-modules" class="headerlink" title="Dynamic modules"></a>Dynamic modules</h2><p>Nest模块系统包括一个强大的功能，称为动态模块。此特性使您能够轻松地创建可定制的模块，这些模块可以动态地注册和配置提供程序。动态模块在<a href="https://docs.nestjs.com/fundamentals/dynamic-modules">这里</a>有广泛的介绍。在本章中，我们将给出一个简短的概述来完成对模块的介绍。</p>
<p>下面是一个<code>DatabaseModule</code>动态模块定义的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, DynamicModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createDatabaseProviders &#125; <span class="keyword">from</span> <span class="string">&#x27;./database.providers&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Connection &#125; <span class="keyword">from</span> <span class="string">&#x27;./connection.provider&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">providers</span>: [Connection],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> forRoot(entities = [], options?): DynamicModule &#123;</span><br><span class="line">    <span class="keyword">const</span> providers = createDatabaseProviders(options, entities);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">module</span>: DatabaseModule,</span><br><span class="line">      <span class="attr">providers</span>: providers,</span><br><span class="line">      <span class="attr">exports</span>: providers,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br><code>forRoot()</code>方法可以同步或异步(即通过<code>Promise</code>)返回一个动态模块。</p>
</blockquote>
<p>该模块在默认情况下定义了<code>Connection</code> provider(在<code>@Module()</code>装饰器元数据中)，但另外——取决于传递给<code>forRoot()</code>方法的<code>entities</code>和<code>options</code>对象——还公开了一个提供程序集合，例如存储库。注意，动态模块返回的属性扩展(而不是覆盖)了在<code>@Module()</code>装饰器中定义的基本模块元数据。这就是从模块导出静态声明的<code>Connection</code>提供程序和动态生成的存储库提供程序的方式。</p>
<p>如果要在全局作用域中注册一个动态模块，请将<code>global</code>属性设置为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">global</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">module</span>: DatabaseModule,</span><br><span class="line">  <span class="attr">providers</span>: providers,</span><br><span class="line">  <span class="attr">exports</span>: providers,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!warning]<br>正如上面所提到的，让所有东西都是全局的并不是一个好的设计决策。</p>
</blockquote>
<p>DatabaseModule可以通过以下方式导入和配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DatabaseModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./database/database.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;./users/entities/user.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [DatabaseModule.forRoot([User])],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想反过来重新导出一个动态模块，你可以忽略exports数组中的forRoot()方法调用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DatabaseModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./database/database.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;./users/entities/user.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [DatabaseModule.forRoot([User])],</span><br><span class="line">  <span class="attr">exports</span>: [DatabaseModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.nestjs.com/fundamentals/dynamic-modules">动态模块</a>一章更详细地介绍了这个主题，并包括一个<a href="https://github.com/nestjs/nest/tree/master/sample/25-dynamic-modules">工作示例</a></p>
<blockquote>
<p>[!hint]<br>在<a href="https://docs.nestjs.com/fundamentals/dynamic-modules#configurable-module-builder">本章</a>中，学习如何使用<code>ConfigurableModuleBuilder</code>构建高度可定制的动态模块。</p>
</blockquote>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>6. Nest.js 中间件</title>
    <url>/2023/07/29/Node/NestJS/6.%20Nest.js%20%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>中间件是一个在路由处理程序之前被调用的函数。中间件函数可以访问请求和响应对象，以及应用程序请求-响应周期中的<code>next()</code>中间件函数。next中间件函数通常由一个名为next的变量表示。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250929639.png" alt="image.png"></p>
<p>默认情况下，Nest中间件相当于<a href="https://expressjs.com/en/guide/using-middleware.html">express</a>中间件。以下来自官方快速文档的描述描述了中间件的功能:</p>
<blockquote>
<p>中间件函数可以执行以下任务:</p>
<ul>
<li>执行任何代码。</li>
<li>对请求和响应对象进行更改。</li>
<li>调用堆栈中的下一个中间件函数。</li>
<li>如果当前中间件函数没有结束<code>请求-响应周期</code>，它必须调用next()将控制传递给下一个中间件函数。否则，请求将被挂起。</li>
</ul>
</blockquote>
<blockquote>
<p>[!warning]<br><code>Express</code>和<code>fastify</code>以不同的方式表达和处理中间件，并提供不同的方法签名。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, NestMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request, Response, NextFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerMiddleware</span> <span class="title">implements</span> <span class="title">NestMiddleware</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">use</span>(<span class="params">req: Request, res: Response, next: NextFunction</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Request...&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>Nest中间件完全支持依赖注入。与提供程序和控制器一样，它们能够注入在同一模块中可用的依赖项。像往常一样，这是通过<code>constructor</code>完成的。</p>
<h2 id="应用中间件"><a href="#应用中间件" class="headerlink" title="应用中间件"></a>应用中间件</h2><p>在<code>@Module()</code>装饰器中没有中间件的位置。相反，我们使用模块类的<code>configure()</code>方法来设置它们。包含中间件的模块必须实现<code>NestModule</code>接口。让我们在<code>AppModule</code>级别设置<code>LoggerMiddleware</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>)</span> &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(<span class="string">&#x27;cats&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们已经为之前在<code>CatsController</code>中定义的<code>/cats</code>路由处理程序设置了<code>LoggerMiddleware</code>。我们还可以在配置中间件时将包含路由路径和请求方法的对象传递给<code>forRoutes()</code>方法，从而进一步将中间件限制为特定的请求方法。在下面的示例中，请注意我们导入了<code>RequestMethod</code> enum来引用所需的请求方法类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, RequestMethod, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>)</span> &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(&#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: RequestMethod.GET &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br><code>configure()</code>方法可以使用<code>async/await</code>实现异步(例如，你可以在<code>configure()</code>方法体中等待异步操作的完成)。</p>
</blockquote>
<blockquote>
<p>[!warning]<br>当使用<code>express</code>适配器时，默认情况下，NestJS应用会从包体解析器中注册<code>json</code>和<code>urlencoded</code>。这意味着，如果您想通过<code>MiddlewareConsumer</code>定制中间件，那么在使用<code>NestFactory.create()</code>创建应用程序时，需要通过将<code>bodyParser</code>标志设置为<code>false</code>来关闭全局中间件。</p>
</blockquote>
<h2 id="路由通配符"><a href="#路由通配符" class="headerlink" title="路由通配符"></a>路由通配符</h2><p>Nest也支持基于模式的路由。例如，星号用作通配符，并将匹配任何字符组合:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">forRoutes(&#123; <span class="attr">path</span>: <span class="string">&#x27;ab*cd&#x27;</span>, <span class="attr">method</span>: RequestMethod.ALL &#125;);</span><br></pre></td></tr></table></figure>

<p><code>&#39;ab*cd&#39;</code>路由路径将匹配<code>abcd, ab_cd, abecd</code>，等等。字符<code>?、+、*和()</code>可以在路由路径中使用，它们是对应正则表达式的子集。连字符(-)和点(.)由基于字符串的路径逐字解释。</p>
<blockquote>
<p>[!warning]<br><code>fastify</code>包使用最新版本的<code>path-to-regexp</code>包，它不再支持通配符<em>。相反，您必须使用参数(例如，(.</em>)，:splat*)。</p>
</blockquote>
<h2 id="中间件消费者"><a href="#中间件消费者" class="headerlink" title="中间件消费者"></a>中间件消费者</h2><p><code>MiddlewareConsumer</code>是一个helper类。它提供了几个内置的方法来管理中间件。所有这些都可以用流畅的样式简单地链接起来。<code>forRoutes()</code>方法可以接受一个字符串、多个字符串、一个<code>RouteInfo</code>对象、一个控制器类，甚至多个控制器类。在大多数情况下，您可能只是传递一个以逗号分隔的控制器列表。下面是单个控制器的示例:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.controller&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> <span class="title">implements</span> <span class="title">NestModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>)</span> &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(CatsController);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br><code>apply()</code>方法可以接受单个中间件，也可以接受多个参数来指定多个中间件。</p>
</blockquote>
<h2 id="排除路由"><a href="#排除路由" class="headerlink" title="排除路由"></a>排除路由</h2><p>有时，我们希望从应用中间件中排除某些路由。我们可以使用<code>exclude()</code>方法轻松地排除某些路由。这个方法可以接受一个字符串、多个字符串或一个<code>RouteInfo</code>对象来标识要排除的路由，如下所示:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">consumer</span><br><span class="line">  .apply(LoggerMiddleware)</span><br><span class="line">  .exclude(</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: RequestMethod.GET &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: RequestMethod.POST &#125;,</span><br><span class="line">    <span class="string">&#x27;cats/(.*)&#x27;</span>,</span><br><span class="line">  )</span><br><span class="line">  .forRoutes(CatsController);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>exclude()方法使用path-to-regexp包支持通配符参数。</p>
</blockquote>
<p>在上面的例子中，<code>LoggerMiddleware</code>将被绑定到<code>Catscontroller</code>内部定义的所有路由，除了传递给<code>exclude()</code>方法的三个路由。</p>
<h2 id="功能性中间件"><a href="#功能性中间件" class="headerlink" title="功能性中间件"></a>功能性中间件</h2><p>我们一直在使用的LoggerMiddleware类非常简单。它没有成员，没有额外的方法，也没有依赖关系。为什么我们不能在一个简单的函数而不是在类中定义它呢?事实上，我们可以。这种类型的中间件称为函数中间件。让我们将<code>logger middleware</code>从基于类的转换为函数中间件来说明它们的区别:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Request, Response, NextFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">req: Request, res: Response, next: NextFunction</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Request...`</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并在<code>AppModule</code>中使用它:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">consumer</span><br><span class="line">  .apply(logger)</span><br><span class="line">  .forRoutes(CatsController);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>当您的中间件不需要任何依赖项时，请考虑使用更简单的函数中间件替代方案。</p>
</blockquote>
<h2 id="多中间件"><a href="#多中间件" class="headerlink" title="多中间件"></a>多中间件</h2><p>如上所述，为了绑定顺序执行的多个中间件，只需在apply()方法中提供一个逗号分隔的列表:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h2><p>如果我们想一次将中间件绑定到每个注册路由，我们可以使用<code>INestApplication</code>实例提供的<code>use()</code>方法:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">app.use(logger);</span><br><span class="line"><span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>在全局中间件中访问<code>DI</code>（Dependency Injection）容器是不可能的。你可以在使用<code>app.use()</code>时使用函数中间件。或者，你可以使用类中间件，并在<code>AppModule</code>(或任何其他模块)中使用<code>.forRoutes(&#39;*&#39;)</code>来消费它。</p>
</blockquote>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2023/07/23/Node/NestJS/test/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5
  </pre></div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Key elements in Product X</span><br><span class="line">    &quot;Calcium&quot; : 42.96</span><br><span class="line">    &quot;Potassium&quot; : 50.05</span><br><span class="line">    &quot;Magnesium&quot; : 10.01</span><br><span class="line">    &quot;Iron&quot; :  5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>promise 是处理异步请求的特殊对象</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>Promise 有三种状态。</p>
<ol>
<li><strong>pending</strong>(进行中): 初始状态，不是成功或失败状态。处于 pending 状态时，可以使用 then() 方法指定成功和失败的回调函数，<strong>then()方法中的回调函数会统一处理fulfilled和rejected，而不是单独为这两种状态指定不同的处理函数</strong>。</li>
<li><strong>fulfilled</strong>(已完成): 意味着操作成功完成。已经处于 fulfilled 或 rejected 状态，将立即执行相应的回调函数。</li>
<li><strong>rejected</strong>(已失败): 意味着操作失败。已经处于 fulfilled 或 rejected 状态，将立即执行相应的回调函数。</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, url);  </span><br><span class="line">    xhr.onload = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;  </span><br><span class="line">        resolve(xhr.responseText);  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    xhr.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Network Error&quot;</span>));  </span><br><span class="line">    xhr.send();  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">getData(<span class="string">&quot;https://example.com/todos/1&quot;</span>)  </span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data))  </span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>并行执行多个 Promise 对象，并在所有 Promise 对象都成功时返回结果。<br>promise.all 是一个 JavaScript 的方法，它接收一个 promise 的可迭代对象（如数组或字符串）作为参数，并返回一个新的 promise 对象。这个新的 promise 对象的状态和结果取决于传入的 promise 对象的状态和结果。<br>如果传入的可迭代对象是空的，或者不包含任何 promise 对象，那么 promise.all 会同步地返回一个已完成（resolved）状态的 promise 对象，它的结果是一个空数组。<br>如果传入的可迭代对象包含至少一个 promise 对象，那么 promise.all 会异步地等待所有的 promise 对象都完成（resolved）或有一个失败（rejected）。<br>如果所有的 promise 对象都完成了，那么 promise.all 返回的 promise 对象也会完成，它的结果是一个包含所有传入的 promise 对象的结果的数组，数组中的顺序和传入的顺序一致。<br>如果有任何一个 promise 对象失败了，那么 promise.all 返回的 promise 对象也会失败，它的结果是第一个失败的 promise 对象的原因。<br>| 输入                        | 输出                                                                                                |<br>| ————————— | ————————————————————————————————— |<br>| 空数组                      | Promise { “fulfilled”, [] }                                                                         |<br>| 非 promise 值               | Promise { “fulfilled”, [输入值] }                                                                   |<br>| 已完成或已失败的 promise 值 | Promise { 第一个失败的 promise 的状态, 第一个失败的 promise 的原因或所有成功的 promise 的结果数组 } |<br>| 未完成或未失败的 promise 值 | Promise { “pending” }                                                                               |<br>|                             |                                                                                                     |<br>![[Pasted image 20230514165735.png]]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = getData(<span class="string">&quot;/api/data1&quot;</span>);  </span><br><span class="line"><span class="keyword">const</span> promise2 = getData(<span class="string">&quot;/api/data2&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2])  </span><br><span class="line">  .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(data1);  </span><br><span class="line">    <span class="built_in">console</span>.log(data2);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race() 方法可以竞速执行多个 Promise 对象，并返回第一个完成的 Promise 对象的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;result1&quot;</span>), <span class="number">1000</span>));  </span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;result2&quot;</span>), <span class="number">500</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2])  </span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))  </span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>await是一个运算符，用于等待一个表达式的结果，它只能在异步函数（async function）中使用。<br>await可以等待一个Promise对象，也可以等待一个普通的值。如果等待的是一个Promise对象，await会阻塞后面的代码，直到Promise对象被兑现（resolve）或拒绝（reject），并返回其兑现的值或抛出拒绝的原因。如果等待的是一个普通的值，await会直接返回该值。<br>await可以用于等待异步函数的返回值，也可以用于等待其他的异步操作，比如setTimeout，fetch等。</p>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then方法是Promise对象的一个方法，它可以接受两个参数，分别是onFulfilled和onRejected。onFulfilled是一个函数，它会在Promise状态变为fulfilled时被调用，onRejected是一个函数，它会在Promise状态变为rejected时被调用。如果你只传递了onFulfilled参数，那么then方法只有在Promise状态变为fulfilled时才会被调用。如果你想在Promise状态变为rejected时也有相应的处理，你可以传递第二个参数onRejected，或者使用catch方法。</p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>catch方法是then方法的一种简写形式，它相当于then(undefined, onRejected)。  catch方法返回的是一个新的Promise对象，它可以继续链式调用then方法。如果catch方法没有抛出异常或返回一个被拒绝的Promise对象，那么它返回的Promise对象会被兑现（fulfilled）。</p>
<h4 id="then和catch"><a href="#then和catch" class="headerlink" title="then和catch"></a>then和catch</h4><p>catch方法可以捕获前面then方法中抛出的异常，而then方法的第二个参数不能捕获自身的异常。</p>
<h2 id="Some-Questions"><a href="#Some-Questions" class="headerlink" title="Some Questions"></a>Some Questions</h2><h4 id="promise不管包装的是什么内容都会是异步的吗"><a href="#promise不管包装的是什么内容都会是异步的吗" class="headerlink" title="promise不管包装的是什么内容都会是异步的吗?"></a>promise不管包装的是什么内容都会是异步的吗?</h4><p>答：<br>•  promise是一种用于表示异步操作的最终完成或失败及其结果值的对象。<br>•  promise可以包装任何类型的值，无论是普通的值还是另一个promise对象。<br>•  promise本身并不是异步的，它只是一个代理，用于在未来某个时候把值交给使用者。<br>•  promise的异步性体现在它的状态转换上，它有三种状态：待定（pending），已兑现（fulfilled）和已拒绝（rejected）。<br>•  当一个promise被创建时，它处于待定状态，此时它还没有被兑现或被拒绝，也没有任何结果值。<br>•  当一个promise被兑现或被拒绝时，它就变成了已敲定（settled）状态，此时它有一个不可变的结果值，并且不能再改变状态。<br>•  promise的状态转换通常是由异步操作触发的，比如setTimeout，fetch等。当异步操作完成时，它会调用promise构造函数中传入的resolve或reject函数，从而改变promise的状态，并传递结果值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&quot;foo&quot;</span>); <span class="comment">// 异步操作完成后，调用resolve函数，将promise状态从pending变为fulfilled，并传递结果值&#x27;foo&#x27;</span></span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>•  promise的状态转换也可以由同步操作触发，比如直接在构造函数中调用resolve或reject函数。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&quot;bar&quot;</span>); <span class="comment">// 同步操作完成后，调用resolve函数，将promise状态从pending变为fulfilled，并传递结果值&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>•  但是，即使promise的状态转换是由同步操作触发的，它也不会立即执行与之关联的处理函数（then，catch等），而是会将它们放入微任务队列（microtask queue），等待当前执行栈清空后再执行。这样做的目的是为了保证promise的行为一致性和可预测性。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&quot;bar&quot;</span>); <span class="comment">// 同步操作完成后，调用resolve函数，将promise状态从pending变为fulfilled，并传递结果值&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">myPromise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 这个函数不会立即执行，而是会放入微任务队列中等待</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;baz&quot;</span>); <span class="comment">// 这个语句会先于上面的函数执行</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>•  因此，可以说<strong>promise不管包装的是什么内容都会有一定程度的异步性，但这并不意味着它们都会产生新的异步操作。这取决于promise内部如何触发状态转换和结果值传递</strong>。</p>
]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>for of 和 for in的区别 ？</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/for%20of%20%E5%92%8C%20for%20in%E7%9A%84%E5%8C%BA%E5%88%AB%20%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>for in 遍历的是key,for of 遍历value</p>
]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>valueOf和toString</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/valueOf%E5%92%8CtoString/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>console.log()直接打印的话中除了object直接打印、date执行两次toString,其余都toString再用valueOf,<br>alert(),String()中都只使用了toString()，<br>如果需要进行运算，都是先进行valueOf再toString<br>总而言之，<strong>与数字、运算有关的用valueOf优先,其他都是toString优先</strong></p>
]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>7. Nest.js 异常过滤器</title>
    <url>/2023/07/29/Node/NestJS/7.%20Nest.js%20%E5%BC%82%E5%B8%B8%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nest有一个内置的异常层，负责处理整个应用程序中所有未处理的异常。当应用程序代码没有处理异常时，该层将捕获异常，然后自动发送适当的用户友好响应。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307281131809.png" alt="image.png"></p>
<p>开箱即用，此操作由内置的全局异常过滤器执行，该过滤器处理类型为<code>HttpException</code>的异常(及其子类)。当异常无法识别时(既不是<code>HttpException</code>也不是继承自<code>HttpException</code>的类)，内置异常过滤器会生成以下默认JSON响应:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;statusCode&quot;</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Internal server error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>全局异常过滤器部分支持<code>http-errors</code>库。基本上，任何包含<code>statusCode</code>和<code>message</code>属性的抛出异常都将被正确填充并作为响应发送回来(而不是无法识别的异常使用默认的<code>Internalservererroreexception</code>)。</p>
</blockquote>
<h2 id="抛出标准的异常"><a href="#抛出标准的异常" class="headerlink" title="抛出标准的异常"></a>抛出标准的异常</h2><p>Nest提供了一个内置的<code>HttpException</code>类，从<code>@nestjs/common</code>包中公开。对于典型的基于<code>HTTP REST/GraphQL API</code>的应用程序，最佳实践是在发生某些错误条件时发送标准HTTP响应对象。</p>
<p>例如，在<code>CatsController</code>中，我们有一个<code>findAll()</code>方法(<code>GET</code>路由处理程序)。让我们假设这个路由处理程序由于某种原因抛出了一个异常。为了演示这一点，我们将硬编码如下:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Get</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">findAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">&#x27;Forbidden&#x27;</span>, HttpStatus.FORBIDDEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!hint]<br>我们在这里使用了<code>HttpStatus</code>。这是从<code>@nestjs/common</code>包中导入的一个helper枚举。</p>
</blockquote>
<p>当客户端调用这个端点时，响应看起来像这样:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;statusCode&quot;</span>: <span class="number">403</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Forbidden&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HttpException构造函数接受两个必需的参数来决定响应:</p>
<ul>
<li><code>response</code>参数定义JSON响应体。它可以是如下所述的字符串或对象。</li>
<li><code>status</code>参数定义<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HTTP状态码</a>。</li>
</ul>
<p>默认情况下，JSON响应体包含两个属性:</p>
<ul>
<li><code>statusCode</code>:默认为status参数中提供的HTTP状态码</li>
<li><code>message</code>:基于状态的HTTP错误的简短描述</li>
</ul>
<p>要覆盖JSON响应体的消息部分，请在<code>response</code>参数中提供一个字符串。要覆盖整个JSON响应体，请在<code>response</code>参数中传递一个对象。Nest将序列化该对象并将其作为JSON响应体返回。</p>
<p>第二个构造函数参数 <code>status</code> 应该是一个有效的HTTP状态码。最佳实践是使用从<code>@nestjs/common</code>导入的<code>HttpStatus</code> enum。</p>
<p>第三个构造函数参数(可选)<code>options</code>可用于提供错误原因。这个<code>cause</code>对象没有被序列化到响应对象中，但是它对于日志记录很有用，提供了关于导致<code>HttpException</code>抛出的内部错误的有价值的信息。</p>
<p>下面是一个覆盖整个响应体并提供错误原因的示例:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Get</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">findAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.service.findAll()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(&#123;</span><br><span class="line">      <span class="attr">status</span>: HttpStatus.FORBIDDEN,</span><br><span class="line">      <span class="attr">error</span>: <span class="string">&#x27;This is a custom message&#x27;</span>,</span><br><span class="line">    &#125;, HttpStatus.FORBIDDEN, &#123;</span><br><span class="line">      <span class="attr">cause</span>: error</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们会看到这样的响应：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">403</span>,</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;This is a custom message&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>在许多情况下，您不需要编写自定义异常，可以使用内置的Nest HTTP异常，如下一节所述。如果确实需要创建自定义异常，最好的做法是创建自己的异常层次结构，其中自定义异常继承自<code>HttpException</code>基类。使用这种方法，Nest将识别异常，并自动处理错误响应。让我们实现这样一个自定义异常:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ForbiddenException</span> <span class="keyword">extends</span> <span class="title">HttpException</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&#x27;Forbidden&#x27;</span>, HttpStatus.FORBIDDEN);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>Nest命令</title>
    <url>/2023/07/21/Node/NestJS/Nest%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装Nest"><a href="#安装Nest" class="headerlink" title="安装Nest"></a>安装Nest</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g @nestjs/cli</span><br></pre></td></tr></table></figure>

<h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest new project-name</span><br></pre></td></tr></table></figure>

<h2 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器"></a>创建控制器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest g controller [name]</span><br></pre></td></tr></table></figure>

<h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest g service [name]</span><br></pre></td></tr></table></figure>

<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest g module [name]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Node</category>
        <category>NestJS</category>
      </categories>
  </entry>
  <entry>
    <title>生命周期</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><h2 id="Vue-自定义指令"><a href="#Vue-自定义指令" class="headerlink" title="Vue 自定义指令"></a>Vue 自定义指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() -&gt;        -&gt; mounted() -&gt;      -&gt; updated() -&gt;            -&gt; unmounted()</span><br><span class="line">		beforeMounted()        beforeUpdated()     beforeUnmounted()       </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>闭包 ？</title>
    <url>/2023/06/24/Others/%E9%9D%A2%E8%AF%95/%E9%97%AD%E5%8C%85%20%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Others</category>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>1. 什么是 Next.js</title>
    <url>/2023/07/08/React/NextJS/1.%20%E4%BB%80%E4%B9%88%E6%98%AF%20Next.js/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Next.js是一个灵活的React框架可以给你提供构建块快速创建Web应用程序。<br>但是我们实际上的意思是什么呢？让我花时间拓展一下什么是React和Next.js以及它们能提供什么帮助？</p>
<h2 id="Web应用程序的构建块"><a href="#Web应用程序的构建块" class="headerlink" title="Web应用程序的构建块"></a>Web应用程序的构建块</h2><p>这里有一些事情是你需要去考虑的，当你在构建一个现代的应用程序的时候，例如：</p>
<ul>
<li>User Interface - 用户怎么使用应用程序并与之交互</li>
<li>Routing - 用户如何在应用程序的不同部分之间导航</li>
<li>Data Fetching - 你的数据在哪以及怎么获取它们</li>
<li>Rendering - 在何时何处渲染你的静态的或者动态的内容</li>
<li>Integrations - 你使用了哪些第三方服务以及你如何连接它们</li>
<li>Infrastructure - 你在哪里部署、存储和运行你的应用程序代码</li>
<li>Performance - 怎么去为最终用户优化你的应用</li>
<li>Scalability(可扩展性、可伸缩性) -  应用程序怎么适应你的团队、数据和流量的增长</li>
<li>Developer Experience - 你的团队构建和维护你的应用程序时的体验</li>
</ul>
<p>对于你的应用程序的每一部分，你需要去决定是否需要去构建你的自己的解决方案或者使用其它的工具，例如库或者框架。</p>
<h2 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React ?"></a>什么是 React ?</h2><p>React 是一个用于构建交互式用户界面的 Javascript 库。</p>
<p>用户界面，即用户在屏幕上看到和交互的元素。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250932287.png" alt="image.png"></p>
<p>库，即 React 提供的有用的功能来构建用户界面，但是让开发人员来决定要在哪里使用这些功能。</p>
<p>React成功的部分原因是它在构建应用程序时相对的不太容易受到其他方面的影响，这导致了它第三方工具个解决方案的生态环境的繁荣。</p>
<p>然而，这也意味着从零开始构建一个完整的 React 的应用程序需要开发人员的一些努力，开发人员需要花时间去配置工具和改造那些通用的应用程序的解决方案。</p>
<h2 id="什么是-Next-js"><a href="#什么是-Next-js" class="headerlink" title="什么是 Next.js ?"></a>什么是 Next.js ?</h2><p>Next.js 是一个提供构建块去创建应用程序的React的框架。</p>
<p>通过框架，Next可以处理React所需的工具和配置，并且为你的程序提供额外的架构、特性、和优化。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250933657.png" alt="image.png"></p>
<p>你可以使用React 去构建你的用户界面，然后逐步采用Next.js的特性来解决常见的应用需求，比如路由、数据获取、集成——所有这些都可以改善开发者和最终用户的体验。</p>
<p>无论你是个人开发人员还是大型团队的一员，你都可以利用React和Next.js来构建完全交互式的、高度动态的、高性能的web应用程序。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>2. 从Javascript到React</title>
    <url>/2023/07/09/React/NextJS/2.%20%E4%BB%8EJavascript%E5%88%B0React/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="渲染用户界面"><a href="#渲染用户界面" class="headerlink" title="渲染用户界面"></a>渲染用户界面</h2><p>为了理解React是怎么工作，我们首先需要对浏览器怎么解释你的代码去创建交互式的界面有一个基础的理解。</p>
<p>当一个用户访问网页，服务器返回给浏览器的HTML文件可能看上去是这样的：</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250933168.png" alt="image.png"></p>
<p>然后浏览器开始阅读HTML并构建文档对象模型（DOM）。</p>
<h2 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM ?"></a>什么是 DOM ?</h2><p>DOM是HTML元素的对象表现形式，它扮演了你代码和用户界面之间的桥梁，具有父级和子级关系的树形结构。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250933484.png" alt="image.png"></p>
<p>你可以使用DOM方法和编程语言，例如Javascript，去监听用户时间和操作DOM通过选择、添加、更新和删除用户界面上的指定的元素。DOM操作不仅仅只是指定元素而且允许你改变它们的样式和内容。</p>
<h2 id="更新-UI-通过-Javascript-和-DOM-方法"><a href="#更新-UI-通过-Javascript-和-DOM-方法" class="headerlink" title="更新 UI 通过 Javascript 和 DOM 方法"></a>更新 UI 通过 Javascript 和 DOM 方法</h2><p>让我们看看你怎么使用Javascript和DOM方法通过在你的项目中添加一个<code>h1</code>标签。<br>打开你的代码编辑器并且创建一个新的<code>index.html</code>文件。在htm文件中添加下面的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后给<code>div</code>元素一个唯一的<code>id</code>，以便你后面可以定位到它。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在html内部编写Javascript，添加一个<code>script</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，在<code>script</code>标签内部，你可以使用DOM方法，<code>getElementById()</code>，选中<code>div</code>元素通过<code>id</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以继续使用DOM方法来创建一个新的<code>h1</code>元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Select the div element with &#x27;app&#x27; id</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Create a new H1 element</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Create a new text node for the H1 element</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> headerContent = <span class="built_in">document</span>.createTextNode(</span></span><br><span class="line"><span class="javascript">        <span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      );</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Append the text to the H1 element</span></span></span><br><span class="line"><span class="javascript">      header.appendChild(headerContent);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// Place the H1 element inside the div</span></span></span><br><span class="line"><span class="javascript">      app.appendChild(header);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了确保所有东西都能运作，在你选择的浏览器内部打开你选择的HTML文件，你会看到一个“Develop. Preview. Ship 🚀”的<code>h1</code>标签。</p>
<h2 id="HTML-vs-DOM"><a href="#HTML-vs-DOM" class="headerlink" title="HTML vs DOM"></a>HTML vs DOM</h2><p>如果你观察你的浏览器开发工具内部的DOM元素，你会注意到包括<code>h1</code>标签的DOM元素。这个页面的DOM不同于源代码或者换种说话，你创建的源HTML文件。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250934833.png" alt="image.png"></p>
<p>这是因为HTML代表的是初始页面内容，而DOM代表了被你写的Javascript代码更改后的页面内容。</p>
<p>使用原生js更新DOM是非常有力的，但是繁琐的。你已经编写了所有的代码来添加一个<code>h1</code>元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> headerContent = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  header.appendChild(headerContent);</span></span><br><span class="line"><span class="javascript">  app.appendChild(header);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>随着团队或者应用规模的增长，通过这种方式构建应用的挑战是逐步增加的。</p>
<p>使用这种方法，开发者花了很多时间写说明去告诉计算机它应该怎么做事，但是，描述你想要显示的内容并且让计算机计算如何同更新DOM不是更好吗？</p>
<h2 id="命令式编程-vs-声明式编程"><a href="#命令式编程-vs-声明式编程" class="headerlink" title="命令式编程 vs 声明式编程"></a>命令式编程 vs 声明式编程</h2><p>上面的代码是命令式编程的一个好例子，你编写如何更新UI的步骤。但是对于构建UI，声明式的方法往往更好，因为它可以加速开发过程。如果开发者能声明他们想去显示的这将是有用的，而不是去写DOM方法。</p>
<p>换句话说，命令式编程就像是给一个厨师如何一步步制作披萨的说明书，声明式编程就是去买一个披萨而不用考虑制作披萨的步骤。</p>
<p>React是一个流行的帮助开发者构建用户界面的声明库。</p>
<h2 id="React-一个声明式的UI库"><a href="#React-一个声明式的UI库" class="headerlink" title="React: 一个声明式的UI库"></a>React: 一个声明式的UI库</h2><p>作为一个开发者，你可以告诉React你让要让用户界面发生什么，React会代替你弄清楚怎么更新DOM的步骤。</p>
<p>在下一个部分，我们会探索如何开始使用React。</p>
<h2 id="开始使用-React"><a href="#开始使用-React" class="headerlink" title="开始使用 React"></a>开始使用 React</h2><p>为了使用React，你可以从 unpkg.com 加载两个React脚本。</p>
<ul>
<li>react 是核心React库</li>
<li>react-dom提供了特定的方法是您能够将React与DOM一起使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以使用<code>react-dom</code>的<code>React.render()</code>来告诉React在<code>#app</code>元素中渲染<code>h1</code>,而不是直接使用原生js来操作DOM.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，如果你试图在浏览器中运行这段代码，你将会得到一个 syntax error(语法错误)。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250934175.png" alt="image.png"></p>
<p>这是因为<code>&lt;h1&gt;...&lt;/h1&gt;</code>在Javascript中是无效的，这是一段<code>JSX</code>代码。</p>
<h2 id="什么是-JSX"><a href="#什么是-JSX" class="headerlink" title="什么是 JSX ?"></a>什么是 JSX ?</h2><p>JSX 是JavaScript的语法拓展，允许你描述你的UI使用类似于HTML的语法，一件很棒的事情就是除了三条JSX的规则你需要知道以外，就没有HTML和Javascript之外的别的新的标识符或者语法需要学习了。</p>
<p>需要注意的是，浏览器不能直接理解JSX，所以你需要一个Javascript编译器，例如<code>Babel</code>，去把你的JSX代码转换成常规的Javascript。</p>
<h2 id="添加-Babel-到你的项目"><a href="#添加-Babel-到你的项目" class="headerlink" title="添加 Babel 到你的项目"></a>添加 Babel 到你的项目</h2><p>将下面的脚本复制粘贴到你的<code>index.html</code>中就将Babel添加到了你的项目中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除此之外，你需要通过改变脚本类型为<code>type=text/jsx</code>来通知Babel要转换的是什么代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Babel Script --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以在浏览器中运行你的代码去确保它是正常工作的。</p>
<p>比较你写的React的声明式代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和你在之前的部分写的命令式代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> headerContent = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  header.appendChild(headerContent);</span></span><br><span class="line"><span class="javascript">  app.appendChild(header);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用React你可以节省大量的重复代码。</p>
<p>这正是React做的，它包括一些可重复执行的代码片段，这些代码可以代替你执行任务，在这个例子中是代替你更新UI。</p>
<h2 id="React-必备的-Javascript"><a href="#React-必备的-Javascript" class="headerlink" title="React 必备的 Javascript"></a>React 必备的 Javascript</h2><p>虽然你可以同时学习Javascript和React，但是熟悉Javascript可以使你学习React的过程更简单。</p>
<p>在下一部分中，会从Javascript的角度为你介绍一些React的核心概念，这是将会提到的Javascript主题的概要。</p>
<ul>
<li>Functions and Arrow Functions</li>
<li>Objects</li>
<li>Arrays and Array methods</li>
<li>Destructuring（解构赋值）</li>
<li>Template Literals（字面量）（模板字符串）</li>
<li>Ternary Operators（三元操作符）</li>
<li>ES Modules and Import/Export Syntax</li>
</ul>
<p>虽然这个课程不会深入Javascript，使用最新的版本去联系Javascript是一种好的做法，但是如果你感觉还不精通Javascript，这不妨碍你开始使用React。</p>
<blockquote>
<p>stay up to date（与时俱进）<br>proficient adj 精通的、熟练的<br>hinder v 阻碍 </p>
</blockquote>
<h2 id="React-核心概念"><a href="#React-核心概念" class="headerlink" title="React 核心概念"></a>React 核心概念</h2><p>开始使用React你有三个核心概念需要熟悉，分别是：</p>
<ul>
<li>Components</li>
<li>Props</li>
<li>State</li>
</ul>
<p>在下一个部分，我们将会继续学习上面的概念，并且提供继续学习的资源。</p>
<h2 id="使用-Component-构建-UI"><a href="#使用-Component-构建-UI" class="headerlink" title="使用 Component 构建 UI"></a>使用 Component 构建 UI</h2><p>UI能被分解到称为Component的更小的构建块。</p>
<p>Components允许你创建自包含的、可重复使用的代码片段，如果你把component看作乐高砖块，你可以把这些独立的砖块组合成更大的结构。如果你需要去更新一部分UI，你可以更新特定的容器或砖块。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250935877.png" alt="image.png"></p>
<p>模块化使你的代码增长时的可维护性更好，因为你可以简单的添加、更新和删除component在没有改变应用的其他部分代码的情况下。</p>
<p>React Component很棒的一件事是它们只是Javascript，让我们看看从Javascript的角度如何编写React Component。</p>
<h3 id="创建Component"><a href="#创建Component" class="headerlink" title="创建Component"></a>创建Component</h3><p>在React中，component是函数。在你的<code>script</code>tag内部，写一个叫做<code>header</code>的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>一个component是一个返回UI元素的方法，在函数的返回声明中你可以编写JSX。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  ReactDOM.render(, app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>为了把component渲染成DOM，你可以把它当作第一个参数传递到<code>ReactDOM.render()</code>方法中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ReactDOM.render(header, app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>等一等，如果你尝试在浏览器中运行上面的代码，你会得到一个错误，为了使他工作，这里两件事情必须要做。</p>
<p>首先，React component应该是首字母大写的以区别于原生HTML和Javascript。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capitalize the React Component</span></span><br><span class="line">ReactDOM.render(Header, app);</span><br></pre></td></tr></table></figure>

<p>第二，你使用React component的方式应该和使用常规HTML标签一样，使用角括号<code>&lt;&gt;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<h3 id="嵌套组件"><a href="#嵌套组件" class="headerlink" title="嵌套组件"></a>嵌套组件</h3><p>应用往往有更多的内容而不止一个单独的组件，你可以嵌套使用每一个React components就像使用常规HTML标签一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<p>然后再<code>&lt;HomePage&gt;</code>中嵌套使用<code>&lt;Header&gt;</code>component。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* Nesting the Header component */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<h3 id="组件树"><a href="#组件树" class="headerlink" title="组件树"></a>组件树</h3><p>你可以通过这种方式继续嵌套component，形成组件树。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250935566.png" alt="image.png"></p>
<p>例如，您的顶级主页组件可以包含一个Header、一个Article和一个Footer组件。每个组件都可以有自己的子组件，以此类推。例如，Header组件可以包含徽标、标题和导航组件。</p>
<p>模块化的格式允许你在应用的内部的不同地方复用组件。</p>
<p>在你的项目中，因为&lt;首页&gt;现在是你的顶层组件，你可以把它传递给ReactDOM.render()方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<p>在下一部分中，我们会讨论<code>props</code>并且使用它们去在你的component中传递数据。</p>
<blockquote>
<p>break down 分解、细化<br>modularity n 模块化<br>modular adj 模块化的<br>statement n 语句、声明<br>argument n 参数<br>capitalize v 大写<br>distinguish v 区别<br>bracket n 括号、支架<br>nesting component 嵌套组件<br>and so no 以此类推、等等<br>in turn 依次、轮流<br>since conj 因为</p>
</blockquote>
<h2 id="使用-Props-展示数据"><a href="#使用-Props-展示数据" class="headerlink" title="使用 Props 展示数据"></a>使用 Props 展示数据</h2><blockquote>
<p>so far 到目前为止<br>what if 如果…会…<br>ahead of time 提前、事先<br>explictly adv 显式的<br>denote v 表示</p>
</blockquote>
<p>到目前为止，如果你复用<code>&lt;Header/&gt;</code>组件，它将会两次显示相同的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果你想传递不同的数据或者你提前不知道信息，因为你是从一个外部的数据源获取数据。</p>
<p>常规的HTML元素存在能让你传递一段改变元素行为的信息的属性。例如，改变<code>img</code>元素的<code>src</code>属性去改变显示的图片，改变<code>a</code>标签的<code>href</code>属性去改变链接的目的地址。</p>
<p>通过相同的方式，你可以传递一段信息作为属性给React组件，这叫做<code>Props</code></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250936588.png" alt="image.png"></p>
<p>类似于JavaScript函数，你可以设计组件去接受自定义的参数去改变组件的行为或者是在渲染到屏幕上的时候什么是可视的。你可以往下传递这些属性从父组件到子组件。</p>
<blockquote>
<p>[!note]+<br>在React中，数据沿着组件树往下流，这被称作单向数据流状态，将会在下一部分讨论这个，可以作为props从父组件传递到子组件。</p>
</blockquote>
<h2 id="使用-Props"><a href="#使用-Props" class="headerlink" title="使用 Props"></a>使用 Props</h2><p>在你的<code>HomePage</code>组件，你可以传递一个自定义的<code>title</code>到<code>Header</code>组件，就像你传递HTML属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function Header() &#123;</span></span><br><span class="line"><span class="comment">//   return &lt;h1&gt;Develop. Preview. Ship. 🚀&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;React 💙&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>然后<code>Header</code>组件可以接受这些props作为它的第一个函数参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="comment">//   return &lt;h1&gt;Develop. Preview. Ship. 🚀&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>如果你<code>console.log()</code>props，它是一个有着<code>title</code>属性的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props) <span class="comment">// &#123; title: &quot;React 💙&quot; &#125;</span></span><br><span class="line"><span class="comment">//   return &lt;h1&gt;React 💙&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>因为props是一个对象，你可以使用<code>object destrcuturing</code>显式地命名函数参数中的props值:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(title) <span class="comment">// &quot;React 💙&quot;</span></span><br><span class="line"><span class="comment">//  return &lt;h1&gt;React 💙&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>然后你可以使用你的<code>title</code>变量去取代你<code>h1</code>标签中的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(title);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你打开你的项目在浏览器中，你将会看到它显示的实际的单词是<code>title</code>，这是因为React认为你趋向于渲染一个纯文本字符串到DOM。</p>
<h2 id="在-JSX-中使用变量"><a href="#在-JSX-中使用变量" class="headerlink" title="在 JSX 中使用变量"></a>在 JSX 中使用变量</h2><blockquote>
<p>[!note]+<br>curly adj 卷曲的 n 卷毛<br>brace n 括号 支架 v 撑住<br>directly adv 直接地<br>markup n 标记、涨价、利润<br>evaluate v 计算、估算、评估<br>notation n 符号、记号、注释<br>account v 解释、把…视作，说明<br>generic adj 一般的、通用的<br>iterate v 迭代<br>iterating through lists 遍历数组<br>identical adj 完全一样的<br>identify v 识别、认出、确认<br>unopinionated adj 不受限制的、无强烈观点的、不固执己见的<br>weave v 编织、迂回<br>guaranteed adj 肯定的、保障的、有担保的</p>
</blockquote>
<p>为了使用你定义的变量，你可以使用花括号<code>&#123;&#125;</code>，一种特殊的JSX语法，允许你在JSX标记中直接编写常规的js。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function Header(&#123;title&#125;) &#123;</span></span><br><span class="line"><span class="comment">//  console.log(title)</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>当你在“JSX领域”时，你可以把花括号看作是进入“JavaScript领域”的一种方式。可以在花括号内添加任何JavaScript表达式(计算结果为单个值的表达式)。例如:</p>
<ol>
<li>一个带有点符号的对象属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>模板字符串</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Cool $&#123;title&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数返回值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTitle</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (title) &#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Default title&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;createTitle(title)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>三元操作符</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default Title&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你现在给以传递任何字符串给你的<code>title</code>属性，因为你已经用三元操作符解释了组件中的默认情况，你甚至可以根本不传递title prop:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default title&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您的组件现在接受一个通用的<code>title</code>属性，您可以在应用程序的不同部分重用它。你所需要做的就是改变标题:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;React 💙&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;A new title&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>通常需要将数据显示为列表。您可以使用数组方法来操作数据并生成样式相同但包含不同信息的UI元素。</p>
<blockquote>
<p>[!note]+<br>当涉及到数据获取时，React是不受限制的，这意味着你可以选择最适合你需要的解决方案。稍后，我们将讨论Next.js中的数据获取选项。但是现在，您可以使用一个简单的数组来表示数据</p>
</blockquote>
<p>在你的<code>HomePage</code>组件中添加一个名字数组:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以使用<code>array.map()</code>方法迭代数组，并使用箭头函数将名称映射到列表项:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark style="background: #FF5582A6;">请注意，您是如何使用花括号在“JavaScript”和“JSX”之间来回穿梭的。</mark></p>
<p>如果你运行这段代码，React会给我们一个关于丢失的key prop的警告。这是因为React需要一些东西来唯一地标识数组中的项，以便它知道要更新DOM中的哪些元素。</p>
<p>您现在可以使用名称，因为它们目前是唯一的，但建议使用保证唯一的东西，例如项目ID。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-State-添加交互性"><a href="#使用-State-添加交互性" class="headerlink" title="使用 State 添加交互性"></a>使用 State 添加交互性</h2><p>让我们探索React怎么使用State和event handlers帮我们添加交互性。</p>
<p>举个例子，让我们创建一个<code>like</code>按钮在你的<code>HomePage</code>组件内部，首先在<code>return</code>语句里面添加一个<code>button</code>元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>为了使按钮在点击的时候能干一些事情，你可以使用点击事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;&#125;</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在React中，事件名是驼峰大小写的。<code>onClick</code>事件是可用于响应用户交互的许多可能事件之一。例如，您可以对输入字段使用<code>onChange</code>或对表单使用<code>onSubmit</code>。</p>
<h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><p>你可以定义一个函数去处理事件不管它们什么时候被触发，创建一个函数在return语句之前调用<code>handleClick()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;increment like count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;&#125;</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以调用<code>handleClick</code>函数当<code>onclick</code>事件被触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//    ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;increment like count&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="State-和-hooks"><a href="#State-和-hooks" class="headerlink" title="State 和 hooks"></a>State 和 hooks</h2><p>React有一组叫做hooks的函数。钩子允许您向组件添加额外的逻辑，例如状态。您可以将状态视为UI中随时间变化的信息，通常由用户交互触发。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250936495.png" alt="image.png"></p>
<p>您可以使用state来存储和增加用户单击like按钮的次数。实际上，<code>useState()</code>就是用于管理状态的React钩子的名称:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function HomePage() &#123;</span><br><span class="line">  React.useState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的第一项是状态值，您可以将其命名为任何值。建议给它起一个描述性的名字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [likes] = React.useState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的第二项是更新值的函数。你可以给更新函数取任何名字，但通常在它的前面加上set，后面跟着你要更新的状态变量的名字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = React.useState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以借此机会添加<code>like</code>状态的初始值:<code>0</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，您可以使用组件内部的状态变量来检查初始状态是否正常工作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like(&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，你可以在<code>HomePage</code>组件中调用状态更新函数<code>setLikes</code>，让我们把它添加到你之前定义的<code>handleClick()</code>函数中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setLikes(likes + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Likes (&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单击按钮现在将调用<code>handleClick</code>函数，该函数调用<code>setLikes</code>状态更新函数，参数为当前<code>like+ 1</code>。</p>
<blockquote>
<p>[!note]+<br>与props作为第一个函数参数传递给组件不同，状态是在组件中初始化和存储的。您可以将状态信息作为道具传递给子组件，但是更新状态的逻辑应该保留在最初创建状态的组件中。</p>
</blockquote>
<h2 id="怎么继续学习-React"><a href="#怎么继续学习-React" class="headerlink" title="怎么继续学习 React"></a>怎么继续学习 React</h2><p>你刚被介绍了三个基础的概念：components, props, state。在这些方面打下坚实的基础将有助于您开始构建React应用程序。一旦你感觉更自信了，也可以看看其他React主题:</p>
<blockquote>
<p>React怎么处理renders和怎么使用refs<br>怎么去管理state<br>怎么使用context对于深度嵌套的数据<br>怎么使用React API hooks，比如<code>useEffect()</code></p>
</blockquote>
<h2 id="React-资源"><a href="#React-资源" class="headerlink" title="React 资源"></a>React 资源</h2><p>多年来，已经创建了许多课程、视频和文章来帮助开发人员学习React。虽然很难推荐适合你学习风格的资源，但<a href="https://beta.reactjs.org/learn">React文档</a>是一个非常宝贵的参考，它包含交互式沙盒来帮助你练习这些主题。</p>
<p>说到学习React，<span style="background:#ff4d4f">最好的学习方式就是构建</span>。你可以通过使用<code>&lt;script&gt;</code>和你所学到的东西逐渐采用React，为现有的网站添加小组件。然而，许多开发人员已经发现，React提供的用户和开发人员体验足够有价值，可以直接使用React编写整个前端项目。</p>
<h2 id="从-React-到-Next-js"><a href="#从-React-到-Next-js" class="headerlink" title="从 React 到 Next.js"></a>从 React 到 Next.js</h2><p>虽然React擅长构建UI，但要独立地将UI构建成一个功能齐全的可扩展应用程序确实需要一些工作。好消息是，Next.js处理了大部分的设置和配置，并提供了额外的功能来帮助您构建React应用程序。</p>
<p>接下来，我们将把这个例子从React迁移到Next.js，讨论Next.js是如何工作的，并介绍一些web开发概念来帮助你学习更高级的Next.js功能。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>3. 从 React 到 Next.js</title>
    <url>/2023/07/13/React/NextJS/3.%20%E4%BB%8E%20React%20%E5%88%B0%20Next.js/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在上一课中，我们讨论了如何开始使用React。这是最终代码的样子。如果从这里开始，请将此代码粘贴到代码编辑器中的index.html文件中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &quot;Default title&quot;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> names = [<span class="string">&quot;Ada Lovelace&quot;</span>, <span class="string">&quot;Grace Hopper&quot;</span>, <span class="string">&quot;Margaret Hamilton&quot;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          setLikes(likes + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> (</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">              &#123;names.map((name) =&gt; (</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">              ))&#125;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like (&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        )</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span>, app)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>现在，让我们看看如何从一个简单的React应用转移到Next.js。</p>
<h2 id="入门-Next-js"><a href="#入门-Next-js" class="headerlink" title="入门 Next.js"></a>入门 Next.js</h2><p>要将Next.js添加到项目中，您将不再需要从unpkg.com加载react和react-dom脚本。相反，你可以使用Node Package Manager: npm在本地安装这些包。</p>
<blockquote>
<p>[!note]+<br>你需要在你的机器上安装Node.js(<a href="https://nextjs.org/docs/upgrading#minimum-nodejs-version">最低版本要求</a>)，你可以在<a href="https://nodejs.org/en/">这里</a>下载它。</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在你的终端中，运行<code>npm install react react-dom next</code>。安装完成后，您应该能够看到包中列出的项目依赖项<code>package.json</code>文件:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;next&quot;</span>: <span class="string">&quot;^12.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还会注意到一个名为<code>node_modules</code>的新文件夹，其中包含了我们的依赖项的实际文件。<br>回到<code>index.html</code>文件，你可以删除以下代码:</p>
<ol>
<li><code>react</code>和<code>react-dom</code>脚本，因为你已经用NPM安装了它们。</li>
<li><code>&lt;html&gt;</code>和<code>&lt;body&gt;</code>标签，因为Next.js将为您创建这些标签。</li>
<li>与<code>app</code>元素和<code>ReactDom.render()</code>方法交互的代码。</li>
<li>Babel脚本，因为Next.js有一个编译器，可以将JSX转换为有效的浏览器可以理解的JavaScript。</li>
<li> <code>&lt;script type=&quot;text/jsx&quot;&gt;</code> 标签。</li>
<li> <code>React.useState(0)</code> 方法的 <code>React.</code>部分</li>
</ol>
<p>HTML文件中剩下的代码叫<code>JSX</code>，所以你可以把文件类型从<code>.html</code>改到<code>.js</code>或者<code>.jsx</code>。</p>
<p>要完全转移到一个Next.js应用这里有三件事情你需要去做。</p>
<ol>
<li>移动<code>index.js</code>文件去一个新的叫做<code>pages</code>文件夹。</li>
<li>给你的主组件添加一个默认的导出去帮助Next.js区分哪个组件应该作为这个页面的主组件去渲染。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//  ...</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加一个<code>scripts</code>到你的<code>package.json</code>文件去运行Next.js的开发服务器当你开发的时候。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;next dev&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">   <span class="comment">// &quot;dependencies&quot;: &#123;</span></span><br><span class="line">   <span class="comment">//   &quot;next&quot;: &quot;^11.1.0&quot;,</span></span><br><span class="line">   <span class="comment">//   &quot;react&quot;: &quot;^17.0.2&quot;,</span></span><br><span class="line">   <span class="comment">//   &quot;react-dom&quot;: &quot;^17.0.2&quot;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行开发服务器"><a href="#运行开发服务器" class="headerlink" title="运行开发服务器"></a>运行开发服务器</h2><p>为了确认一切正常，你可以在终端中运行<code>npm run dev</code>，并在浏览器中导航到localhost:3000来查看你的应用。然后，对代码做一个小的修改并保存。</p>
<p>保存文件后，您应该注意到浏览器会自动更新以反映更改。</p>
<p>这个特性被称为<code>Fast Refresh</code>，它能够在你进行任何编辑的时候，都给予你实时的反馈，并且这个功能是Next.js默认就配置好的。</p>
<p>回顾一下，你的代码从</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &quot;Default title&quot;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> names = [<span class="string">&quot;Ada Lovelace&quot;</span>, <span class="string">&quot;Grace Hopper&quot;</span>, <span class="string">&quot;Margaret Hamilton&quot;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> [likes, setLikes] = React.useState(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          setLikes(likes + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> (</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">              &#123;names.map((name) =&gt; (</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">              ))&#125;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like (&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        )</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span>, app)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default title&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HomePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line">  <span class="keyword">const</span> [likes, setLikes] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setLikes(likes + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Like (&#123;likes&#125;)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从表面上看，这只是代码行数的一小部分减少，但它确实有助于突出一些东西:React是一个库，为构建现代交互式UI提供了必要的原语。但是将创建的UI合并到应用程序中仍然需要做一些工作。</p>
<p>查看迁移过程，您可能已经感受到使用Next.js的好处。您删除了babel脚本，体验了不再需要考虑的复杂工具配置。你还看到了快速刷新功能，这只是Next.js众多开发者体验功能之一。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>祝贺您创建了第一个Next.js应用。</p>
<p>总而言之，您探索了React和Next.js的基础知识，并从简单的React应用程序迁移到Next.js应用程序。</p>
<p>现在可以选择next .js旅程的下一步了。您可以:</p>
<ol>
<li>通过创建您的第一个应用程序来学习如何使用Next.js -本课程将向您介绍Next.js的主要功能，并通过构建更复杂的项目让您练习。</li>
<li>通过继续本课程，深入了解Next.js的工作原理。</li>
</ol>
<p>在下一课中，我们将通过介绍一些相关的web开发概念来探索next .js是如何工作的。熟悉这些概念将有助于扩展您的基础，并使学习更高级的Next.js特性变得更容易。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>4. Next.js怎么工作</title>
    <url>/2023/07/16/React/NextJS/4.%20Next.js%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学习更高级的Next.js特性之前，了解Next.js的基本工作原理会有所帮助。</p>
<p>在本课程开始时，我们讨论了React如何相对不受您如何构建和构建应用程序的影响-有多种方法可以使用React构建应用程序。js提供了一个框架来构建您的应用程序，以及有助于加快开发过程和最终应用程序的优化。</p>
<p>在接下来的部分中，我们将看看在这些不同的阶段中应用程序代码发生了什么:</p>
<ul>
<li>代码运行的环境:<strong>开发</strong>与<strong>生产</strong></li>
<li>代码何时运行:<strong>构建时</strong>与<strong>运行时</strong></li>
<li>渲染发生在哪里:<strong>客户机</strong>还是<strong>服务器</strong></li>
</ul>
<p>现在让我们更深入地了解这些概念，并讨论Next.js在幕后执行的一些过程。</p>
<h2 id="开发和生产环境"><a href="#开发和生产环境" class="headerlink" title="开发和生产环境"></a>开发和生产环境</h2><p>你可以把环境当成代码运行的上下文。</p>
<p>在开发过程中，你在本地机器上构建和运行你的应用程序，进入生产环境是使应用程序准备好被用户部署和使用的过程。</p>
<h2 id="怎么应用到-Next-js-？"><a href="#怎么应用到-Next-js-？" class="headerlink" title="怎么应用到 Next.js ？"></a>怎么应用到 Next.js ？</h2><p>js为应用程序的开发和生产阶段提供了特性。例如:</p>
<ul>
<li>在开发阶段，Next.js针对开发人员及其构建应用程序的经验进行了优化。它附带了一些旨在改善开发者体验的特性，比如TypeScript和ESLint的集成、快速刷新等等。</li>
<li>在生产阶段，Next.js针对最终用户及其使用应用程序的体验进行了优化。它的目标是转换代码，使其具有高性能和可访问性。</li>
</ul>
<p>由于每个环境都有不同的考虑因素和目标，因此将应用程序从开发转移到生产需要做很多工作。需要编译应用程序代码，捆绑代码，缩小代码，以及拆分代码。</p>
<h2 id="Next-js-编译器"><a href="#Next-js-编译器" class="headerlink" title="Next.js 编译器"></a>Next.js 编译器</h2><p>js处理这些代码转换和底层基础设施，使您的应用程序更容易进入生产环境。</p>
<p>这之所以可能是因为Next.js有一个用Rust(一种底层编程语言)和SWC(一种可用于编译、最小化、绑定等的平台)编写的编译器。</p>
<h2 id="什么是-Compiling-？"><a href="#什么是-Compiling-？" class="headerlink" title="什么是 Compiling ？"></a>什么是 Compiling ？</h2><p>开发人员使用对开发人员更友好的语言(如JSX、TypeScript和现代版本的JavaScript)编写代码。虽然这些语言提高了开发人员的效率和信心，但在浏览器能够理解它们之前，它们需要被编译成JavaScript。</p>
<p>编译是指用一种语言获取代码，然后用另一种语言或该语言的另一种版本输出代码的过程。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250937850.png" alt="image.png"></p>
<p>在Next.js中，编译是在开发阶段编辑代码时进行的，并且是构建步骤的一部分，以便为应用程序的生产做好准备。</p>
<h2 id="什么是-Minifying-？"><a href="#什么是-Minifying-？" class="headerlink" title="什么是 Minifying ？"></a>什么是 Minifying ？</h2><p>开发人员编写的代码是针对可读性进行优化过的，此代码可能包含代码运行不需要的额外信息，例如注释、空格、缩进和多行。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250937964.png" alt="image.png"></p>
<p>最小化是在不改变代码功能的情况下删除不必要的代码格式和注释的过程。目标是通过减小文件大小来提高应用程序的性能。</p>
<p>在Next.js中，JavaScript和CSS文件会在生产环境中自动缩小。</p>
<h2 id="什么是-Bundling"><a href="#什么是-Bundling" class="headerlink" title="什么是 Bundling ?"></a>什么是 Bundling ?</h2><p>开发人员将应用程序分解为模块、组件和功能，这些模块、组件和功能可用于构建应用程序的更大部分。导出和导入这些内部模块以及外部第三方包会创建一个复杂的文件依赖关系网络。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250937437.png" alt="image.png"></p>
<p>捆绑是解决网络依赖并合并(或“打包”)文件(或模块)为浏览器优化的捆绑包的过程，目标是减少用户访问网页时对文件的请求数量。</p>
<h2 id="什么是-Code-Splitting-？"><a href="#什么是-Code-Splitting-？" class="headerlink" title="什么是 Code Splitting ？"></a>什么是 Code Splitting ？</h2><p>开发人员通常将他们的应用程序分成多个页面，这些页面可以从不同的url访问。这些页面中的每个都成为进入应用程序的唯一入口点。</p>
<p>代码拆分是将应用程序包拆分为每个入口点所需的更小块的过程。目标是通过只加载运行该页面所需的代码来改善应用程序的初始加载时间。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250938946.png" alt="image.png"></p>
<p>js内置了对代码分割的支持。在构建步骤中，<code>pages/</code>目录中的每个文件都将被自动代码拆分为自己的JavaScript包。</p>
<p>深入：</p>
<ul>
<li>页面之间共享的任何代码也被拆分到另一个bundle中，以避免在进一步导航时重新下载相同的代码。</li>
<li>在初始页面加载之后，Next.js可以开始预加载用户可能浏览到的其他页面的代码。</li>
<li>动态导入是手动分割初始加载代码的另一种方法。</li>
</ul>
<h2 id="构建时和运行时"><a href="#构建时和运行时" class="headerlink" title="构建时和运行时"></a>构建时和运行时</h2><p>构建时(或构建步骤)是为生产准备应用程序代码的一系列步骤的名称。</p>
<p>在构建应用程序时，Next.js将把代码转换为生产优化的文件，准备部署到服务器并供用户使用。这些文件包括:</p>
<ul>
<li>用于静态生成页面的HTML文件</li>
<li>在服务器上呈现页面的JavaScript代码</li>
<li>用于在客户端上实现页面交互的JavaScript代码</li>
<li>CSS文件</li>
</ul>
<p>运行时(或请求时间)是指在构建和部署应用程序之后，应用程序响应用户请求而运行的时间段。</p>
<h2 id="客户端和服务端"><a href="#客户端和服务端" class="headerlink" title="客户端和服务端"></a>客户端和服务端</h2><p>在web应用程序的上下文中，客户端指的是用户设备上的浏览器，它向服务器发送应用程序代码的请求。然后，它将从服务器接收到的响应转换为用户可以与之交互的界面。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250938882.png" alt="image.png"></p>
<p>服务器是指数据中心中的计算机，它存储应用程序代码，接收来自客户机的请求，进行一些计算，并发回适当的响应。</p>
<h2 id="什么是渲染？"><a href="#什么是渲染？" class="headerlink" title="什么是渲染？"></a>什么是渲染？</h2><p>将用React编写的代码转换成UI的HTML表示是不可避免的工作单元。这个过程称为渲染。</p>
<p>呈现可以在服务器或客户机上进行。它可以在构建时提前发生，也可以在运行时的每个请求中发生。</p>
<p>使用Next.js，有三种类型的呈现方法可用:服务器端呈现、静态站点生成和客户端呈现。</p>
<h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>服务器端渲染和静态站点生成也被称为预渲染，因为获取外部数据和将React组件转换为HTML发生在结果发送到客户端之前。</p>
<h3 id="客户端渲染与预渲染"><a href="#客户端渲染与预渲染" class="headerlink" title="客户端渲染与预渲染"></a>客户端渲染与预渲染</h3><p>在标准的React应用程序中，浏览器从服务器接收一个空的HTML 外壳以及构造UI的JavaScript指令。这被称为客户端呈现，因为初始呈现工作发生在用户的设备上。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250938511.png" alt="image.png"></p>
<blockquote>
<p>[!note]+<br>你可以选择在Next.js应用中为特定组件使用客户端渲染，方法是使用React的useEffect()或数据获取钩子(如useSWR)来获取数据。</p>
</blockquote>
<p>相比之下，Next.js默认情况下预呈现每个页面。预渲染意味着HTML是提前在服务器上生成的，而不是在用户的设备上用JavaScript完成。</p>
<p>在实践中，这意味着对于一个完全客户端渲染的应用程序，当渲染工作完成时，用户将看到一个空白页面。与预渲染的应用程序相比，用户将看到构建好的HTML:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250938630.png" alt="image.png"></p>
<p>让我们讨论两种类型的预渲染:</p>
<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>通过服务器端呈现，为每个请求在服务器上生成页面的HTML。然后将生成的HTML、JSON数据和JavaScript指令发送到客户机，以使页面具有交互性。</p>
<p>在客户端，HTML用于显示快速的非交互式页面，而React使用JSON数据和JavaScript指令使组件具有交互性(例如，将事件处理程序附加到按钮上)。这个过程叫做水合作用。</p>
<p>在Next.js中，你可以通过使用<code>getServerSideProps</code>来选择服务器端渲染页面。</p>
<blockquote>
<p>[!note]+<br>React 18和Next 12引入了React服务器组件的alpha版本。服务器组件完全在服务器上呈现，不需要客户端JavaScript来呈现。此外，服务器组件允许开发人员在服务器上保留一些逻辑，并且只将该逻辑的结果发送给客户端。这减少了发送到客户端的包大小，并提高了客户端呈现性能。在这里了解有关React服务器组件的更多信息。</p>
</blockquote>
<h3 id="静态站点生成"><a href="#静态站点生成" class="headerlink" title="静态站点生成"></a>静态站点生成</h3><p>使用静态站点生成，HTML是在服务器上生成的，但与服务器端呈现不同的是，在运行时没有服务器。相反，内容只在构建时部署应用程序时生成一次，HTML存储在CDN中，并为每个请求重用。</p>
<p>在Next.js中，您可以选择使用<code>getStaticProps</code>静态生成页面。</p>
<blockquote>
<p>[!note]+<br>您可以在构建站点后使用增量静态再生成来创建或更新静态页面。这意味着如果数据发生变化，您不必重新构建整个站点。</p>
</blockquote>
<p>js的美妙之处在于，您可以为每个页面的用例选择最合适的呈现方法，无论是静态站点生成、服务器端呈现还是客户端呈现。要了解更多关于哪种呈现方法适合您的特定用例的信息，请参阅<a href="https://nextjs.org/docs/basic-features/data-fetching/overview">数据获取文档</a>。</p>
<h2 id="CDNs-和-Edge"><a href="#CDNs-和-Edge" class="headerlink" title="CDNs 和 Edge"></a>CDNs 和 Edge</h2><h3 id="什么是网络？"><a href="#什么是网络？" class="headerlink" title="什么是网络？"></a>什么是网络？</h3><p>了解应用程序代码的存储位置和部署到网络后的运行位置是很有帮助的。您可以将网络想象成能够共享资源的连接计算机(或服务器)。在Next.js应用程序的情况下，您的应用程序代码可以分发到<code>origin severs、内容交付网络(cdn)和Edge</code>。让我们看看它们分别是什么:</p>
<h4 id="Origin-Servers"><a href="#Origin-Servers" class="headerlink" title="Origin Servers"></a>Origin Servers</h4><p>正如我们前面所讨论的，服务器是指存储和运行应用程序代码原始版本的主计算机。</p>
<p>我们使用<code>origin</code>这个术语是为了将这个服务器与应用程序代码可以分发到的其他地方(比如CDN服务器和Edge服务器)区分开来。</p>
<p>当原始服务器接收到请求时，它在发送响应之前进行一些计算。计算工作的结果可以转移到CDN(内容分发网络)。</p>
<h4 id="Content-Delivery-Network"><a href="#Content-Delivery-Network" class="headerlink" title="Content Delivery Network"></a>Content Delivery Network</h4><p><code>CDN</code>将静态内容(如HTML和图像文件)存储在世界各地的多个位置，并放置在客户机和原始服务器之间。当新请求进入时，距离用户最近的<code>CDN</code>位置可以使用缓存的结果进行响应。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250939414.png" alt="image.png"></p>
<p>这减少了<code>origin</code>上的负载，因为计算不必发生在每个请求上。这也使用户更快，因为响应来自地理上更接近他们的位置。</p>
<p>在Next.js中，由于预渲染可以提前完成，cdn非常适合存储工作的静态结果-使内容交付更快。</p>
<h4 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h4><p>Edge是网络边缘(或边缘)的一个广义概念，最接近用户。cdn可以被认为是“边缘”的一部分，因为它们将静态内容存储在网络的边缘。</p>
<p>与cdn类似，边缘服务器分布在世界各地的多个位置。但与存储静态内容的cdn不同，一些Edge服务器可以运行一小段代码。</p>
<p>这意味着缓存和代码执行都可以在离用户更近的Edge上完成。</p>
<p>通过将一些传统上在客户端或服务器端完成的工作转移到Edge，您可以使应用程序性能更高，因为它减少了发送到客户端的代码量，并且部分用户请求不必一直返回到原始服务器，从而减少了延迟。在这里查看<a href="https://vercel.com/features/edge-functions#:~:text=Unlock%20the%20potential%20of%20edge%20computing">Next.js的Edge示例</a>。</p>
<p>在Next.js中，你可以使用中间件在Edge上运行代码，很快就可以使用React Server组件了。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>祝贺你完成了Next.js基础课程!</p>
<p>为了继续学习Next.js，我们建议您使用我们的教程创建您的<a href="https://nextjs.org/learn/basics/create-nextjs-app?utm_source=next-site&utm_medium=homepage-cta&utm_campaign=next-website">第一个Next.js应用程序</a>，该教程将向您介绍主要功能。</p>
<p>您还可以查看我们的<a href="https://nextjs.org/docs">文档</a>并探索我们广泛的<a href="https://nextjs.org/examples">示例列表</a>。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>6. 页面间导航</title>
    <url>/2023/07/18/React/NextJS/6.%20%E9%A1%B5%E9%9D%A2%E9%97%B4%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>到目前为止，我们创建的Next.js应用程序只有一个页面。网站和web应用程序通常有许多不同的页面。</p>
<p>让我们探索一下如何向应用程序添加更多页面。</p>
<h2 id="我们将在课程里面学到什么"><a href="#我们将在课程里面学到什么" class="headerlink" title="我们将在课程里面学到什么"></a>我们将在课程里面学到什么</h2><p>在这门课中，你将会：</p>
<ul>
<li>使用集成的文件系统路由创建一个新页面</li>
<li>了解如何使用<code>Link</code>组件在页面之间启用客户端导航</li>
<li>了解对代码分割和预取的内置支持</li>
</ul>
<blockquote>
<p>[!note]<br>如果你正在寻找关于Next.js路由的详细文档，请查看<a href="https://nextjs.org/docs/routing/introduction">路由文档</a></p>
</blockquote>
<h2 id="Next-js-中的-Pages"><a href="#Next-js-中的-Pages" class="headerlink" title="Next.js 中的 Pages"></a>Next.js 中的 Pages</h2><p>在Next.js中，页面是从<code>pages</code>目录下的文件导出的React组件。</p>
<p>页面根据其文件名与路由相关联。例如，在开发中:</p>
<ul>
<li><code>pages/index.js</code>与/路由相关联。</li>
<li><code>pages/posts/first-post.js</code>与<code>/posts/first-post</code>路由相关联。</li>
</ul>
<p>我们已经有了<code>pages/index.js</code>文件，所以让我们创建<code>pages/posts/first-post.js</code>来看看它是如何工作的。</p>
<h2 id="创建一个新页面"><a href="#创建一个新页面" class="headerlink" title="创建一个新页面"></a>创建一个新页面</h2><p>在<code>pages</code>下创建posts目录。</p>
<p>在<code>posts</code>目录下创建一个名为<code>first-post.js</code>的文件，内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件可以有任何名称，但必须将其导出为默认导出。</p>
<p>现在，确保开发服务器正在运行并访问<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>。您应该看到以下页面:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250940702.png" alt="image.png"></p>
<p>这就是在Next.js中创建不同页面的方法。</p>
<p>只需在pages目录下创建一个JS文件，该文件的路径就变成了URL路径。</p>
<p>在某种程度上，这类似于使用HTML或PHP文件构建网站。而不是写HTML，你写JSX和使用React组件。</p>
<p>让我们添加一个指向新添加页面的链接，以便我们可以从主页导航到它。</p>
<h2 id="链接组件"><a href="#链接组件" class="headerlink" title="链接组件"></a>链接组件</h2><p>当在网站上的页面之间进行链接时，可以使用<code>&lt;a&gt;</code> HTML标签。</p>
<p>在next .js中，你可以使用链接组件<code>next/link</code>来链接应用程序中的页面。<code>&lt;Link&gt;</code>允许您进行客户端导航，并接受让您更好地控制导航行为的属性。</p>
<h2 id="使用-Link"><a href="#使用-Link" class="headerlink" title="使用 Link"></a>使用 Link</h2><p>首先，打开<code>pages/index.js</code>，从<code>next/link</code>中导入<code>Link</code>组件，在顶部添加这一行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后找到<code>h1</code>标签，看起来像这样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 className=<span class="string">&quot;title&quot;</span>&gt;</span><br><span class="line">  Welcome to &lt;a href=<span class="string">&quot;https://nextjs.org&quot;</span>&gt;Next.js!&lt;/a&gt;</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>把它改成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 className=<span class="string">&quot;title&quot;</span>&gt;</span><br><span class="line">  Read &lt;Link href=<span class="string">&quot;/posts/first-post&quot;</span>&gt;<span class="built_in">this</span> page!&lt;/Link&gt;</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，打开pages/posts/first-post.js并将其内容替换为以下内容:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，Link组件类似于使用<code>&lt;a&gt;</code>标记，但是您使用的不是<code>&lt;a href=&quot;…&quot;&gt;</code>，而是<code>&lt;Link href=&quot;…&quot;&gt;</code>。</p>
<blockquote>
<p>[!note]<br>在<code>Next.js 12.2</code>之前，Link组件需要包装一个<code>&lt;a&gt;</code>标签，但在<code>12.2</code>及以上版本中不需要这样做。</p>
</blockquote>
<p>让我们检查一下它是否有效。现在你应该在每个页面上都有一个链接，允许你来回浏览:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250940555.png" alt="image.png"></p>
<h2 id="客户端导航"><a href="#客户端导航" class="headerlink" title="客户端导航"></a>客户端导航</h2><p><code>Link</code>组件支持在同一个Next.js应用中的两个页面之间进行客户端导航。</p>
<p>客户端导航意味着使用JavaScript进行页面转换，这比浏览器的默认导航要快。</p>
<ul>
<li>使用浏览器的开发者工具将<code>&lt;html&gt;</code>的<code>background</code> CSS属性更改为黄色</li>
<li>点击链接可以在两个页面之间来回切换</li>
<li>您将看到，在页面转换之间，黄色背景仍然存在</li>
</ul>
<p>这表明浏览器没有加载整个页面，客户端导航正在工作</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250941935.png" alt="image.png"></p>
<p>如果您使用的是<code>&lt;a href=&quot;…&quot;&gt;</code>而不是<code>&lt;Link href=&quot;…&quot;&gt;</code>，那么单击链接时背景颜色将被清除，因为浏览器会进行完全刷新。</p>
<h2 id="代码分割和预取"><a href="#代码分割和预取" class="headerlink" title="代码分割和预取"></a>代码分割和预取</h2><p>Next.js会自动进行代码分割，因此每个页面只加载该页所需的内容。这意味着在呈现主页时，最初不会提供其他页面的代码。</p>
<p>这确保了即使你有数百个页面，主页也能快速加载。</p>
<p>只加载所请求页面的代码也意味着页面将被隔离。如果某个页面抛出错误，应用程序的其余部分仍然可以工作。</p>
<p>此外，在Next.js的生产构建中，每当<code>Link</code>组件出现在浏览器的视图中，Next.js都会自动在后台预取链接页面的代码。当您单击链接时，目标页面的代码将已经在后台加载，并且页面转换将几乎是即时的!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js通过代码分割、客户端导航和预取(在生产中)自动优化应用程序，以获得最佳性能。</p>
<p>您可以将路由创建为页面下的文件，并使用内置的Link组件。不需要路由库。</p>
<p>你可以在<code>next/link</code>的<a href="https://nextjs.org/docs/api-reference/next/link">API参考</a>中了解更多关于<code>Link</code>组件的信息，在路由<a href="https://nextjs.org/docs/routing/introduction">文档</a>中了解路由的一般情况。</p>
<blockquote>
<p>[!note]<br>如果你需要链接到Next.js应用程序之外的外部页面，只需使用不带link的<code>&lt;a&gt;</code>标签。</p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>5. 创建你的第一个应用</title>
    <url>/2023/07/18/React/NextJS/5.%20%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要用React从头开始构建一个完整的web应用程序，你需要考虑很多重要的细节:</p>
<ul>
<li>代码必须使用像webpack这样的捆绑器进行捆绑，并使用像Babel这样的编译器进行转换。</li>
<li>您需要进行生产优化，比如代码分割。</li>
<li>您可能希望静态地预渲染一些页面以提高性能和SEO。您可能还希望使用服务器端渲染或客户端渲染。</li>
<li>您可能需要编写一些服务器端代码来将React应用程序连接到数据存储。</li>
</ul>
<p>框架可以解决这些问题。但是这样的框架必须具有适当的抽象级别——否则它将不会非常有用。它还需要拥有出色的“开发者体验”，确保你和你的团队在编写代码时拥有惊人的体验。</p>
<h2 id="Next-js-React-框架"><a href="#Next-js-React-框架" class="headerlink" title="Next.js: React 框架"></a>Next.js: React 框架</h2><p>在Next.js, React框架中。Next.js为上述所有问题提供了解决方案。但更重要的是，它会让你和你的团队在构建React应用程序时获得成功。</p>
<p>js旨在提供一流的开发人员体验和许多内置功能，例如:</p>
<ul>
<li>一个直观的基于页面的路由系统(支持动态路由)</li>
<li>静态生成（SSG）和服务器端渲染（SSR）的预渲染，都支持在每个页面上进行。</li>
<li>为了更快页面加载的自动代码分割</li>
<li>具有优化预取的客户端路由</li>
<li>内置CSS和Sass支持，并支持任何CSS-in- js库</li>
<li>支持快速刷新的开发环境</li>
<li>API路由，用于通过<code>serverless</code>函数构建API端点</li>
<li>完全可扩展的。</li>
</ul>
<p>Next.js被用于成千上万的面向生产的网站和web应用程序，包括许多世界上最大的品牌。</p>
<h2 id="关于教程"><a href="#关于教程" class="headerlink" title="关于教程"></a>关于教程</h2><p>这个免费的互动课程将指导您如何开始使用Next.js。</p>
<p>在本教程中，您将通过创建一个非常简单的博客应用程序来学习Next.js基础知识。以下是最终结果的示例:</p>
<p><a href="https://next-learn-starter.vercel.app/">https://next-learn-starter.vercel.app</a> (source)</p>
<blockquote>
<p>本教程假定具有JavaScript和React的基本知识。如果你从来没有写过React代码，你应该先阅读<a href="https://react.dev/learn/tutorial-tic-tac-toe">官方的React教程</a>。<br>如果您正在寻找文档，请访问<a href="https://nextjs.org/docs/getting-started">Next.js文档</a></p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，让我们确保您的开发环境已经准备好。</p>
<ul>
<li>如果你没有安装Node.js，从<a href="https://nodejs.org/en/">这里</a>安装。需要Node.js 10.13或更高版本。</li>
<li>在本教程中，您将使用自己的文本编辑器和终端应用程序。</li>
</ul>
<blockquote>
<p>如果您使用的是Windows，我们建议您下载Windows版本的Git，并使用它附带的Git Bash，它支持本教程中特定于unix的命令。Linux的Windows子系统(<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL</a>)是另一种选择。</p>
</blockquote>
<h2 id="创建一个-Next-js-应用"><a href="#创建一个-Next-js-应用" class="headerlink" title="创建一个 Next.js 应用"></a>创建一个 Next.js 应用</h2><p>要创建一个Next.js应用，打开你的终端，cd到你想要创建应用的目录，然后运行以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest nextjs-blog --use-npm --example &quot;https://github.com/vercel/next-learn/tree/master/basics/learn-starter&quot;</span><br></pre></td></tr></table></figure>

<p>在底层，它使用了一个名为<code>create-next-app</code>的工具，它会为你引导一个Next.js应用。它通过–<code>example</code>标志使用这个模板。</p>
<p>如果它不能工作，请看看这个页面。</p>
<h2 id="运行开发服务器"><a href="#运行开发服务器" class="headerlink" title="运行开发服务器"></a>运行开发服务器</h2><p>现在有了一个名为nextjs-blog的新目录。让我们深入了解一下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd nextjs-blog</span><br></pre></td></tr></table></figure>

<p>然后，执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>这会在端口3000上启动Next.js应用程序的“开发服务器”(稍后会详细介绍)。<br>让我们检查一下它是否有效。从浏览器打开<code>http://localhost:3000</code>。</p>
<h2 id="欢迎来到-Next-js"><a href="#欢迎来到-Next-js" class="headerlink" title="欢迎来到 Next.js"></a>欢迎来到 Next.js</h2><p>当您访问<a href="http://localhost:3000时，应该会看到这样一个页面。这是一个入门模板页面，展示了一些关于Next.js的有用信息。">http://localhost:3000时，应该会看到这样一个页面。这是一个入门模板页面，展示了一些关于Next.js的有用信息。</a></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250939260.png" alt="image.png"></p>
<blockquote>
<p>[!note]+ 帮助<br>如果你遇到了困难，你可以在GitHub讨论上联系社区。</p>
</blockquote>
<h2 id="编辑页面"><a href="#编辑页面" class="headerlink" title="编辑页面"></a>编辑页面</h2><p>让我们尝试编辑起始页。</p>
<ul>
<li>确保Next.js开发服务器仍在运行。</li>
<li>用文本编辑器打开<code>pages/index.js</code>。</li>
<li>在<code>&lt;h1&gt;</code>标签下找到“Welcome to”的文本，并将其更改为“Learn”。</li>
<li>保存文件</li>
</ul>
<p>一旦你保存了文件，浏览器就会自动用新的文本更新页面:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250939681.png" alt="image.png"></p>
<p>Next.js开发服务器启用了快速刷新功能。当您对文件进行更改时，Next.js几乎立即自动将更改应用到浏览器中。不需要刷新!这将帮助你快速迭代应用。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>8. 预渲染和数据获取</title>
    <url>/2023/07/22/React/NextJS/8.%20%E9%A2%84%E6%B8%B2%E6%9F%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们想创建一个博客(这是<a href="https://next-learn-starter.vercel.app/">期望的结果</a>)，但是到目前为止我们还没有添加任何博客内容。在本课中，我们将学习如何获取外部博客数据到我们的应用程序中。我们将在文件系统中存储博客内容，但如果内容存储在其他地方(例如数据库或<a href="https://en.wikipedia.org/wiki/Headless_content_management_system">Headless CMS</a>)，它将工作。</p>
<h2 id="你将在本课中学到什么"><a href="#你将在本课中学到什么" class="headerlink" title="你将在本课中学到什么"></a>你将在本课中学到什么</h2><p>在这门课中，你将会学到：</p>
<ul>
<li>Next.js的预渲染特性</li>
<li>两种预渲染的形式：静态生成和服务端渲染</li>
<li>有数据的静态生成和没数据的静态生成</li>
<li>怎么使用<code>getStaticProps</code>去导入外部博客的数据到首页</li>
<li>关于<code>getStaticProps</code>的一些有用的信息</li>
</ul>
<h2 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h2><p>在我们讨论数据获取之前，让我们先讨论一个Next.js最重要的数据：预渲染</p>
<p>默认情况下，Next.js会预渲染每个页面。这意味着Next.js提前为每个页面生成HTML，而不是让客户端JavaScript完成所有工作。预渲染可以带来更好的性能和<a href="https://en.wikipedia.org/wiki/Search_engine_optimization">SEO</a>。</p>
<p>每个生成的HTML都与该页所需的最少JavaScript代码相关联。当浏览器加载页面时，它的JavaScript代码运行并使页面完全交互式。(这个过程被称为水合作用)</p>
<p>你可以通过以下步骤检查预渲染是否正在发生:</p>
<ul>
<li>在浏览器中禁用JavaScript。(<a href="https://developer.chrome.com/docs/devtools/javascript/disable/">以下是在Chrome中的做法</a>)。</li>
<li>尝试访问此页面(本教程的<a href="https://next-learn-starter.vercel.app/">最终结果</a>)</li>
</ul>
<p>你应该会看到你的应用是在没有JavaScript的情况下呈现的。这是因为Next.js已经将应用程序预渲染为静态HTML，允许您在不运行JavaScript的情况下查看应用程序UI。</p>
<blockquote>
<p>[!note]<br>您也可以在本地主机上尝试上述步骤，但如果禁用JavaScript，则不会加载CSS。</p>
</blockquote>
<p>如果你的应用程序是一个纯React.js应用程序(没有Next.js)，没有预渲染，所以如果你禁用JavaScript，你将无法看到应用程序。例如:</p>
<blockquote>
<p>在浏览器中启用JavaScript并查看此页面。这是一个用Create React app构建的普通React.js应用程序。<br>现在，禁用JavaScript并再次访问同一页面。<br>你不会再看到应用程序了——相反，它会说“你需要启用JavaScript来运行这个应用程序。”这是因为应用程序没有预先渲染成静态HTML。</p>
</blockquote>
<h2 id="摘要-预渲染-vs-不预渲染"><a href="#摘要-预渲染-vs-不预渲染" class="headerlink" title="摘要: 预渲染 vs 不预渲染"></a>摘要: 预渲染 vs 不预渲染</h2><p>这里有一个快速的图形摘要:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250943273.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250944795.png" alt="image.png"></p>
<p>接下来，让我们讨论一下Next.js中的两种预渲染形式。</p>
<h2 id="预渲染的两种形式"><a href="#预渲染的两种形式" class="headerlink" title="预渲染的两种形式"></a>预渲染的两种形式</h2><p>Next.js有两种形式的预渲染:<code>静态生成和服务器端渲染</code>。不同之处在于它何时为页面生成HTML。</p>
<ul>
<li>静态生成是在构建时生成HTML的预呈现方法。然后在每个请求中重用预呈现的HTML。</li>
<li>服务器端渲染是在每个请求上生成HTML的预渲染方法。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250944022.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250944745.png" alt="image.png"></p>
<blockquote>
<p>在开发模式下(当你运行npm run dev或yarn dev时)，每个请求都会预渲染页面。这也适用于静态生成，使其更容易开发。当进入生产环境时，静态生成将在构建时发生一次，而不是在每个请求上。</p>
</blockquote>
<h2 id="Per-page-Basis"><a href="#Per-page-Basis" class="headerlink" title="Per-page Basis"></a>Per-page Basis</h2><p>重要的是，Next.js允许您选择为每个页面使用哪个预呈现表单。你可以创建一个“混合型”Next.js应用，对大多数页面使用静态生成，对其他页面使用服务器端渲染。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250944158.png" alt="image.png"></p>
<h2 id="什么时候去使用静态生成或者服务端渲染"><a href="#什么时候去使用静态生成或者服务端渲染" class="headerlink" title="什么时候去使用静态生成或者服务端渲染"></a>什么时候去使用静态生成或者服务端渲染</h2><p>我们建议<code>尽可能使用静态生成</code>(带或不带数据)，因为您的页面可以构建一次并由CDN提供服务，这比让服务器在每个请求上呈现页面要快得多。</p>
<p>您可以对许多类型的页面使用静态生成，包括:</p>
<ul>
<li>营销页面</li>
<li>博客文章</li>
<li>电子商务产品目录</li>
<li>帮助和文档</li>
</ul>
<p>你应该问自己:“我能在用户请求之前预渲染这个页面吗?”如果答案是肯定的，那么您应该选择静态生成。</p>
<p>另一方面，如果您不能在用户请求之前预渲染页面，那么静态生成就不是一个好主意。也许您的页面显示频繁更新的数据，并且页面内容在每次请求时都会更改。</p>
<p>在这种情况下，您可以使用服务器端渲染。它会慢一些，但是预渲染的页面总是最新的。或者可以跳过预渲染，使用客户端JavaScript填充频繁更新的数据。</p>
<h2 id="我们会聚焦在静态生成"><a href="#我们会聚焦在静态生成" class="headerlink" title="我们会聚焦在静态生成"></a>我们会聚焦在静态生成</h2><p>在本课中，我们将重点介绍<a href="https://nextjs.org/docs/basic-features/pages#static-generation-recommended">静态生成</a>。在下一页中，我们将讨论带数据和不带数据的静态生成。</p>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>Floor()</title>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/Floor()/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>向下取整</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title>7. &#39;Assets, Metadata和CSS&#39;</title>
    <url>/2023/07/19/React/NextJS/7.%20Assets,%20Metadata%E5%92%8CCSS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们添加的第二个页面目前没有样式。让我们添加一些CSS来设置页面的样式。</p>
<p>js内置了对CSS和Sass的支持。在本课程中，我们将使用CSS。</p>
<p>本课还将讨论Next.js如何处理静态资产，如图像和页面元数据，如<code>&lt;title&gt;</code>标签。</p>
<h2 id="你将在这节课学到什么"><a href="#你将在这节课学到什么" class="headerlink" title="你将在这节课学到什么"></a>你将在这节课学到什么</h2><p>在这节课中，你将学习:</p>
<ul>
<li>如何添加静态文件(图像等)到Next.js。</li>
<li>如何自定义每个页面<code>&lt;head&gt;</code>中的内容。</li>
<li>如何使用CSS模块创建一个可重用的React组件。</li>
<li>如何在<code>pages/_app.js</code>中添加<a href="https://nextjs.org/docs/basic-features/built-in-css-support#adding-a-global-stylesheet">全局CSS</a>。</li>
<li>在Next.js中使用样式的一些有用提示。</li>
</ul>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul>
<li>基本的CSS知识。本课程将介绍如何在Next.js应用程序中添加CSS，但它不会涵盖CSS基础知识。</li>
</ul>
<blockquote>
<p>如果你正在寻找关于Next.js样式的详细文档，请查看<a href="https://nextjs.org/docs/basic-features/built-in-css-support">CSS文档</a>。</p>
</blockquote>
<h2 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h2><p>Next.js可以在顶级<code>public</code>目录下提供静态资产，比如图像。<code>public</code>中的文件可以从应用程序的根目录引用，类似于页面。</p>
<p><code>public</code>目录对于<code>robots.txt</code>、Google Site Verification和任何其他静态资产也很有用。请查看静态文件服务的<a href="https://nextjs.org/docs/basic-features/static-file-serving">文档</a>以了解更多信息。</p>
<h3 id="下载个人资料图片"><a href="#下载个人资料图片" class="headerlink" title="下载个人资料图片"></a>下载个人资料图片</h3><p>首先，让我们找回你的头像。</p>
<ul>
<li>下载<code>.jpg</code>格式的个人资料图片(或使用<a href="https://github.com/vercel/next-learn/blob/master/basics/basics-final/public/images/profile.jpg">此文件</a>)。</li>
<li>在<code>public</code>目录中创建一个<code>images</code>目录。</li>
<li>将图片保存为<code>profile.jpg</code>到<code>public/images</code>目录下。</li>
<li>图像大小可以在<code>400px * 400px</code>左右。</li>
<li>您可以直接在<code>public</code>目录下删除未使用的SVG徽标文件。</li>
</ul>
<h3 id="Unoptimized-Image"><a href="#Unoptimized-Image" class="headerlink" title="Unoptimized Image"></a>Unoptimized Image</h3><p>使用常规HTML，您将添加您的个人资料图片如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/profile.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Your Name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而，这意味着你必须手动处理:</p>
<ul>
<li>确保您的图像在不同的屏幕尺寸上响应</li>
<li>使用第三方工具或库优化您的图像</li>
<li>只当它们进入视口才加载图像</li>
</ul>
<p>相反，Next.js提供了一个现成的<code>Image</code>组件来为您处理这个问题。</p>
<h3 id="图像组件和图像优化"><a href="#图像组件和图像优化" class="headerlink" title="图像组件和图像优化"></a>图像组件和图像优化</h3><p><code>next/image</code>是HTML <code>&lt;img&gt;</code>元素的扩展，为现代Web而进化。</p>
<p>Next.js默认情况下也支持图像优化。这允许在浏览器支持的情况下以现代格式(如<a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types#webp">WebP</a>)调整大小、优化和提供图像。这避免了将大图像传送到具有较小视口的设备上。它还允许Next.js自动采用未来的图像格式，并将它们提供给支持这些格式的浏览器。</p>
<p>自动图像优化工程与任何图像源。即使图像由外部数据源(如CMS)托管，也可以对其进行优化。</p>
<h3 id="使用图像组件"><a href="#使用图像组件" class="headerlink" title="使用图像组件"></a>使用图像组件</h3><p>Next.js不是在构建时优化图像，而是在用户请求时按需优化图像。与静态站点生成器和纯静态解决方案不同，无论是发送10个图像还是1000万个图像，构建时间都不会增加。</p>
<p>默认情况下，图像是延迟加载的。这意味着您的页面速度不会因视窗外的图像而受到影响。图像在滚动到视窗时加载。</p>
<p>图像总是以这样一种方式呈现，以避免<a href="https://web.dev/cls/">Cumulative Layout Shift</a>，这是谷歌将在搜索排名中使用的<a href="https://web.dev/vitals/#core-web-vitals">Core Web Vital</a>。</p>
<p>下面是一个使用<code>next/image</code>来显示个人资料图片的例子。高度和宽度属性应该是所需的渲染大小，具有与源图像相同的宽高比。</p>
<p><strong>Note</strong>:我们将在后面的“Polishing Layout”中使用这个组件，现在还不需要复制它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Image <span class="keyword">from</span> <span class="string">&#x27;next/image&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YourComponent = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">src</span>=<span class="string">&quot;/images/profile.jpg&quot;</span> // <span class="attr">Route</span> <span class="attr">of</span> <span class="attr">the</span> <span class="attr">image</span> <span class="attr">file</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">height</span>=<span class="string">&#123;144&#125;</span> // <span class="attr">Desired</span> <span class="attr">size</span> <span class="attr">with</span> <span class="attr">correct</span> <span class="attr">aspect</span> <span class="attr">ratio</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">width</span>=<span class="string">&#123;144&#125;</span> // <span class="attr">Desired</span> <span class="attr">size</span> <span class="attr">with</span> <span class="attr">correct</span> <span class="attr">aspect</span> <span class="attr">ratio</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">alt</span>=<span class="string">&quot;Your Name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">  /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要了解有关自动图像优化的更多信息，请查看<a href="https://nextjs.org/docs/basic-features/image-optimization">文档</a>。<br>要了解更多关于Image组件的信息，请查看<code>next/image</code>的<a href="https://nextjs.org/docs/api-reference/next/image">API参考</a>。</p>
</blockquote>
<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>如果我们想修改页面的元数据，比如<code>&lt;title&gt;</code> HTML标记，该怎么办?</p>
<p><code>&lt;title&gt;</code>是<code>&lt;head&gt;</code> HTML标记的一部分，因此让我们深入了解如何在Next.js页面中修改<code>&lt;head&gt;</code>标记。</p>
<p>在编辑器中打开<code>pages/index.js</code>，找到以下几行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Head&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Create Next App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/Head&gt;</span><br></pre></td></tr></table></figure>

<p>注意，这里使用了<code>&lt;Head&gt;</code>而不是小写的<code>&lt;head&gt;</code>。<code>&lt;Head&gt;</code>是一个内置于Next.js中的React组件。它允许您修改页面的<code>&lt;head&gt;</code>。</p>
<p>你可以从<code>next/Head</code>模块中导入Head组件。</p>
<h2 id="将-Head-添加到-first-post-js-中"><a href="#将-Head-添加到-first-post-js-中" class="headerlink" title="将 Head 添加到 first-post.js 中"></a>将 Head 添加到 first-post.js 中</h2><p>我们没有在<code>/posts/first-post</code>路由中添加<code>&lt;title&gt;</code>，加一个。</p>
<p>打开<code>pages/posts/first-post.js</code>文件，在文件开头添加<code>next/head</code>的导入:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后，更新导出的<code>FirstPost</code>组件，使其包含Head组件。现在，我们只添加<code>title</code>标签:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>← Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试访问<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>。浏览器选项卡现在应该显示“First Post”。通过使用浏览器的开发人员工具，您应该看到标题标记被添加到<code>&lt;head&gt;</code>。</p>
<blockquote>
<p>要了解有关Head组件的更多信息，请查看<code>next/head</code>的<a href="https://nextjs.org/docs/api-reference/next/head">API参考</a>。<br>如果您想定制<code>&lt;html&gt;</code>标记，例如添加lang属性，可以通过创建<code>pages/_document.js</code>文件来实现。在<a href="https://nextjs.org/docs/advanced-features/custom-document">自定义文档文档</a>中了解更多信息。</p>
</blockquote>
<h2 id="第三方-JavaScript"><a href="#第三方-JavaScript" class="headerlink" title="第三方 JavaScript"></a>第三方 JavaScript</h2><p>第三方JavaScript是指从第三方源添加的任何脚本。通常，包含第三方脚本是为了将不需要从头编写的新功能引入站点，例如分析、广告和客户支持小部件。</p>
<h3 id="添加第三方-JavaScript"><a href="#添加第三方-JavaScript" class="headerlink" title="添加第三方 JavaScript"></a>添加第三方 JavaScript</h3><p>让我们深入了解一下如何将第三方脚本添加到Next.js页面。</p>
<p>在你的编辑器中打开<code>pages/posts/first-post.js</code>，找到以下几行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Head&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;/Head&gt;</span><br></pre></td></tr></table></figure>

<p>除了元数据之外，需要尽快加载和执行的脚本通常被添加到页面的<code>&lt;head&gt;</code>中。使用常规的HTML <code>&lt;script&gt;</code>元素，外部脚本将添加如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Head&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://connect.facebook.net/en_US/sdk.js&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/Head&gt;</span><br></pre></td></tr></table></figure>

<p>该脚本包含<a href="https://developers.facebook.com/docs/javascript/quickstart">Facebook SDK</a>，通常用于引入Facebook社交插件和其他功能。虽然这种方法是有效的，但是以这种方式包含脚本并不能清楚地告诉我们，相对于同一页面上获取的其他JavaScript代码，它将在什么时候加载。如果一个特定的脚本是呈现阻塞的，并且会延迟页面内容的加载，这可能会严重影响性能。</p>
<h3 id="使用-Script-组件"><a href="#使用-Script-组件" class="headerlink" title="使用 Script 组件"></a>使用 Script 组件</h3><p><code>next/script</code>是HTML <code>&lt;script&gt;</code>元素的扩展，并在获取和执行其他脚本时进行优化。</p>
<p>在同一个文件中，在文件的开头添加一个从<code>next/script</code>导入的脚本:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Script <span class="keyword">from</span> <span class="string">&#x27;next/script&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>现在，更新<code>FirstPost</code>组件以包含<code>Script</code>组件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Script</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">src</span>=<span class="string">&quot;https://connect.facebook.net/en_US/sdk.js&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">strategy</span>=<span class="string">&quot;lazyOnload&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onLoad</span>=<span class="string">&#123;()</span> =&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">console</span>.log(<span class="string">`script loaded correctly, window.FB has been populated`</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      /&gt;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>← Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span></span></span><br><span class="line"><span class="xml"><span class="javascript"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>Script</code>组件中已经定义了一些额外的属性:</p>
<ul>
<li><code>strategy</code>控制何时加载第三方脚本。<code>lazyOnload</code>的值告诉Next.js在浏览器空闲时惰性加载这个特定的脚本</li>
<li><code>onLoad</code>用于在脚本完成加载后立即运行任何JavaScript代码。在本例中，我们将一条消息记录到控制台，该消息提到脚本已正确加载</li>
<li>尝试访问<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>。通过使用浏览器的开发人员工具，您应该在控制台面板中看到上面的消息。此外，您可以运行<code>Window.FB</code>查看脚本是否已经填充了这个全局变量。</li>
</ul>
<blockquote>
<p>[!note]<br><code>Facebook SDK</code>仅作为一个人为的示例来展示如何以高性能的方式向应用程序添加第三方脚本。现在您已经了解了在Next.js中包含第三方功能的基础知识，可以在继续之前从<code>FirstPost</code>中删除<code>Script</code>组件。<br>要了解关于Script组件的更多信息，请查看<a href="https://nextjs.org/docs/basic-features/script">文档</a>。</p>
</blockquote>
<h2 id="CSS-样式"><a href="#CSS-样式" class="headerlink" title="CSS 样式"></a>CSS 样式</h2><p>现在让我们谈谈CSS样式。</p>
<p>如您所见，我们的索引页(<a href="http://localhost:3000/">http://localhost:3000</a>)已经有了一些样式。如果查看一下文件结构，您将看到一个名为<code>styles</code>的文件夹，其中包含两个CSS文件:一个全局样式表(<code>global.css</code>)和一个CSS模块(<code>Home.module.css</code>)。<br>如果你的项目没有这些文件，你可以在这里下载启动代码:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-next-app nextjs-blog --use-npm --example &quot;https://github.com/vercel/next-learn/tree/master/basics/assets-metadata-css-starter&quot;</span><br></pre></td></tr></table></figure>

<h3 id="CSS-模块"><a href="#CSS-模块" class="headerlink" title="CSS 模块"></a>CSS 模块</h3><p><a href="https://nextjs.org/docs/basic-features/built-in-css-support">CSS模块</a>允许您通过自动创建唯一的类名来在组件级局部作用域的CSS。这允许您在不同的文件中使用相同的CSS类名，而不用担心类名冲突。</p>
<p>除了CSS模块，你还可以用多种方式为你的Next.js应用设置样式，包括:</p>
<ul>
<li>Sass允许你导入.css和.scss文件</li>
<li>PostCSS库，比如Tailwind CSS</li>
<li>CSS-in-JS库，如<code>styled-jsx</code>、<code>styled-components</code>和<code>emotion</code></li>
</ul>
<p>在本课中，我们将讨论如何在Next.js中使用CSS模块和<a href="https://nextjs.org/docs/basic-features/built-in-css-support#sass-support">Sass</a>。让我们开始吧!</p>
<h3 id="Layout-组件"><a href="#Layout-组件" class="headerlink" title="Layout 组件"></a>Layout 组件</h3><p>首先，让我们创建一个Layout组件，它将被所有页面共享。</p>
<ul>
<li>创建一个名为<code>components</code>的顶级目录。</li>
<li>在组件内部，创建一个名为<code>layout.js</code>的文件，包含以下内容:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">&#123; children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，打开<code>pages/posts/first-post.js</code>，为<code>Layout</code>组件添加一个import，并将其设置为最外层的组件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../../components/layout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">FirstPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>← Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-CSS"><a href="#添加-CSS" class="headerlink" title="添加 CSS"></a>添加 CSS</h3><p>现在，让我们向<code>Layout</code>组件添加一些样式。为此，我们将使用CSS模块，它允许你在React组件中导入CSS文件。</p>
<p>创建一个名为<code>components/layout.module.css</code>的文件，内容如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">36rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3rem</span> auto <span class="number">6rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要</strong>: 要使用CSS模块，CSS文件名必须以<code>.module.css</code>结尾。</p>
</blockquote>
<p>要在<code>components/layout.js</code>中使用这个容器类，你需要:</p>
<ul>
<li>导入CSS文件并为其指定一个名称，如<code>styles</code></li>
<li>使用<code>styles.container</code>作为<code>className</code></li>
</ul>
<p>打开<code>components/layout.js</code>并将其内容替换为以下内容:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./layout.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">&#123; children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你现在转到<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>，你应该看到文本现在在一个居中的容器中:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250942081.png" alt="image.png"></p>
<h3 id="自动生成唯一类名"><a href="#自动生成唯一类名" class="headerlink" title="自动生成唯一类名"></a>自动生成唯一类名</h3><p>现在，如果你在浏览器的devtools中查看一下HTML，你会注意到<code>Layout</code>组件呈现的div有一个类名，看起来像<code>layout_container__…</code> :</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250942493.png" alt="image.png"></p>
<p>这就是CSS模块所做的:它自动生成唯一的类名。只要使用CSS模块，就不必担心类名冲突。</p>
<p>此外，Next.js的代码分割功能也适用于CSS模块。它确保为每个页面加载最少的CSS。这将导致更小的包大小。</p>
<p>CSS模块在构建时从JavaScript包中提取，并生成<code>.css</code>文件，由Next.js自动加载。</p>
<h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><p>CSS模块对于组件级样式非常有用。但如果你想让每个页面都加载一些CSS, Next.js也支持。</p>
<p>要将全局CSS加载到你的应用中，创建一个名为<code>pages/_app.js</code>的文件，内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">&#123; Component, pageProps &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_app.js</code>的默认导出是一个顶级React组件，它包装了应用程序中的所有页面。你可以使用这个组件在页面间导航时保持状态，或者像我们在这里做的那样添加全局样式。了解更多关于<code>_app.js</code>文件的<a href="https://nextjs.org/docs/advanced-features/custom-app">信息</a>。</p>
<h3 id="重启开发服务器"><a href="#重启开发服务器" class="headerlink" title="重启开发服务器"></a>重启开发服务器</h3><p><strong>重要</strong>：添加<code>pages/_app.js</code>时，需要重新启动开发服务器。按“Ctrl + c”停止服务器并运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h3 id="添加全局-CSS"><a href="#添加全局-CSS" class="headerlink" title="添加全局 CSS"></a>添加全局 CSS</h3><p>在Next.js中，你只能从<code>pages/_app.js</code>中导入全局CSS文件。你不能在其他地方导入全局CSS。</p>
<p>全局CSS不能导入到<code>pages/_app.js</code>之外的原因是全局CSS会影响页面上的所有元素。</p>
<p>如果你要从主页导航到<code>/posts/first-post</code>页面，主页的全局样式会无意中影响到<code>/posts/first-pos</code>t。</p>
<p>您可以将全局CSS文件放置在任何位置并使用任何名称。那么让我们做下面的事情:</p>
<ul>
<li>创建一个顶级<code>styles</code>目录和一个<code>global.css</code>文件。</li>
<li>在<code>styles/global.css</code>中添加以下CSS。下面的代码重置了一些样式并改变了<code>a</code>标签的颜色:</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu,</span><br><span class="line">    Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0070f3</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，导入你之前创建的<code>pages/_app.js</code>文件中的CSS文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `pages/_app.js`</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../styles/global.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">&#123; Component, pageProps &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果访问<a href="http://localhost:3000/posts/first-post">http://localhost:3000/posts/first-post</a>，您将看到样式已经应用。在<code>_app.js</code>中导入的任何样式都将全局应用于应用程序的所有页面。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250942380.png" alt="image.png"></p>
<blockquote>
<p><strong>如果它不起作用</strong>：请确保在更新<code>pages/_app.js</code>时重新启动开发服务器。</p>
</blockquote>
<h3 id="Polishing-Layout"><a href="#Polishing-Layout" class="headerlink" title="Polishing Layout"></a>Polishing Layout</h3><p>到目前为止，我们只添加了最少的React和CSS代码，只是为了说明CSS模块之类的概念。在我们继续下一课关于数据获取的内容之前，让我们来润色一下页面样式和代码。</p>
<h3 id="更新-components-layout-module-css"><a href="#更新-components-layout-module-css" class="headerlink" title="更新 components/layout.module.css"></a>更新 <code>components/layout.module.css</code></h3><p>首先，打开<code>components/layout.module.css</code>，并将其内容替换为以下更精致的布局和头像样式:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">36rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3rem</span> auto <span class="number">6rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.backToHome</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3rem</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建-styles-utils-module-css"><a href="#创建-styles-utils-module-css" class="headerlink" title="创建 styles/utils.module.css"></a>创建 <code>styles/utils.module.css</code></h3><p>其次，让我们创建一组CSS实用程序类(用于文本样式)，它们可以跨多个组件重用。</p>
<p>添加一个新的CSS文件<code>styles/utils.module.css</code>，内容如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heading2Xl</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2.5rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">800</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: -<span class="number">0.05rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.headingXl</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.3</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">800</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: -<span class="number">0.05rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.headingLg</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.4</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.headingMd</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.borderCircle</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">9999px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.colorInherit</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.padding1px</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.listItem</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.lightText</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您可以在整个应用程序中重用这些实用程序类，甚至可以在<code>global.css</code>文件中使用实用程序类。实用类指的是一种编写CSS选择器的方法，而不是方法(例如全局样式、CSS模块、Sass等)。了解更多 <a href="https://tailwindcss.com/docs/utility-first">utility-first CSS</a>.。</p>
</blockquote>
<h3 id="更新-components-layout-js"><a href="#更新-components-layout-js" class="headerlink" title="更新 components/layout.js"></a>更新 <code>components/layout.js</code></h3><p>第三，打开<code>components/layout.js</code>并将其内容替换为以下代码，将Your Name更改为实际名称:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Image <span class="keyword">from</span> <span class="string">&#x27;next/image&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./layout.module.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> utilStyles <span class="keyword">from</span> <span class="string">&#x27;../styles/utils.module.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Your Name&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> siteTitle = <span class="string">&#x27;Next.js Sample Website&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params">&#123; children, home &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">content</span>=<span class="string">&quot;Learn how to build a personal website using Next.js&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">property</span>=<span class="string">&quot;og:image&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">content</span>=<span class="string">&#123;</span>`<span class="attr">https:</span>//<span class="attr">og-image.vercel.app</span>/$&#123;<span class="attr">encodeURI</span>(</span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">siteTitle</span>,</span></span></span><br><span class="line"><span class="tag"><span class="xml">          )&#125;<span class="attr">.png</span>?<span class="attr">theme</span>=<span class="string">light&amp;md</span>=<span class="string">0&amp;fontSize</span>=<span class="string">75px&amp;images</span>=<span class="string">https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg</span>`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;og:title&quot;</span> <span class="attr">content</span>=<span class="string">&#123;siteTitle&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;twitter:card&quot;</span> <span class="attr">content</span>=<span class="string">&quot;summary_large_image&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">className</span>=<span class="string">&#123;styles.header&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;home ? (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">priority</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">src</span>=<span class="string">&quot;/images/profile.jpg&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">className</span>=<span class="string">&#123;utilStyles.borderCircle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">height</span>=<span class="string">&#123;144&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">width</span>=<span class="string">&#123;144&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#123;utilStyles.heading2Xl&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">        ) : (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">priority</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">src</span>=<span class="string">&quot;/images/profile.jpg&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">className</span>=<span class="string">&#123;utilStyles.borderCircle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">height</span>=<span class="string">&#123;108&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">width</span>=<span class="string">&#123;108&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&#123;utilStyles.headingLg&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">className</span>=<span class="string">&#123;utilStyles.colorInherit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;name&#125;</span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">main</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">      &#123;!home &amp;&amp; (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.backToHome&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>← Back to home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是新的变动:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Meta_element">meta tags</a>(如og:image)，用于描述页面的内容</li>
<li>布尔home 属性，它将调整标题和图像的大小</li>
<li>如果home为假，则底部的“Back to home”链接</li>
<li>添加了带有<code>next/image</code>的图像，这些图像预先加载了<code>priority</code>属性</li>
</ul>
<h2 id="更新-pages-index-js"><a href="#更新-pages-index-js" class="headerlink" title="更新 pages/index.js"></a>更新 <code>pages/index.js</code></h2><p>最后，让我们更新主页。</p>
<p>打开<code>pages/index.js</code>并将其内容替换为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout, &#123; siteTitle &#125; <span class="keyword">from</span> <span class="string">&#x27;../components/layout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> utilStyles <span class="keyword">from</span> <span class="string">&#x27;../styles/utils.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">home</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;siteTitle&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&#123;utilStyles.headingMd&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>[Your Self Introduction]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          (This is a sample website - you’ll be building a site like this on&#123;&#x27; &#x27;&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://nextjs.org/learn&quot;</span>&gt;</span>our Next.js tutorial<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.)</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后用你的自我介绍代替你的自我介绍。这里有一个作者简介的例子:</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250943061.png" alt="image.png"></p>
<p>就是这样!现在我们有了经过优化的布局代码，我们准备继续我们的<strong>data fetching</strong>课程。</p>
<h3 id="样式技巧"><a href="#样式技巧" class="headerlink" title="样式技巧"></a>样式技巧</h3><p>这里有一些样式技巧可能会对你有所帮助。</p>
<blockquote>
<p>您可以通读下面的部分。无需更改我们的应用程序!</p>
</blockquote>
<h3 id="使用-clsx-库切换类"><a href="#使用-clsx-库切换类" class="headerlink" title="使用 clsx 库切换类"></a>使用 clsx 库切换类</h3><p><code>CLSX</code>是一个简单的库，允许您轻松切换类名。你可以使用<code>npm install clsx</code>或<code>yarn add clsx</code>来安装它。<br>请查看它的<a href="https://github.com/lukeed/clsx">文档</a>了解更多细节，但这里是基本用法:</p>
<ul>
<li>假设你想创建一个接受<code>type</code>的Alert组件，类型可以是’success’或’error’。</li>
<li>如果是success，你希望文本颜色是绿色。如果是error，你希望文本颜色是红色。</li>
</ul>
<p>你可以先像这样写一个CSS模块(比如alert.module.css):</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后像这样使用<code>clsx</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./alert.module.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; clsx &#125; <span class="keyword">from</span> <span class="string">&#x27;clsx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Alert</span>(<span class="params">&#123; children, type &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">className</span>=<span class="string">&#123;clsx(&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        [<span class="attr">styles.success</span>]<span class="attr">:</span> <span class="attr">type</span> === <span class="string">&#x27;success&#x27;</span>,</span></span></span><br><span class="line"><span class="tag"><span class="xml">        [<span class="attr">styles.error</span>]<span class="attr">:</span> <span class="attr">type</span> === <span class="string">&#x27;error&#x27;</span>,</span></span></span><br><span class="line"><span class="tag"><span class="xml">      &#125;)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">    &gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="自定义-PostCSS-配置"><a href="#自定义-PostCSS-配置" class="headerlink" title="自定义 PostCSS 配置"></a>自定义 PostCSS 配置</h3><p>无需配置，Next.js就可以使用<a href="https://postcss.org/">PostCSS</a>编译CSS。</p>
<p>要定制<code>PostCSS</code>配置，可以创建一个名为<a href="https://nextjs.org/docs/advanced-features/customizing-postcss-config#customizing-plugins">postcss.config.js</a>的顶层文件。如果你正在使用<a href="https://tailwindcss.com/">Tailwind CSS</a>之类的库，这是很有用的。</p>
<p>下面是添加Tailwind CSS的步骤。首先，安装这些软件包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss autoprefixer postcss</span><br></pre></td></tr></table></figure>

<p>然后，创建<code>postcss.config.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: &#123;</span><br><span class="line">    <span class="attr">tailwindcss</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">autoprefixer</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还建议通过在<code>tailwind.config.js</code>中指定<code>content</code>选项来<a href="https://tailwindcss.com/docs/content-configuration">配置内容源</a>:</p>
<blockquote>
<p>要了解有关自定义PostCSS配置的更多信息，请查看PostCSS的<a href="https://nextjs.org/docs/advanced-features/customizing-postcss-config">文档</a>。</p>
</blockquote>
<h3 id="使用-Sass"><a href="#使用-Sass" class="headerlink" title="使用 Sass"></a>使用 Sass</h3><p>Next.js允许您同时使用<code>.scss</code>和<code>.sass</code>扩展名导入<a href="https://nextjs.org/docs/basic-features/built-in-css-support#sass-support">Sass</a>。你可以通过CSS模块和<code>.module.scss</code>或者<code>.module.sass</code>使用组件级Sass。</p>
<p>在使用Next.js内置的Sass支持之前，请确保安装了Sass:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D sass</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
        <category>NextJS</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle获取日期</title>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/Oracle%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于经常会再oracle中获取当月的第一天/后一天/上一天/最后一天/上个月这一天，所以整理出下面的oracle获取日期大全出来，有什么更好的建议可以留言补充一下。</p>
<table>
<thead>
<tr>
<th>日期说明</th>
<th>oracle语句（假设现在是2018-11-28 11:11:11）</th>
<th>返回日期</th>
</tr>
</thead>
<tbody><tr>
<td>当月第一天</td>
<td>select trunc(sysdate, ‘mm’) from dual</td>
<td>2018-11-1</td>
</tr>
<tr>
<td>当年第一天</td>
<td>select trunc(sysdate,‘yy’) from dual</td>
<td>2018-1-1</td>
</tr>
<tr>
<td>当前年月日</td>
<td>select trunc(sysdate,‘dd’) from dual</td>
<td>2018-11-28</td>
</tr>
<tr>
<td>当年第一天</td>
<td>select trunc(sysdate,‘yyyy’) from dual</td>
<td>2018-1-1</td>
</tr>
<tr>
<td>当前星期的第一天 （也就是星期天）</td>
<td>select trunc(sysdate,‘d’) from dual</td>
<td>2018-11-28</td>
</tr>
<tr>
<td>当前日期</td>
<td>select trunc(sysdate) from dual</td>
<td>2018-11-28</td>
</tr>
<tr>
<td>当前时间（准确到小时）</td>
<td>select trunc(sysdate, ‘hh’) from dual</td>
<td>2018-11-28 11:00:00</td>
</tr>
<tr>
<td>当前时间（准确到分钟）</td>
<td>select to_char(trunc(sysdate, ‘mi’),‘yyyy-MM-dd HH:mm:ss’) from dual</td>
<td>2018-11-28 11:11:00</td>
</tr>
<tr>
<td>前一天的日期</td>
<td>select TRUNC(SYSDATE - 1) from dual</td>
<td>2018-11-27</td>
</tr>
<tr>
<td>前一个月的日期</td>
<td>select add_months(trunc(sysdate),-1) from dual</td>
<td>2018-10-28</td>
</tr>
<tr>
<td>后一个月的日期</td>
<td>select add_months(trunc(sysdate),1) from dual</td>
<td>2018-12-28</td>
</tr>
<tr>
<td>本月最后一天</td>
<td>select to_char(last_day(sysdate), ‘yyyy-mm-dd’) from dual</td>
<td>2018-11-30</td>
</tr>
</tbody></table>
<h2 id="TRUNC"><a href="#TRUNC" class="headerlink" title="TRUNC()"></a>TRUNC()</h2><p>trunc()函数返回以指定元素格式截去一部分的日期值，或者直接对数字格式的数据进行截断。</p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307251603421.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title>优化器</title>
    <url>/2023/06/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/%E4%BC%98%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Oracle 优化器有两种模式：<strong>基于规则的优化器</strong>（Rule-Based Optimizer，RBO）和<strong>基于成本的优化器</strong>（Cost-Based Optimizer，CBO）。</p>
<h2 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h2><p>RBO 是 Oracle 数据库早期的查询优化器，在执行计划生成时使用固定的优化规则（如使用索引、连接方式选取等），可以保证相同查询在不同时间和环境下产生的执行计划相同。但是，由于没有考虑表数据量、索引选择等因素，可能导致性能不如 CBO。</p>
<h3 id="optimizer-mode"><a href="#optimizer-mode" class="headerlink" title="optimizer_mode"></a>optimizer_mode</h3><ul>
<li>  <strong>ALL_ROWS</strong>：代表基于成本的优化器（Cost-Based Optimizer, CBO），会尝试找到最小代价的执行计划，可以适用于查询结果集较大时的情况。</li>
<li>  **FIRST_ROWS(n)**：代表基于成本的优化器，但是该模式下优化器将尽量快地返回第一批结果，n 为表示要返回结果的行数。该模式适用于需要尽快返回结果的查询，但是可能会牺牲一部分查询性能。</li>
<li>  <strong>CHOOSE</strong>：代表 Oracle 数据库将根据统计信息和其他因素自动选择 RBO 或 CBO 中更适合具体语句的模式。<br>如果 optimizer_mode 参数没有被明确设置，则 Oracle 数据库会默认使用 CHOOSE 参数。在实际应用中，我们需要根据具体的业务场景灵活选择对应的 optimizer_mode 参数。</li>
</ul>
<h2 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h2><p>CBO 会通过收集统计信息（如表大小、数据分布、索引选择等）来计算每个可能执行计划的代价，并选择具有最小代价的执行计划。CBO 可以根据实际数据变化自动调整执行计划，提高了查询性能和可维护性。</p>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><h3 id="RULE"><a href="#RULE" class="headerlink" title="/*+ RULE */"></a><code>/*+ RULE */</code></h3><p>“<code>/*+ RULE */</code>“ 是 Oracle SQL 查询中的一个提示（hint），可以在 SQL 查询中使用，提示 Oracle 数据库使用基于规则的优化器（Rule-Based Optimizer, RBO）而不是基于成本的优化器（Cost-Based Optimizer, CBO）。</p>
<h3 id="INDEX-table-name-index-name"><a href="#INDEX-table-name-index-name" class="headerlink" title="/*+ INDEX(table_name index_name) */"></a><code>/*+ INDEX(table_name index_name) */</code></h3><p> “<code>/*+ INDEX(table_name index_name) */</code>“ 指定使用哪个索引来处理 SQL 查询结果，可以提高查询性能。</p>
<h3 id="FULL-table-name"><a href="#FULL-table-name" class="headerlink" title="/*+ FULL(table_name) */"></a><code>/*+ FULL(table_name) */</code></h3><p> “<code>/*+ FULL(table_name) */</code>“ 强制使用全表扫描来处理 SQL 查询结果，如果 Oracle 数据库自动选择索引访问来处理查询，但实际上数据量很小，全表扫描可能比使用索引访问更快。</p>
<h3 id="ORDERED"><a href="#ORDERED" class="headerlink" title="/*+ ORDERED */"></a><code>/*+ ORDERED */</code></h3><p> “<code>/*+ ORDERED */</code>“ 指定查询计划必须按照查询语句中指定的顺序逐个处理表和视图。这种提示在某些特殊场景下可以提高查询效率。</p>
<h3 id="LEADING-hint-table"><a href="#LEADING-hint-table" class="headerlink" title="/*+ LEADING(hint_table) */"></a><code>/*+ LEADING(hint_table) */</code></h3><p>“<code>/*+ LEADING(hint_table) */</code>“ 指定查询计划从 hint_table 开始处理关联表，可以影响查询执行的效率。</p>
<h3 id="USE-CONCAT"><a href="#USE-CONCAT" class="headerlink" title="/*+ USE_CONCAT */"></a><code>/*+ USE_CONCAT */</code></h3><p>“<code>/*+ USE_CONCAT */</code>“ 将多个 OR 条件正常使用的行级索引转换为连续的区段，从而避免行级索引本身的一些限制。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈 “交浅言深” - 简书</title>
    <url>/2023/07/04/notion/Other/%E6%B5%85%E8%B0%88%20%E2%80%9C%E4%BA%A4%E6%B5%85%E8%A8%80%E6%B7%B1%E2%80%9D%20-%20%E7%AE%80%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浅谈-“交浅言深”-简书"><a href="#浅谈-“交浅言深”-简书" class="headerlink" title="浅谈 “交浅言深” - 简书"></a>浅谈 “交浅言深” - 简书</h1><p>Created: January 4, 2022 12:18 PM</p>
<p>先说一下这个词的由来，在《后汉书 · 崔骃传》载：“骃闻，交浅而言深者，愚也。” 后来，宋代的大文豪苏轼在《上神宗皇帝书》也提到说：“交浅言深，君子所戒。情深不寿，强极则辱。”</p>
<p>交浅言深的危害有：1. 容易让人产生误会，还会尴尬，反而交不到真的朋友。2. 会被有心人利用，有被四处出卖的风险。</p>
<p>其实我就是这样的人，很容易对交情浅的人说利害攸关的恳切的话，但是自己的真心并没有换来别人的关心，反而是出卖。很是痛苦！我反复的问过自己，为什么自己会成为这样的人。认真思考过后，我觉得交浅言深的背后，其实是建立在自信缺失条件下的社交焦虑和应激反应，是心灵自残的恶性循环。</p>
<p>换言之，交浅言深的人很大部分是那些无法忍受沉默的人。由于缺乏自信，我们这类人对于社交过程中的沉默异常敏感，同时会下意识的将沉默看成是自己的过错，因此便产生了社交焦虑，希望用更多，更深入的信息来打破沉默，吸引对方的注意力，恳求对方了解自己，于是不知不觉便说了很多 “不该说” 的话。</p>
<p>我们放下了防备，献祭了自己的自尊和真诚供陌生人赏玩来打发他们无意义的时间，更意味着我们把自己的自尊和真诚标上了一个可以被陌生人肆意赏玩的价码——还有比这更不自爱的行为吗？</p>
<p>如何做到不交浅言深呢？尝试着享受寂寞孤独，另一方面要提升自己的认知和各种能力，增强自信心，学会爱自己！</p>
<p>最后送大家一句话：群居守口，独居守心！ &gt; 本文由简悦 SimpRead 转码</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title>删除配置</title>
    <url>/2023/06/24/Vim/Neovim/%E5%88%A0%E9%99%A4%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset XXXX</span><br></pre></td></tr></table></figure>

<p>XXXX的具体内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git congif -f</span><br><span class="line"></span><br><span class="line">XXXX=xxx</span><br><span class="line">aaaaa=aaa</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vim</category>
        <category>Neovim</category>
      </categories>
  </entry>
  <entry>
    <title>安装NVChad</title>
    <url>/2023/06/24/Vim/Neovim/%E5%AE%89%E8%A3%85NVChad/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>安装neovim最新版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">choco install/upgrade neovim</span><br></pre></td></tr></table></figure>
<p>删除<code>Appdata/local/nvim-data</code>和<code>Appdata/local/nvim</code>里面的文件</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/NvChad/NvChad $HOME\AppData\Local\nvim --depth 1</span><br></pre></td></tr></table></figure>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>因为网络原因可能nvim初始化可能失败，需多次尝试<br>如果有模块找不到也是网络原因<br>![[lazy.nvim-9.14.5.zip]]</p>
<h2 id="lazy-nvim安装插件"><a href="#lazy-nvim安装插件" class="headerlink" title="lazy.nvim安装插件"></a>lazy.nvim安装插件</h2><p>修改”C:\Users\lsy\AppData\Local\nvim\lua\custom\plugins.lua”中的代码<br>例如添加codeium插件，插件加载的相关配置可以查看[官方文档](<a href="https://github.com/folke/lazy.nvim#-plugin-spec">folke/lazy.nvim：💤 Neovim的现代插件管理器 (github.com)</a>)</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Exafunction/codeium.vim&quot;</span>,</span><br><span class="line">    lazy = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- event = &quot;InsertEnter&quot;,</span></span><br><span class="line">    <span class="comment">-- config = function()</span></span><br><span class="line">    <span class="comment">--   require(&quot;better_escape&quot;).setup()</span></span><br><span class="line">    <span class="comment">-- end,</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vim</category>
        <category>Neovim</category>
      </categories>
  </entry>
  <entry>
    <title>Portainer安装</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Docker/Portainer%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Portainer安装"><a href="#Portainer安装" class="headerlink" title="Portainer安装"></a>Portainer安装</h1><ol>
<li><code>docker pull portainer/portainer-ce:latest</code></li>
<li><code>docker run -d  --name portainer -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /app/portainer_data:/data --restart always --privileged**=**true portainer/portainer-ce:latest</code></li>
</ol>
<p><a href="https://www.portainer.io/">Powerful container management software for Platform Teams, DevOps, Dev</a></p>
<p>Portainer官网</p>
<p>快速排序算法是一种分治算法，它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>以下是 Java 语言实现的快速排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void quickSort(int[] arr, int low, int high) &#123;</span><br><span class="line">    if (arr == null || arr.length == 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (low &gt;= high)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 取中间值</span><br><span class="line">    int middle = low + (high - low) / 2;</span><br><span class="line">    int pivot = arr[middle];</span><br><span class="line"></span><br><span class="line">    // 将数组分为两部分</span><br><span class="line">    int i = low, j = high;</span><br><span class="line">    while (i &lt;= j) &#123;</span><br><span class="line">        // 将比中间值小的移到左边</span><br><span class="line">        while (arr[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将比中间值大的移到右边</span><br><span class="line">        while (arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (i &lt;= j) &#123;</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归排序子数组</span><br><span class="line">    if (low &lt; j)</span><br><span class="line">        quickSort(arr, low, j);</span><br><span class="line"></span><br><span class="line">    if (high &gt; i)</span><br><span class="line">        quickSort(arr, i, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>BLOB 详解</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/BLOB%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BLOB-详解"><a href="#BLOB-详解" class="headerlink" title="BLOB 详解"></a>BLOB 详解</h1><p><code>BLOB</code>是<code>Binary Large Object</code>的缩写，意为 “大的二进制对象”。</p>
<p>《JavaScript 权威指南》中对 BLOB 的描述：</p>
<blockquote>
<p>A Blob is an opaque reference to, or handle for, a chunk of data.<br>Blobs oten represent chunks of data from an external source such as a local file, a URL, or a database.</p>
</blockquote>
<p>BLOB 的两个特点：</p>
<ul>
<li>large: Blob 表示巨大的数据块，如视频文件</li>
<li>opaque(不透明): 我们对 BLOB 可以做到操作仅限于设置字节长度、获取 MIME 类型、截取更小的 BLOB。</li>
</ul>
<h2 id="获取-Blob-的方式"><a href="#获取-Blob-的方式" class="headerlink" title="获取 Blob 的方式:"></a>获取 Blob 的方式:</h2><h3 id="1-Blob-支持结构化克隆算法（structured-clone-algorithm），所以可以通过消息事件从另外一个窗口或线程中获取-blob-对象"><a href="#1-Blob-支持结构化克隆算法（structured-clone-algorithm），所以可以通过消息事件从另外一个窗口或线程中获取-blob-对象" class="headerlink" title="1. Blob 支持结构化克隆算法（structured clone algorithm），所以可以通过消息事件从另外一个窗口或线程中获取 blob 对象"></a>1. Blob 支持结构化克隆算法（structured clone algorithm），所以可以通过消息事件从另外一个窗口或线程中获取 blob 对象</h3><h3 id="2-从客户端数据库取出-blob"><a href="#2-从客户端数据库取出-blob" class="headerlink" title="2. 从客户端数据库取出 blob"></a>2. 从客户端数据库取出 blob</h3><h3 id="3-通过-http-从网络上下载-blob"><a href="#3-通过-http-从网络上下载-blob" class="headerlink" title="3. 通过 http 从网络上下载 blob"></a>3. 通过 http 从网络上下载 blob</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getBlob(url, callback)&#123;</span><br><span class="line">    let xhr = new XMLHTTPRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.responseType = &quot;blob&quot;;</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">        callback(xhr.response); // 注意，是 .response 而不是 .responseText</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果下载的blob很大，可以使用 onprogress 获取下载进度</span><br><span class="line">    xhr.send(null);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-通过BlobBuilder创建新的-blob-对象"><a href="#4-通过BlobBuilder创建新的-blob-对象" class="headerlink" title="4. 通过BlobBuilder创建新的 blob 对象"></a>4. 通过<code>BlobBuilder</code>创建新的 blob 对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bb = new BlobBuilder();</span><br><span class="line">bb.append(&#x27;this blob contains this text and 10 big-endian 32-bit signed ints.&#x27;); // 写入字符串</span><br><span class="line">bb.append(&#x27;\0&#x27;); // 写入空字符，表示字符串已结束</span><br><span class="line">var arraybuffer = new ArrayBuffer(4*10);</span><br><span class="line">var dataView = new DataView(arrayBuffer);</span><br><span class="line">for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">    dataView.setInt32(i*4, i);</span><br><span class="line">&#125;</span><br><span class="line">bb.append(arrayBuffer); // 写入ArrayBuffer</span><br><span class="line">var blob = bb.getBlob(&#x27;x-optional/mime-type-here&#x27;); // 获取blob，并指定mime类型</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-客户端-JS-中的File对象是-BLob-的子类型。File-是一个有名称（name）和修改日期（lastModifiedDate）属性的-Blob-数据。可以通过-lt-input-type-quot-file-quot-gt-元素标签或者拖拽接口获取-File-对象。"><a href="#5-客户端-JS-中的File对象是-BLob-的子类型。File-是一个有名称（name）和修改日期（lastModifiedDate）属性的-Blob-数据。可以通过-lt-input-type-quot-file-quot-gt-元素标签或者拖拽接口获取-File-对象。" class="headerlink" title="5. 客户端 JS 中的File对象是 BLob 的子类型。File 是一个有名称（name）和修改日期（lastModifiedDate）属性的 Blob 数据。可以通过&lt;input type=&quot;file&quot;&gt;元素标签或者拖拽接口获取 File 对象。"></a>5. 客户端 JS 中的<code>File</code>对象是 BLob 的子类型。File 是一个有名称（name）和修改日期（lastModifiedDate）属性的 Blob 数据。可以通过<code>&lt;input type=&quot;file&quot;&gt;</code>元素标签或者拖拽接口获取 File 对象。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; id=&quot;ele&quot;&gt;</span><br><span class="line"></span><br><span class="line">const selectedFiles = document.getElementById(&quot;ele&quot;).files</span><br><span class="line">// files属性是的值是一个File对象数组，包含用户选择的0个或多个文件的file对象。</span><br><span class="line">for (let i = 0; i &lt; selectedFiles.length; i++) &#123;</span><br><span class="line">    const f = selectedFiles[i]</span><br><span class="line">    console.log(f.name, f.lastModifiedDate)</span><br><span class="line">    console.log(f.size, f.type) // Blob对象的属性</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对-Blob-对象可做如下操作"><a href="#对-Blob-对象可做如下操作" class="headerlink" title="对 Blob 对象可做如下操作:"></a>对 Blob 对象可做如下操作:</h2><h3 id="1-创建-Blob-URL"><a href="#1-创建-Blob-URL" class="headerlink" title="1. 创建 Blob URL"></a>1. 创建 Blob URL</h3><p>Blob url 是指向存储在浏览器缓存或磁盘中的 blob 的一个引用。</p>
<p>通过<code>createObjectURL()</code>获取指向 Blob 数据的 url <code>blob://</code>，并且在 DOM、css 中使用 blob url，用法和普通的 url 一样。</p>
<p>Blob URL 受同源策略限制，只有在同源的 document 中是合法的。</p>
<p>Blob URL 不是不变的，创建 Blob URL 的 document 被用户关闭后，Blob URL 就会变成无效的。</p>
<p><code>blob://URL</code>工作方式和<code>http://URL</code>类似，当请求<code>blob://URL</code>时浏览器行为和 http 请求相同。如果请求的 blob url 不再合法，浏览器必须返回 404（Not Found）状态码。当请求不同源的 blob url 时，浏览器必须返回 403（Not Allowed）。 Blob URL 只允许通过 <code>GET</code> 请求，请求成功需要返回状态码 200，并且<code>response.header.Content-Type = Blob.type</code></p>
<p>下面的代码是通过 blob url 预览拖拽到指定区域的图片文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            // 处理浏览器兼容问题</span><br><span class="line">            var getBlobURL = (window.URL &amp;&amp; URL.createObjectURL.bind(URL)) ||</span><br><span class="line">                (window.webkitURL &amp;&amp; webkitURL.createObjectURL.bind(URL)) ||</span><br><span class="line">                window.createObjectURL;</span><br><span class="line">            // 释放之前通过createObjectURL创建的对象</span><br><span class="line">            var revokeBlobURL = (window.URL &amp;&amp; URL.revokeObjectURL.bind(URL)) ||</span><br><span class="line">                (window.webkitURL &amp;&amp; webkitURL.revokeObjectURL.bind(URL)) ||</span><br><span class="line">                window.revokeObjectURL;</span><br><span class="line"></span><br><span class="line">            window.onload = function()&#123;</span><br><span class="line">                var droptarget = document.getElementById(&#x27;droptarget&#x27;);</span><br><span class="line">                droptarget.ondragenter = function (e) &#123;</span><br><span class="line">                    var types = e.dataTransfer.types;</span><br><span class="line">                    if (!types ||</span><br><span class="line">                        (types.contains &amp;&amp; types.contains(&#x27;Files&#x27;)) ||</span><br><span class="line">                        (types.indexOf &amp;&amp; types.indexOf(&#x27;Files&#x27;) !== -1)</span><br><span class="line">                    )&#123;</span><br><span class="line">                        droptarget.classList.add(&#x27;active&#x27;);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                droptarget.ondragleave = function () &#123;</span><br><span class="line">                    droptarget.classList.remove(&#x27;active&#x27;);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                droptarget.ondragover = function(e) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                droptarget.ondrop = function(e) &#123;</span><br><span class="line">                    var files = e.dataTransfer.files;</span><br><span class="line">                    for(var i=0; i&lt;files.length; i++)&#123;</span><br><span class="line">                        var type = files[i].type;</span><br><span class="line">                        if (type.substring(0, 6) !== &#x27;image/&#x27;) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        var img = document.createElement(&#x27;img&#x27;);</span><br><span class="line">                        img.src = getBlobURL(files[i]);</span><br><span class="line">                        img.onload = function () &#123;</span><br><span class="line">                            this.width = 100;</span><br><span class="line">                            document.body.append(this);</span><br><span class="line">                            revokeBlobURL(this.src); // 防止内存泄漏</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    droptarget.classList.remove(&#x27;active&#x27;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #droptarget &#123;border: solid black 2px; width: 200px; height: 200px;&#125;</span><br><span class="line">            #droptarget.active &#123;border: solid red 4px;&#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;droptarget&quot;&gt;Drop Files Here&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>postMessage()</code>在窗口和工作进程间传输 blob 数据</li>
<li>将 blob 存储在客户端数据库</li>
<li>通过 XMLHTTPRequest 的<code>send()</code>方法将 blob 上传到服务器</li>
</ol>
<h3 id="5-FileReader对象的异步接口以string或ArrayBuffer的形式提取-blob-对象的内容。"><a href="#5-FileReader对象的异步接口以string或ArrayBuffer的形式提取-blob-对象的内容。" class="headerlink" title="5. FileReader对象的异步接口以string或ArrayBuffer的形式提取 blob 对象的内容。"></a>5. <code>FileReader</code>对象的异步接口以<code>string</code>或<code>ArrayBuffer</code>的形式提取 blob 对象的内容。</h3><p>因为 Blob 的体积比较大，所有访问磁盘上的 blob 的相关 API 都是异步的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function readfile(f)&#123;</span><br><span class="line">    var reader = new FileReader();</span><br><span class="line">    reader.readAsText(f);</span><br><span class="line">    reader.onload = function () &#123;</span><br><span class="line">        var text = reader.result;</span><br><span class="line">        console.log(&#x27;file content: &#x27;, text);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onerror = function(e)&#123;</span><br><span class="line">        console.log(&#x27;Error&#x27;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>Filesystem API</code>和<code>FileWriter</code>对象将 Blob 对象写到本地文件，相关接口浏览器暂不支持。</li>
</ol>
<aside>
💡 BLOB 是 Binary Large Object 的缩写，意为“大的二进制对象”。《JavaScript 权威指南》中对 BLOB 的描述：“一个 Blob 是一个不透明的引用或句柄，指向一块数据。Blob 通常表示来自外部源（如本地文件、URL 或数据库）的数据块。”BLOB 的两个特点是：大（Blob 表示巨大的数据块，如视频文件）和不透明（我们对 BLOB 的操作仅限于设置字节长度、获取 MIME 类型、截取更小的 BLOB）。获取 Blob 的方式有：支持结构化克隆算法（structured clone algorithm），从客户端数据库取出 blob，通过 HTTP 从网络上下载 blob，通过 BlobBuilder 创建新的 blob 对象，以及客户端 JS 中的 File 对象是 Blob 的子类型。对 Blob 对象可做的操作有：创建 Blob URL，通过 createObjectURL() 获取指向 Blob 数据的 URL `blob://`，并且在 DOM、CSS 中使用 blob URL，用法和普通的 URL 一样。

</aside>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>[[Symbol]]</p>
<p>[[Promise]]</p>
<p>[[Class]]</p>
<p>[[Generator]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>一文彻底学会使用 web worker</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%20web%20worker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一文彻底学会使用-web-worker"><a href="#一文彻底学会使用-web-worker" class="headerlink" title="一文彻底学会使用 web worker"></a>一文彻底学会使用 web worker</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先来聊聊单线程的 Javascript</p>
<p>众所周知，js 最初设计是运行在浏览器中的，为了防止多个线程同时操作 DOM，带来渲染冲突问题，所以 js 执行器被设计成单线程。但随着前端技术的发展，js 能力远不止如此，当我们遇到需要大量计算的场景时（比如图像处理、视频解码等），js 线程往往会被长时间阻塞，甚至造成页面卡顿，影响用户体验。为了解决单线程带来的这一弊端，Web Worker 应运而生。</p>
<h1 id="1-Web-Worker"><a href="#1-Web-Worker" class="headerlink" title="1. Web Worker"></a>1. Web Worker</h1><h2 id="1-1-Web-Worker-是什么"><a href="#1-1-Web-Worker-是什么" class="headerlink" title="1.1 Web Worker 是什么"></a>1.1 <code>Web Worker</code> 是什么</h2><p><code>Web Worker</code> 是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。</p>
<p>因为是独立的线程，Worker 线程与 js 主线程能够同时运行，互不阻塞。所以，在我们有大量运算任务时，可以把运算任务交给 Worker 线程去处理，当 Worker 线程计算完成，再把结果返回给 js 主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。</p>
<h2 id="1-2-Web-Worker-能干些什么"><a href="#1-2-Web-Worker-能干些什么" class="headerlink" title="1.2 Web Worker 能干些什么"></a>1.2 <code>Web Worker</code> 能干些什么</h2><p>虽然 Worker 线程是在浏览器环境中被唤起，但是它与当前页面窗口运行在不同的全局上下文中，我们常用的顶层对象 <code>window</code>，以及 <code>parent</code> 对象在 Worker 线程上下文中是不可用的。另外，在 Worker 线程上下文中，操作 DOM 的行为也是不可行的，<code>document</code>对象也不存在。但是，<code>location</code>和<code>navigator</code>对象可以以可读方式访问。除此之外，绝大多数 Window 对象上的方法和属性，都被共享到 Worker 上下文全局对象 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope">WorkerGlobalScope</a> 中。同样，Worker 线程上下文也存在一个顶级对象 <code>self</code>。</p>
<p>详细信息请参考：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers">Functions and classes available to Web Workers</a></p>
<h1 id="2-Web-Worker-使用"><a href="#2-Web-Worker-使用" class="headerlink" title="2. Web Worker 使用"></a>2. Web Worker 使用</h1><h2 id="2-1-创建-worker"><a href="#2-1-创建-worker" class="headerlink" title="2.1 创建 worker"></a>2.1 创建 <code>worker</code></h2><p>创建 <code>worker</code> 只需要通过 <code>new</code> 调用 <code>Worker()</code> 构造函数即可，它接收两个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const worker = new Worker(path, options);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>path</td>
<td>有效的 js 脚本的地址，必须遵守同源策略。无效的 js 地址或者违反同源策略，会抛出SECURITY_ERR 类型错误</td>
</tr>
<tr>
<td>options.type</td>
<td>可选，用以指定 worker 类型。该值可以是 classic 或 module。 如未指定，将使用默认值 classic</td>
</tr>
<tr>
<td>options.credentials</td>
<td>可选，用以指定 worker 凭证。该值可以是 omit, same-origin，或 include。如果未指定，或者 type 是 classic，将使用默认值 omit (不要求凭证)</td>
</tr>
<tr>
<td>options.name</td>
<td>可选，在 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDedicatedWorkerGlobalScope</a> 的情况下，用来表示 worker 的 scope 的一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String_6fa58bba0570d663099f0ae7ae8883ab">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2Fconflicting%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString_6fa58bba0570d663099f0ae7ae8883ab</a> 值，主要用于调试目的。</td>
</tr>
</tbody></table>
<h2 id="2-2-js-主线程与-worker-线程数据传递"><a href="#2-2-js-主线程与-worker-线程数据传递" class="headerlink" title="2.2 js 主线程与 worker 线程数据传递"></a>2.2 js 主线程与 worker 线程数据传递</h2><p>主线程与 worker 线程都是通过 <code>postMessage</code> 方法来发送消息，以及监听 <code>message</code> 事件来接收消息。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line"></span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建worker</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&#x27;message&#x27;, e =&gt; &#123; // 接收消息</span><br><span class="line">    console.log(e.data); // Greeting from Worker.js，worker线程发送的消息</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 这种写法也可以</span><br><span class="line">// myWorker.onmessage = e =&gt; &#123; // 接收消息</span><br><span class="line">//    console.log(e.data);</span><br><span class="line">// &#125;;</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(&#x27;Greeting from Main.js&#x27;); // 向 worker 线程发送消息，对应 worker 线程中的 e.data</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123; // 接收到消息</span><br><span class="line">    console.log(e.data); // Greeting from Main.js，主线程发送的消息</span><br><span class="line">    self.postMessage(&#x27;Greeting from Worker.js&#x27;); // 向主线程发送消息</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好了，一个简单 worker 线程就创建成功了。</p>
<p><code>postMessage()</code> 方法接收的参数可以是字符串、对象、数组等。具体我们在 #2.7 讨论。</p>
<p>主线程与 worker 线程之间的数据传递是传值而不是传地址。所以你会发现，即使你传递的是一个<code>Object</code>，并且被直接传递回来，接收到的也不是原来的那个值了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;);</span><br><span class="line"></span><br><span class="line">const obj = &#123;name: &#x27;小明&#x27;&#125;;</span><br><span class="line">myWorker.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    console.log(e.data === obj); // false</span><br><span class="line">&#125;);</span><br><span class="line">myWorker.postMessage(obj);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    self.postMessage(e.data); // 将接收到的数据直接返回</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-监听错误信息"><a href="#2-3-监听错误信息" class="headerlink" title="2.3 监听错误信息"></a>2.3 监听错误信息</h2><p>web worker 提供两个事件监听错误，<code>error</code> 和 <code>messageerror</code>。这两个事件的区别是:</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>error</td>
<td>当 worker 内部出现错误时触发</td>
</tr>
<tr>
<td>messageerror</td>
<td>当 message 事件接收到无法被反序列化的参数时触发</td>
</tr>
</tbody></table>
<p>监听方式跟接收消息一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建worker</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&#x27;error&#x27;, err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;);</span><br><span class="line">myWorker.addEventListener(&#x27;messageerror&#x27;, err =&gt; &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">self.addEventListener(&#x27;error&#x27;, err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;);</span><br><span class="line">self.addEventListener(&#x27;messageerror&#x27;, err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-关闭-worker-线程"><a href="#2-4-关闭-worker-线程" class="headerlink" title="2.4 关闭 worker 线程"></a>2.4 关闭 worker 线程</h2><p>worker 线程的关闭在主线程和 worker 线程都能进行操作，但对 worker 线程的影响略有不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建worker</span><br><span class="line">myWorker.terminate(); // 关闭worker</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">self.close(); // 直接执行close方法就ok了</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无论是在主线程关闭 worker，还是在 worker 线程内部关闭 worker，worker 线程当前的 Event Loop 中的任务会继续执行。至于 worker 线程下一个 Event Loop 中的任务，则会被直接忽略，不会继续执行。</p>
<p>区别是，在主线程手动关闭 worker，主线程与 worker 线程之间的连接都会被立刻停止，即使 worker 线程当前的 Event Loop 中仍有待执行的任务继续调用 <code>postMessage()</code> 方法，但主线程不会再接收到消息。</p>
<p>在 worker 线程内部关闭 worker，不会直接断开与主线程的连接，而是等 worker 线程当前的 Event Loop 所有任务执行完，再关闭。也就是说，在当前 Event Loop 中继续调用 <code>postMessage()</code> 方法，主线程还是能通过监听<code>message</code>事件收到消息的。</p>
<p>如下两个例子可以很好说明这一点：</p>
<p><strong>在主线程关闭 worker</strong></p>
<ul>
<li>worker 线程在接受到消息后，立即向主线程回复一条消息。然后利用计时器添加一个宏任务；利用 Promise 添加一个微任务；执行一个 for 循环。目的都是向主线程回复一条消息。</li>
<li>主线程在接收到消息后立即关闭 worker 线程。</li>
</ul>
<p>大家可以思考一下，主线程会接收到哪些消息呢，控制台会打印出哪些信息呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建 worker</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    console.log(e.data);</span><br><span class="line">    myWorker.terminate(); // 关闭 worker</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(&#x27;Greeting from Main.js&#x27;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    postMessage(&#x27;Greeting from Worker&#x27;);</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;setTimeout run&#x27;);</span><br><span class="line">        postMessage(&#x27;Greeting from SetTimeout&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;Promise run&#x27;);</span><br><span class="line">        postMessage(&#x27;Greeting from Promise&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; 1001; i++) &#123;</span><br><span class="line">        if (i === 1000) &#123;</span><br><span class="line">            console.log(&#x27;Loop run&#x27;);</span><br><span class="line">            postMessage(&#x27;Greeting from Loop&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<ul>
<li>主线程只会接收到 worker 线程第一次通过 <code>postMessage()</code> 发送的消息，后面的消息不会接收到；</li>
<li>worker 线程当前 Event Loop 里的任务会继续执行，包括微任务；</li>
<li>worker 线程里 setTimeout 创建的下一个 Event Loop 任务队列没有执行。</li>
</ul>
<p><strong>在 worker 线程内部关闭 worker</strong></p>
<p>对上述例子稍作修改，将关闭 worker 的事件放到 worker 线程内部，大家觉得又会打印出什么呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建 worker</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    console.log(e.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(&#x27;Greeting from Main.js&#x27;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    postMessage(&#x27;Greeting from Worker&#x27;);</span><br><span class="line"></span><br><span class="line">    self.close(); // 关闭 worker</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;setTimeout run&#x27;);</span><br><span class="line">        postMessage(&#x27;Greeting from SetTimeout&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;Promise run&#x27;);</span><br><span class="line">        postMessage(&#x27;Greeting from Promise&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; 1001; i++) &#123;</span><br><span class="line">        if (i === 1000) &#123;</span><br><span class="line">            console.log(&#x27;Loop run&#x27;);</span><br><span class="line">            postMessage(&#x27;Greeting from Loop&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p>与在主线程关闭不同的是，worker 线程当前的 Event Loop 任务队列中的 <code>postMessage()</code> 事件都会被主线程监听到。</p>
<h2 id="2-5-Worker-线程引用其他-js-文件"><a href="#2-5-Worker-线程引用其他-js-文件" class="headerlink" title="2.5 Worker 线程引用其他 js 文件"></a>2.5 Worker 线程引用其他 js 文件</h2><p>总有一些场景，需要放到 worker 进程去处理的任务很复杂，需要大量的处理逻辑，我们当然不想把所有代码都塞到 <code>worker.js</code> 里，那样就太糟糕了。不出意料，web worker 为我们提供了解决方案，我们可以在 worker 线程中利用 <code>importScripts()</code> 方法加载我们需要的 js 文件，而且，通过此方法加载的 js 文件<strong>不受同源策略约束</strong>！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// utils.js</span><br><span class="line">const add = (a, b) =&gt; a + b;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">// 使用方法：importScripts(path1, path2, ...);</span><br><span class="line"></span><br><span class="line">importScripts(&#x27;./utils.js&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(add(1, 2)); // log 3</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-6-ESModule-模式"><a href="#2-6-ESModule-模式" class="headerlink" title="2.6 ESModule 模式"></a>2.6 ESModule 模式</h2><p>还有一些场景，当你开启一个新项目，正高兴的用 <code>importScripts()</code> 导入 js 文件时发现， <code>importScripts()</code> 方法执行失败。仔细一看，原来是新项目的 js 文件都用的是 ESModule 模式。难道要把引用到的文件都改一遍吗？当然不用，还记得上文提到初始化 worker 时的第二个可选参数吗，我们可以直接使用 module 模式初始化 worker 线程！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const worker = new Worker(&#x27;/worker.js&#x27;, &#123;</span><br><span class="line">    type: &#x27;module&#x27;  // 指定 worker.js 的类型</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// utils.js</span><br><span class="line">export default add = (a, b) =&gt; a + b;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// worker.js（worker线程）</span><br><span class="line">import add from &#x27;./utils.js&#x27;; // 导入外部js</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">    postMessage(e.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(1, 2); // log 3</span><br><span class="line"></span><br><span class="line">export default self; // 只需把顶级对象self暴露出去即可</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-7-主线程和-worker-线程可传递哪些类型数据"><a href="#2-7-主线程和-worker-线程可传递哪些类型数据" class="headerlink" title="2.7 主线程和 worker 线程可传递哪些类型数据"></a>2.7 主线程和 worker 线程可传递哪些类型数据</h2><p>很多场景，在调用某些方法时，我们将一些自定义方法当作参数传入。但是，当你使用 <code>postMessage()</code> 方法时这么做，将会导致 <code>DATA_CLONE_ERR</code> 错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new Worker(&#x27;/worker.js&#x27;); // 创建worker</span><br><span class="line"></span><br><span class="line">const fun = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(fun); // Error：Failed to execute &#x27;postMessage&#x27; on &#x27;Worker&#x27;: ()=&gt;&#123;&#125; could not be cloned.</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，使用 <code>postMessage()</code> 方法传递消息，可以传递哪些数据？</p>
<p><code>postMessage()</code> 传递的数据可以是由<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/Guide/DOM/The_structured_clone_algorithm">结构化克隆</a>算法处理的任何值或 JavaScript 对象，包括循环引用。</p>
<p>结构化克隆算法<strong>不能处理</strong>的数据：</p>
<ul>
<li><code>Error</code> 以及 <code>Function</code> 对象；</li>
<li>DOM 节点</li>
<li>对象的某些特定参数不会被保留<ul>
<li><code>RegExp</code> 对象的 <code>lastIndex</code> 字段不会被保留</li>
<li>属性描述符，setters 以及 getters（以及其他类似元数据的功能）同样不会被复制。例如，如果一个对象用属性描述符标记为 read-only，它将会被复制为 read-write</li>
<li>原形链上的属性也不会被追踪以及复制。</li>
</ul>
</li>
</ul>
<p>结构化克隆算法<strong>支持</strong>的数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures%23%25E5%258E%259F%25E5%25A7%258B%25E5%2580%25BC">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FData_structures%23%25E5%258E%259F%25E5%25A7%258B%25E5%2580%25BC</a></td>
<td>symbols 除外</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FBoolean</a> 对象</td>
<td></td>
</tr>
<tr>
<td>String 对象</td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FDate</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FRegExp</a></td>
<td>lastIndex 字段不会被保留。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/File">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFile</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FileList">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFileList</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArrayBuffer</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FTypedArray</a></td>
<td>这基本上意味着所有的 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FTyped_arrays</a> ，如 Int32Array 等。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FImageData</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject</a></td>
<td>仅包括普通对象（如对象字面量）</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FMap</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSet</a></td>
<td></td>
</tr>
</tbody></table>
<h1 id="3-SharedWorker"><a href="#3-SharedWorker" class="headerlink" title="3.SharedWorker"></a>3.SharedWorker</h1><p><strong>SharedWorker</strong> 是一种特殊类型的 Worker，可以被多个浏览上下文访问，比如多个 windows，iframes 和 workers，但这些浏览上下文必须同源。它们实现于一个不同于普通 worker 的接口，具有不同的全局作用域：<code>[SharedWorkerGlobalScope](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FSharedWorkerGlobalScope)</code> ，但是继承自 <code>[WorkerGlobalScope](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FSharedWorkerGlobalScope%23properties_inherited_from_workerglobalscope)</code></p>
<p><code>SharedWorker</code> 线程的创建和使用跟 <code>worker</code> 类似，事件和方法也基本一样。 不同点在于，主线程与 <code>SharedWorker</code> 线程是通过 <code>[MessagePort](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FMessagePort)</code>建立起链接，数据通讯方法都挂载在<code>SharedWorker.port</code>上。</p>
<p>值得注意的是，如果你采用 <code>addEventListener</code> 来接收 <code>message</code> 事件，那么在主线程初始化<code>SharedWorker()</code> 后，还要调用 <code>SharedWorker.port.start()</code> 方法来手动开启端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new SharedWorker(&#x27;./sharedWorker.js&#x27;);</span><br><span class="line"></span><br><span class="line">myWorker.port.start(); // 开启端口</span><br><span class="line"></span><br><span class="line">myWorker.port.addEventListener(&#x27;message&#x27;, msg =&gt; &#123;</span><br><span class="line">    console.log(msg.data);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是，如果采用 <code>onmessage</code> 方法，则默认开启端口，不需要再手动调用<code>SharedWorker.port.start()</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.js（主线程）</span><br><span class="line">const myWorker = new SharedWorker(&#x27;./sharedWorker.js&#x27;);</span><br><span class="line"></span><br><span class="line">myWorker.port.onmessage = msg =&gt; &#123;</span><br><span class="line">    console.log(msg.data);</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上两种方式效果是一样的，具体信息请参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/MessagePort">MessagePort</a>。</p>
<p>由于 <code>SharedWorker</code> 是被多个页面共同使用，那么除了与各个页面之间的数据通讯是独立的，同一个<code>SharedWorker</code> 线程上下文中的其他资源都是共享的。基于这一点，很容易实现不同页面之间的数据通讯。</p>
<h2 id="一个利用SharedWorker实现多页面数据共享的例子"><a href="#一个利用SharedWorker实现多页面数据共享的例子" class="headerlink" title="一个利用SharedWorker实现多页面数据共享的例子"></a>一个利用<code>SharedWorker</code>实现多页面数据共享的例子</h2><ol>
<li>index 页面的 add 按钮，每点击一次，向 sharedWorker 发送一次 add 数据，页面 count 增加 1</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;index page&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;index page: &lt;/p&gt;</span><br><span class="line">        count: &lt;span id=&quot;container&quot;&gt;0&lt;/span&gt;</span><br><span class="line">        &lt;button id=&quot;add&quot;&gt;add&lt;/button&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        // 利用iframe加载</span><br><span class="line">        &lt;iframe src=&quot;./iframe.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        if (!!window.SharedWorker) &#123;</span><br><span class="line">            const container = document.getElementById(&#x27;container&#x27;);</span><br><span class="line">            const add = document.getElementById(&#x27;add&#x27;);</span><br><span class="line"></span><br><span class="line">            const myWorker = new SharedWorker(&#x27;./sharedWorker.js&#x27;);</span><br><span class="line"></span><br><span class="line">            myWorker.port.start();</span><br><span class="line"></span><br><span class="line">            myWorker.port.addEventListener(&#x27;message&#x27;, msg =&gt; &#123;</span><br><span class="line">                container.innerText = msg.data;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            add.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">                myWorker.port.postMessage(&#x27;add&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>iframe 页面的 reduce 按钮，每点击一次，向 sharedWorker 发送一次 reduce 数据，页面 count 减少 1</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// iframe.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;iframe page&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;iframe page: &lt;/p&gt;</span><br><span class="line">        count: &lt;span id=&quot;container&quot;&gt;0&lt;/span&gt;</span><br><span class="line">        &lt;button id=&quot;reduce&quot;&gt;reduce&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        if (!!window.SharedWorker) &#123;</span><br><span class="line">            const container = document.getElementById(&#x27;container&#x27;);</span><br><span class="line">            const reduce = document.getElementById(&#x27;reduce&#x27;);</span><br><span class="line"></span><br><span class="line">            const myWorker = new SharedWorker(&#x27;./sharedWorker.js&#x27;);</span><br><span class="line"></span><br><span class="line">            myWorker.port.start();</span><br><span class="line"></span><br><span class="line">            myWorker.port.addEventListener(&#x27;message&#x27;, msg =&gt; &#123;</span><br><span class="line">                container.innerText = msg.data;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            reduce.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">                myWorker.port.postMessage(&#x27;reduce&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>sharedWorker 在接收到数据后，根据数据类型处理 num 计数，然后返回给每个已连接的主线程。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// sharedWorker.js</span><br><span class="line"></span><br><span class="line">let num = 0;</span><br><span class="line">const workerList = [];</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;connect&#x27;, e =&gt; &#123;</span><br><span class="line">    const port = e.ports[0];</span><br><span class="line">    port.addEventListener(&#x27;message&#x27;, e =&gt; &#123;</span><br><span class="line">        num += e.data === &#x27;add&#x27; ? 1 : -1;</span><br><span class="line">        workerList.forEach(port =&gt; &#123; // 遍历所有已连接的part，发送消息</span><br><span class="line">            port.postMessage(num);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    port.start();</span><br><span class="line">    workerList.push(port); // 存储已连接的part</span><br><span class="line">    port.postMessage(num); // 初始化</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果可以发现，index 页面和 iframe 页面的 count 始终保持一致，实现了多个页面数据同步。</p>
<h2 id="sharedWorker调试"><a href="#sharedWorker调试" class="headerlink" title="sharedWorker调试"></a><code>sharedWorker</code>调试</h2><p>在 <code>sharedWorker</code> 线程里使用 <code>console</code> 打印信息，不会出现在主线程的的控制台中。如果你想调试 <code>sharedWorker</code>，需要在 Chrome 浏览器输入 <a href="https://link.juejin.cn/?target=">chrome://inspect/</a> ，这里能看到所有正在运行的 <code>sharedWorker</code>，然后开启一个独立的 dev-tool 面板。</p>
<h1 id="4-兼容性"><a href="#4-兼容性" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h1><p>数据统计于 2022-07</p>
<ol>
<li>web workers</li>
</ol>
<p>可以看出，web workers 已经被大多数浏览器支持，使用上基本不用考虑兼容问题。</p>
<ol>
<li>sharedWorker</li>
</ol>
<p>sharedWorker 在 Safari 以及移动端的兼容性不是很好，使用时还需注意。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>其实，除了 <code>worker</code> 和 <code>sharedWorker</code> 外，还有 <code>ServiceWorker</code>。它一般作为 Web 应用程序、浏览器和网络之间的代理服务，旨在创建有效的离线体验，拦截网络请求，并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。使用方法本文不作详细介绍，有兴趣可自行查看 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker">ServiceWorker</a></p>
<p>好了，以上就是本期全部内容，欢迎交流讨论！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Worker">Worker</a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">SharedWorker</a></li>
<li><a href="https://juejin.cn/post/6844904198639714311">你不知道的 Web Workers</a></li>
</ul>
<blockquote>
<p>本文原作者 JackTian，欢迎交流讨论！ 本文由简悦 SimpRead 转码</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>一文搞懂 JS 原型与原型链（超详细，建议收藏）</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20JS%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一文搞懂-JS-原型与原型链（超详细，建议收藏）"><a href="#一文搞懂-JS-原型与原型链（超详细，建议收藏）" class="headerlink" title="一文搞懂 JS 原型与原型链（超详细，建议收藏）"></a>一文搞懂 JS 原型与原型链（超详细，建议收藏）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个前端开发工程师，熟练掌握 JS 这门语言是必须要的。无论是日常的工作中，亦或者是出去面试找工作，JS 掌握的多深多好，很大程度上决定了你能走的多远。今天本人就来介绍一下 JS 的<code>原型</code>以及<code>原型链</code>，基于本人的一些认识。因为本人也在学习的阶段，所以如果文章中有什么不对的或者不好的地方，烦请大家指出。</p>
<h2 id="JS-原型"><a href="#JS-原型" class="headerlink" title="JS 原型"></a>JS 原型</h2><p>众所周知，JS 的复杂类型都是对象类型（<strong>Object</strong>），而 JS 不是一门完全面向对象编程的语言，所以如何涉及继承机制，就是一个问题。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>因为 JS 中没有类（<strong>Class</strong>）这个概念，所以 JS 的设计者使用了<code>构造函数</code>来实现继承机制。</p>
<blockquote>
<p>ES6 中的class可以看作只是一个语法糖，它的绝大部分的功能，ES5 都可以做到，新的class写法只是让原型的写法更加的清晰、更像面向对象编程的语法而已。下文也会进一步的说明。（摘自阮一峰的 ES6 入门）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成实例</span><br><span class="line">const p = new Person(&#x27;zhangsan&#x27;, 18);</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上述代码所示，JS 通过<code>构造函数</code>来生成<code>实例</code>。但是又出现了一个新的问题，在<code>构造函数</code>中通过<code>this</code>赋值的属性或者方法，是每个实例的<code>实例属性</code>以及<code>实例方法</code>，无法共享公共属性。所以又设计出了一个<code>原型对象</code>，来存储这个<code>构造函数</code>的公共属性以及方法。</p>
<h3 id="补充知识：构造函数创建一个实例的过程"><a href="#补充知识：构造函数创建一个实例的过程" class="headerlink" title="补充知识：构造函数创建一个实例的过程"></a>补充知识：构造函数创建一个实例的过程</h3><ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（这样 this 就指向了新对象）</li>
<li>执行构造函数中的代码（为新对象添加实例属性和实例方法）</li>
<li>返回新对象</li>
</ol>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>说了这么久，终于说到了 JS 的<code>原型对象</code>了。JS 的每个函数在创建的时候，都会生成一个属性<code>prototype</code>，这个属性指向一个对象，这个对象就是此函数的<code>原型对象</code>。该<code>原型对象</code>中有个属性为<code>constructor</code>，指向该函数。这样<code>原型对象</code>和<code>它的函数</code>之间就产生了联系。</p>
<h2 id="JS-原型链"><a href="#JS-原型链" class="headerlink" title="JS 原型链"></a>JS 原型链</h2><p>讲清楚了 JS 的<code>原型对象</code>，来就是介绍 JS 的<code>原型链</code>了。既然有了<code>构造函数</code>，那么就可以通过该<code>构造函数</code>，来创建一个实例对象了。此时，完善一下我们的<code>Preson</code>构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 构造函数</span><br><span class="line">    function Preson(name, age) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 所有实例共享的公共方法</span><br><span class="line">    Preson.prototype.say = function (word) &#123;</span><br><span class="line">      console.log(`$&#123;this.name&#125;说：$&#123;word&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const p1 = new Preson(&#x27;张三&#x27;, 18); // 创建一个Person实例对象</span><br><span class="line">    p1.hasOwnProperty(&#x27;say&#x27;) // false 说明不是定义在其本身上的</span><br><span class="line">    p1.say(&#x27;hello world&#x27;); // 调用公共方法 打印：张三说：hello world</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就要思考了，为什么我们构造的<code>p1</code>这个<code>实例对象</code>，它可以调用到<code>Person</code>这个<code>构造函数</code>的<code>原型对象</code>上的方法呢？明明只有在<code>构造函数</code>内部通过<code>this</code>来赋值的属性或者方法才会被实例所继承，为什么在<code>构造函数</code>的<code>原型对象</code>上定义的<code>say</code>方法也能通过实例来调用到呢？这里就引出了<code>原型链</code>这个概念。</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>每个通过<code>构造函数</code>创建出来的<code>实例对象</code>，其本身有个属性<code>__proto__</code>，这个属性会指向该<code>实例对象</code>的<code>构造函数</code>的<code>原型对象</code>，这么说好像有点绕，我们看下图</p>
<blockquote>
<p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法 / 属性。（摘自阮一峰的 ES6 入门）</p>
</blockquote>
<p>现在我们知道了，当访问一个<code>对象</code>的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的<code>__proto__</code>隐式属性，找到它的<code>构造函数</code>的<code>原型对象</code>，如果还没有找到就会再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p>
<p><strong>注意点</strong>：如果通过<code>p1实例对象</code>的<code>__proto__</code>属性赋值，则会改变其<code>构造函数</code>的<code>原型对象</code>，从而被所有实例所共享。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 构造函数</span><br><span class="line">    function Preson(name, age) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 所有实例共享的公共方法</span><br><span class="line">    Preson.prototype.say = function (word) &#123;</span><br><span class="line">      console.log(`$&#123;this.name&#125;说：$&#123;word&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const p1 = new Preson(&#x27;张三&#x27;, 18); // 创建一个Person实例对象</span><br><span class="line">    const p2 = new Preson(&#x27;李四&#x27;, 20); // 新创建一个Proson实例对象</span><br><span class="line">    p1.say(&#x27;hello world&#x27;); // 调用公共方法</span><br><span class="line">    p1.hasOwnProperty(&#x27;say&#x27;) // false 说明不是定义在其本身上的</span><br><span class="line">    p1.__proto__.do = function () &#123;</span><br><span class="line">      console.log(&#x27;往原型对象中添加方法&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    p2.do(); // 打印出了-往原型对象中添加方法</span><br><span class="line">复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以，我们在开发的时候，要注意不要通过实例对象去改变其构造函数的原型对象，这样会对其他通过该构造函数生成的实例对象造成影响。</p>
</blockquote>
<p>说到这里，有的读者可能又会产生疑问了，再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找是什么意思？我们继续往下看。</p>
<h3 id="补充知识：原型链的尽头"><a href="#补充知识：原型链的尽头" class="headerlink" title="补充知识：原型链的尽头"></a>补充知识：原型链的尽头</h3><p>既然我们之前构造的<code>p1实例对象</code>有<code>__proto__</code>属性指向其<code>构造函数</code>的<code>原型对象</code>，那么该<code>构造函数</code>的<code>原型对象</code>有这个<code>__proto__</code>属性吗？如果有，那么其又指向谁呢？我们不妨打印一下。</p>
<p>我们随便创建了一个<code>A</code>的<code>构造函数</code>，通过打印它的<code>prototype</code>属性，我们可以看到，在浏览器中，它有个<code>__proto__</code>属性指向了一个<code>Object</code>对象。</p>
<p>而进一步展开后，我们会发现，该对象的<code>构造函数</code>为<code>function Object</code>，我们由此可以得知，<strong>所有的<code>原型对象</code>的<code>__proto__</code>属性都是指向<code>function Object</code>的<code>原型对象</code>。</strong> 而<code>function Object</code>的<code>原型对象</code>在上图中我们可以得知是不存在<code>__proto__</code>这个属性的，它指向了<code>null</code>。我们就得知了<code>原型链</code>的尽头是<code>null</code>。</p>
<h3 id="补充知识：所有对象的原型链"><a href="#补充知识：所有对象的原型链" class="headerlink" title="补充知识：所有对象的原型链"></a>补充知识：所有对象的原型链</h3><p>既然 JS 的复杂类型都是<code>对象</code>，那么，函数作为一个<code>对象</code>，是否也存在<code>原型链</code>呢？ 我们在浏览器中创建一个<code>构造函数</code>，打印它的<code>__proto__</code>属性，一探究竟：</p>
<p>我们可以看到，它的<code>__proto__</code>属性指向了一个<code>function Function</code>的<code>原型对象</code>，该<code>原型对象</code>为 JS 中所有函数的<code>原型对象</code>，而其<code>__proto__</code>属性也还是指向了<code>function Object</code>的<code>原型对象</code>，所以验证了<code>原型链</code>的尽头为<code>null</code>，这一说法。</p>
<p>最后，奉上神图一张，祝大家理解 JS 的<code>原型链</code></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过上面的文章，大概梳理了一下本人对于<code>原型</code>和<code>原型链</code>这一概念的理解，并且尽可能详细的阐述了各个概念的前世今生。因为本人也是个前端菜鸡，写这篇文章的目的除了让大家了解<code>原型</code>和<code>原型链</code>这一概念外，还有就是自己梳理一遍所掌握的知识。如果上文有说的不对或者不好的地方，欢迎大家提出宝贵的意见。</p>
<p>PS：下一篇准备写关于闭包的一些个人理解。 &gt; 本文由简悦 SimpRead 转码</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>事件循环（Event Loop）</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event%20Loop%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h1><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li>[[单线程]]</li>
<li>[[事件循环机制 Event Loop]]</li>
<li>[[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]] [[1 同步任务与异步任务]]</li>
</ul>
<h1 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h1><p>JavaScript 是一种单线程的编程语言，同一时间只能做一件事，所有任务都需要排队依次完成。<br>为什么 JS 不能有多个线程呢<br>答：作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准。</p>
<p>​ 为了避免这种复杂性，因此 JS 只能是单线程。</p>
<h1 id="事件循环机制（Event-Loop）"><a href="#事件循环机制（Event-Loop）" class="headerlink" title="事件循环机制（Event Loop）"></a><a href="https://so.csdn.net/so/search?q=%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020">事件循环机制</a>（Event Loop）</h1><p>含义：事件循环分为两种, 分别是<strong>浏览器事件循环</strong>和 <strong>node.js 事件循环</strong>，JavaScript 是一门单线程语言，指主线程只有一个。<strong>Event Loop</strong> 事件循环，其实就是 JS 引擎管理事件执行的一个流程，具体由运行环境确定。目前 JS 的主要运行环境有两个，浏览器和 Node.js。</p>
<p>​ 事件循环机制告诉了我们 JS 代码的执行顺序，是指浏览器或 Node 的一种解决 JS 单线程运行时不会阻塞的一种机制。</p>
<p>浏览器的事件循环又分为<strong>同步任务和异步任务</strong></p>
<h2 id="1、同步任务与异步任务"><a href="#1、同步任务与异步任务" class="headerlink" title="1、同步任务与异步任务"></a>1、同步任务与异步任务</h2><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>含义：在主线程上排队执行的任务，只有一个任务执行完毕，才能执行后一个任务</p>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>含义：不进入主线程，而进入 “任务队列（task queue）” 的任务，只有 “任务队列” 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>分类：异步任务又分为宏任务和微任务。所有同步任务都在主线程上执行，形成一个函数调用栈（执行栈），而异步则先放到<strong>任务队列</strong>（<strong>task queue</strong>）里，任务队列又分为<strong>宏任务</strong>（<a href="https://so.csdn.net/so/search?q=macro&spm=1001.2101.3001.7020">macro</a>-task）与<strong>微任务</strong>（micro-task）。</p>
<h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务包括：script(整体代码)、setTimout、setInterval、setImmediate(node.js 环境)、I/O、UI 交互事件</p>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>微任务包括：new promise().then(回调)、MutationObserver(html5 新特新)、Object.observe(已废弃)、process.nextTick（node 环境）</p>
<p>​ <strong>若同时存在 promise 和 nextTick，则先执行 nextTick</strong></p>
<h2 id="2、执行过程"><a href="#2、执行过程" class="headerlink" title="2、执行过程"></a>2、执行过程</h2><ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（调用栈）；</li>
<li>主线程之外，还存在一个‘任务队列’（task queue），浏览器中的各种 Web API 为异步的代码提供了一个单独的运行空间，当异步的代码运行完毕以后，会将代码中的回调送入到 任务队列中（队列遵循先进先出得原则）</li>
<li>一旦主线程的栈中的所有同步任务执行完毕后，调用栈为空时系统就会将队列中的回调函数依次压入调用栈中执行，当调用栈为空时，仍然会不断循环检测任务队列中是否有代码需要执行；</li>
</ol>
<h2 id="3、执行顺序"><a href="#3、执行顺序" class="headerlink" title="3、执行顺序"></a>3、执行顺序</h2><ul>
<li>先执行同步代码，</li>
<li>遇到异步宏任务则将异步宏任务放入宏任务队列中，</li>
<li>遇到异步微任务则将异步微任务放入微任务队列中，</li>
<li>当所有同步代码执行完毕后，再将<strong>异步微任务</strong>从队列中调入主线程执行，</li>
<li>微任务执行完毕后再将异步宏任务从队列中调入主线程执行，</li>
<li>一直循环直至所有任务执行完毕。</li>
</ul>
<p>注意：当宏任务和微任务都处于 任务队列（Task Queue） 中时，<strong>微任务的优先级大于宏任务</strong>，即先将微任务执行完，再执行宏任务；</p>
<h2 id="4、举例："><a href="#4、举例：" class="headerlink" title="4、举例："></a>4、举例：</h2><p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250957873.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250957778.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;4&quot;);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(&quot;8&quot;);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">        new Promise((r) =&gt; &#123;</span><br><span class="line">          console.log(&quot;5&quot;);//构造函数是同步的</span><br><span class="line">          r();</span><br><span class="line">        &#125;).then(() =&gt; &#123;</span><br><span class="line">          console.log(&quot;7&quot;);//then()是异步的，这里已经入队</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(&quot;6&quot;);</span><br><span class="line">      &#125;, 0);</span><br><span class="line"></span><br><span class="line">      new Promise((r) =&gt; &#123;</span><br><span class="line">        console.log(&quot;1&quot;);//构造函数是同步的</span><br><span class="line">        r();</span><br><span class="line">      &#125;).then(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;3&quot;);//then()是异步的，这里已经入队</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(&quot;2&quot;);</span><br><span class="line">//输出顺序：1 2 3 4 5 6 7 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;1&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&#x27;3&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;4&#x27;);</span><br><span class="line">//输出顺序：2 4 3 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>遇到 setTimout，异步宏任务，放入宏任务队列中；</li>
<li>遇到 new Promise，Promise 在实例化的过程中所执行的代码都是同步进行的，所以输出 2；</li>
<li>而 Promise.then 中<strong>注册的回调才是异步执行</strong>的，将其放入微任务队列中</li>
<li>遇到同步任务 console.log(‘4’); 输出 4；主线程中同步任务执行完</li>
<li>从微任务队列中取出任务到主线程中，输出 3，微任务队列为空</li>
<li>从宏任务队列中取出任务到主线程中，输出 1，宏任务队列为空，结束~</li>
</ol>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  new Promise(resolve =&gt;&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;test&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;).then( () =&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">  Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;before timeout&#x27;);</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;also before timeout&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(2);</span><br><span class="line">//输出：1 2 3 before timeout also before timeout 4 test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>遇到 setTimeout，异步宏任务，将 () =&gt; {console.log(4)} 放入宏任务队列中；</li>
<li>遇到 new Promise，Promise 在实例化的过程中所执行的代码都是同步进行的，所以输出 1；</li>
<li>而 Promise.then 中注册的回调才是异步执行的，将其放入微任务队列中</li>
<li>遇到同步任务 console.log(2)，输出 2；主线程中同步任务执行完</li>
<li>从微任务队列中取出任务到主线程中，输出 3，此微任务中又有微任务，Promise.resolve().then(微任务 a).then(微任务 b)，将其依次放入微任务队列中；</li>
<li>从微任务队列中取出任务 a 到主线程中，输出 before timeout；</li>
<li>从微任务队列中取出任务 b 到主线程中，任务 b 又注册了一个微任务 c，放入微任务队列中；</li>
<li>从微任务队列中取出任务 c 到主线程中，输出 also before timeout；微任务队列为空</li>
<li>从宏任务队列中取出任务到主线程，此任务中注册了一个微任务 d，将其放入微任务队列中，接下来遇到输出 4，宏任务队列为空</li>
<li>从微任务队列中取出任务 d 到主线程 ，输出 test，微任务队列为空，结束 &gt; 本文由简悦 SimpRead 转码</li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Docker+Jenkins+Nginx+Vue</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Server/Docker+Jenkins+Nginx+Vue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker-Jenkins-Nginx-Vue"><a href="#Docker-Jenkins-Nginx-Vue" class="headerlink" title="Docker+Jenkins+Nginx+Vue"></a>Docker+Jenkins+Nginx+Vue</h1><ol>
<li><p>安装Docker</p>
<p> 直接宝塔面板安装</p>
</li>
<li><p>docker安装Jenkins</p>
</li>
</ol>
<p>使用docker-compose安装（注意开放相关端口）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services</span>:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins:latest</span><br><span class="line">    <span class="attr">container_name</span>: jenkins</span><br><span class="line">    <span class="attr">restart</span>: always</span><br><span class="line">    <span class="attr">networks</span>:</span><br><span class="line">      - devops</span><br><span class="line">    <span class="attr">volumes</span>:</span><br><span class="line">      - jenkins-data:<span class="regexp">/var/</span>jenkins_home</span><br><span class="line">      - <span class="regexp">/var/</span>run/docker.sock:<span class="regexp">/var/</span>run/docker.sock</span><br><span class="line">    <span class="attr">ports</span>:</span><br><span class="line">      - <span class="string">&quot;9001:8080&quot;</span></span><br><span class="line">      - <span class="string">&quot;9002:50000&quot;</span></span><br><span class="line">    <span class="attr">healthcheck</span>:</span><br><span class="line">      test: [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;healthcheck.sh&quot;</span>, <span class="string">&quot;||&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">      <span class="attr">interval</span>: 30s</span><br><span class="line">      <span class="attr">timeout</span>: 10s</span><br><span class="line">      <span class="attr">retries</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">networks</span>:</span><br><span class="line">  devops:</span><br><span class="line">    driver: bridge</span><br><span class="line"><span class="attr">volumes</span>:</span><br><span class="line">  jenkins-data:</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>docker安装Nginx</li>
</ol>
<p>使用docker-compose安装（注意开放相关端口）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services</span>:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins:latest</span><br><span class="line">    <span class="attr">container_name</span>: jenkins</span><br><span class="line">    <span class="attr">restart</span>: always</span><br><span class="line">    <span class="attr">networks</span>:</span><br><span class="line">      - devops</span><br><span class="line">    <span class="attr">volumes</span>:</span><br><span class="line">      - jenkins-data:<span class="regexp">/var/</span>jenkins_home</span><br><span class="line">      - <span class="regexp">/var/</span>run/docker.sock:<span class="regexp">/var/</span>run/docker.sock</span><br><span class="line">    <span class="attr">ports</span>:</span><br><span class="line">      - <span class="string">&quot;9001:8080&quot;</span></span><br><span class="line">      - <span class="string">&quot;9002:50000&quot;</span></span><br><span class="line">    <span class="attr">healthcheck</span>:</span><br><span class="line">      test: [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;healthcheck.sh&quot;</span>, <span class="string">&quot;||&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">      <span class="attr">interval</span>: 30s</span><br><span class="line">      <span class="attr">timeout</span>: 10s</span><br><span class="line">      <span class="attr">retries</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">networks</span>:</span><br><span class="line">  devops:</span><br><span class="line">    driver: bridge</span><br><span class="line"><span class="attr">volumes</span>:</span><br><span class="line">  jenkins-data:</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>配置Jenkins</p>
<p> 配置gitee,配置node,创建Jenkins项目</p>
</li>
<li><p>Nginx的html目录映射到Jenkins的workspace的vue build生成的dist目录</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">/<span class="keyword">var</span>/lib/docker/volumes/2e54334c0a5ce2e3e5a5845df3ab3ada_jenkins-data/_data/workspace/BIRTHDAY/dist:<span class="regexp">/usr/</span>share/nginx/html</span><br><span class="line"></span><br><span class="line">jenkins-data:<span class="regexp">/var/</span>jenkins_home</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Server</category>
      </categories>
  </entry>
  <entry>
    <title>Neovim安装教程</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vim/Neovim%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Neovim安装教程"><a href="#Neovim安装教程" class="headerlink" title="Neovim安装教程"></a>Neovim安装教程</h1><h1 id="1-下载Neovim的exe文件"><a href="#1-下载Neovim的exe文件" class="headerlink" title="1. 下载Neovim的exe文件"></a>1. 下载Neovim的exe文件</h1><p>直接官网下载</p>
<h1 id="2-安装vim-plug"><a href="#2-安装vim-plug" class="headerlink" title="2. 安装vim-plug"></a>2. 安装vim-plug</h1><p>复制<a href="https://github.com/junegunn/vim-plug">plug.vim</a>到nvim的安装路径下的share\nvim\runtime\autoload文件夹下</p>
<p><a href="Neovim%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%20ee7c6333e872477fafe27fdddae6b324/plug.vim">plug.vim</a></p>
<h1 id="3-新建init-vim文件"><a href="#3-新建init-vim文件" class="headerlink" title="3. 新建init.vim文件"></a>3. 新建init.vim文件</h1><p>在C:\Users\当前用户\AppData\Local\nvim下新建init.vim文</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">call plug#begin(<span class="string">&#x27;D:\Softwares\Nvim\plugged&#x27;</span>)</span><br><span class="line"><span class="string">&quot;这里的路径可自定义，推荐放到nvim安装路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plug &#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;godlygeek/tabular&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;plasticboy/vim-markdown&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;iamcco/markdown-preview.nvim&#x27;, &#123; &#x27;do&#x27;: &#123; -&gt; mkdp#util#install() &#125;, &#x27;for&#x27;: [&#x27;markdown&#x27;, &#x27;vim-plug&#x27;]&#125;</span></span><br><span class="line"><span class="string">Plug &#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;yuttie/inkstained-vim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;ferrine/md-img-paste.vim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;</span></span><br><span class="line"><span class="string">Plug &#x27;nvim-lua/plenary.nvim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;nvim-telescope/telescope.nvim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;kyazdani42/nvim-web-devicons&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;nvim-treesitter/nvim-treesitter&#x27;, &#123;&#x27;do&#x27;: &#x27;:TSUpdate&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;</span>将所有插件安装在这里</span><br><span class="line"></span><br><span class="line">call plug#end()</span><br><span class="line"><span class="keyword">let</span> g:vim_markdown_folding_disabled = <span class="number">1</span></span><br><span class="line">map &lt;F2&gt; :NERDTree&lt;CR&gt;</span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"><span class="string">&quot; for normal mode</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; &lt;F8&gt; &lt;Plug&gt;MarkdownPreview</span></span><br><span class="line"><span class="string">&quot;</span> <span class="keyword">for</span> insert mode</span><br><span class="line">imap &lt;silent&gt; &lt;F8&gt; &lt;Plug&gt;MarkdownPreview</span><br><span class="line"><span class="string">&quot; for normal mode</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; &lt;F9&gt; &lt;Plug&gt;StopMarkdownPreview</span></span><br><span class="line"><span class="string">&quot;</span> <span class="keyword">for</span> insert mode</span><br><span class="line">imap &lt;silent&gt; &lt;F9&gt; &lt;Plug&gt;StopMarkdownPreview</span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&quot; Find files using Telescope command-line sugar.</span></span><br><span class="line"><span class="string">autocmd FileType markdown nmap &lt;buffer&gt;&lt;silent&gt; &lt;leader&gt;i :call mdip#MarkdownClipboardImage()&lt;CR&gt;</span></span><br><span class="line"><span class="string">let g:mdip_imgdir = &#x27;</span>.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">let g:mdip_imgname = &#x27;</span>image<span class="string">&#x27;</span></span><br><span class="line"><span class="string">set number</span></span><br></pre></td></tr></table></figure>

<h1 id="5-打开nvim-在命令模式输入PlugInstall"><a href="#5-打开nvim-在命令模式输入PlugInstall" class="headerlink" title="5. 打开nvim, 在命令模式输入PlugInstall"></a>5. 打开nvim, 在命令模式输入PlugInstall</h1>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title>直接运行vue项目并访问</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Server/%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8Cvue%E9%A1%B9%E7%9B%AE%E5%B9%B6%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="直接运行vue项目并访问"><a href="#直接运行vue项目并访问" class="headerlink" title="直接运行vue项目并访问"></a>直接运行vue项目并访问</h1><ol>
<li>先安装node 直接用宝塔面板的node工具安装</li>
<li>配置vite.config.js</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">server</span>:&#123;</span><br><span class="line">	<span class="attr">port</span>:<span class="string">&#x27;指定端口&#x27;</span>,</span><br><span class="line">	<span class="attr">host</span>:<span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>关闭防火墙，开放对应端口</li>
<li><code>npm run dev</code></li>
<li>通过公网ip加端口号访问</li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Server</category>
      </categories>
  </entry>
  <entry>
    <title>windows 编译Emscripten</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/WebAssembly/windows%20%E7%BC%96%E8%AF%91Emscripten/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="windows-编译Emscripten"><a href="#windows-编译Emscripten" class="headerlink" title="windows 编译Emscripten"></a>windows 编译Emscripten</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> git clone https:<span class="comment">//github.com/juj/emsdk.git</span></span><br><span class="line"><span class="number">2.</span> cd emsdk</span><br><span class="line"><span class="number">3.</span> ./emsdk.bat install latest</span><br><span class="line"><span class="number">4.</span> ./emsdk.py activate latest</span><br><span class="line"><span class="number">5.</span> ./emsdk_env.bat (暂时性环境配置)</span><br><span class="line"><span class="number">6.</span> 手动配置环境</span><br><span class="line"><span class="number">7.</span> 重启，输入: emcc -v</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>WebAssembly</category>
      </categories>
  </entry>
  <entry>
    <title>Vue+Vite静态资产引入打包</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/Vue+Vite%E9%9D%99%E6%80%81%E8%B5%84%E4%BA%A7%E5%BC%95%E5%85%A5%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue-Vite静态资产引入打包"><a href="#Vue-Vite静态资产引入打包" class="headerlink" title="Vue+Vite静态资产引入打包"></a>Vue+Vite静态资产引入打包</h1><ol>
<li><p>CSS中引入</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">url(<span class="string">&quot;相对路径“)</span></span><br></pre></td></tr></table></figure></li>
<li><p>JS中引入</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> URL(<span class="string">&quot;相对路径&quot;</span>,<span class="keyword">import</span>.meta.url).href</span><br></pre></td></tr></table></figure></li>
<li><p>HTML中引入</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;@/....../...&quot;</span></span><br></pre></td></tr></table></figure>

 <aside>
 💡 需要注意的是当使用`@`引入视频音频文件时路径要写在`<source>`标签中

 </aside></li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3+Vite引入Sass</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/Vue3+Vite%E5%BC%95%E5%85%A5Sass/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue3-Vite引入Sass"><a href="#Vue3-Vite引入Sass" class="headerlink" title="Vue3+Vite引入Sass"></a>Vue3+Vite引入Sass</h1><p>全局：直接main.js引入就行</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局引入</span></span><br><span class="line"><span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">scss</span>: &#123;</span><br><span class="line">        <span class="comment">/**如果引入多个文件，可以使用</span></span><br><span class="line"><span class="comment">       * &#x27;<span class="doctag">@import </span>&quot;@/assets/scss/globalVariable1.scss&quot;;</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@import</span>&quot;@/assets/scss/globalVariable2.scss&quot;;&#x27;</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">        additionalData: <span class="string">&#x27;@import &quot;@/style/globalVar.scss&quot;;&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>局部</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按需引入并使用</span></span><br><span class="line">&lt;style scoped lang=<span class="string">&quot;scss&quot;</span>&gt;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&quot;@/style/globalMixin.scss&quot;</span>;</span><br><span class="line">.test&#123;</span><br><span class="line">  <span class="attr">width</span>: 650px;</span><br><span class="line">  height: 60px;</span><br><span class="line">  font-size: $font-size-normal;</span><br><span class="line">  background-color: $bg-color;</span><br><span class="line">  @include box-shadow;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>获取Dom元素</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/%E8%8E%B7%E5%8F%96Dom%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="获取Dom元素"><a href="#获取Dom元素" class="headerlink" title="获取Dom元素"></a>获取Dom元素</h1><p>给Dom元素或组件设置ref属性</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;audio ref=<span class="string">&quot;audio1&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;@/audios/where_do_i_start.mp3&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Page2</span> <span class="attr">ref</span>=<span class="string">&quot;page2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Page2</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>通过引入ref获取对应元素</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> audio1 = ref(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//变量名要与元素指定的ref的值相同</span></span><br></pre></td></tr></table></figure>

<p>通过<code>audio1.value</code>获取dom元素，获取组件的dom元素要通过<code>page2.value.**$el**</code></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>组件事件</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h1><p>在子组件的模板字符串中，可以直接使用$emit触发自定义事件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;$emit(&#x27;someEvent&#x27;)&quot;</span>&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>在父组件中通过v-on(简写为@)来监听事件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent @someEvent=<span class="string">&quot;callback&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>


<p>💡 在js中触发事件提交使用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">const</span> emit = defineEmits([<span class="string">&#x27;inFocus&#x27;</span>, <span class="string">&#x27;submit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buttonClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  emit(<span class="string">&#x27;submit&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>如雪如山</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/%E6%88%91%E7%9A%84%E4%B9%A6%E5%BA%93/%E5%A6%82%E9%9B%AA%E5%A6%82%E5%B1%B1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如雪如山"><a href="#如雪如山" class="headerlink" title="如雪如山"></a>如雪如山</h1><p>ISBN: 9787020166930<br>丛书: 无<br>作者: 张天翼<br>册数: 1<br>出品方: 无<br>出版日: 2022/04/01<br>出版日期: 2022-4-1<br>出版社: 人民文学出版社<br>创建时间: January 30, 2023 9:57 PM<br>定价: 58<br>封面: <a href="https://img2.doubanio.com/view/subject/s/public/s34201041.jpg">https://img2.doubanio.com/view/subject/s/public/s34201041.jpg</a><br>时间: 2023/01/30<br>标签: 中国, 中国文学, 女性, 小说, 张天翼, 文学, 短篇, 短篇小说<br>装帧: 精装<br>豆瓣: <a href="https://book.douban.com/subject/35875393/">https://book.douban.com/subject/35875393/</a><br>阅读状态: 闲置<br>页数: 347</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>我的书库</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle 索引</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Database/Oracle/Oracle%20%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle-索引"><a href="#Oracle-索引" class="headerlink" title="Oracle 索引"></a>Oracle 索引</h1><blockquote>
<p>1、 索引介绍 索引是用于加速数据存取的数据对象，是对数据表中一个或多个列进行排序的结构。</p>
</blockquote>
<p>摘要：</p>
<p>合理使用索引可以大大减少 I/O 数量，从而提高数据访问性能。在表名上创建索引索引名称（列名 1，列名 2，…ALTERINDEX 索引名称 COALESCEallocateunused；注意：如果未添加 deallocateuused，合并后仍将保留更多空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、  索引介绍</span><br><span class="line">索引是用于加速数据存取的数据对象，是对数据表中一个或多个列进行排序的结构。</span><br><span class="line"></span><br><span class="line">合理的使用索引能够大大减少I/O次数，从而提高数据訪问性能。</span><br><span class="line">2、  问题：为什么须要索引？</span><br><span class="line">Select * from scott.emp where empno=’8379’   --遍历emp表？</span><br><span class="line">制约程序规模增大的两个瓶颈：网络和数据库，须要用更好的方式组织、管理数据。</span><br><span class="line"></span><br><span class="line">3、  索引分类</span><br><span class="line">   按索引列个数</span><br><span class="line">(1) 单列索引</span><br><span class="line">基于单个列所建立的索引，定义格式例如以下：</span><br><span class="line">Create index索引名on表名(列名);</span><br><span class="line">(2) 复合索引</span><br><span class="line">基于两列或是多列的索引。在同一张表上能够有多个索引，可是要求列的组合必须不同。</span><br><span class="line">Create index 索引名 on 表名(列名1, 列名2,…… ) ;</span><br><span class="line">   按索引列的唯一性</span><br><span class="line">(1) 唯一索引</span><br><span class="line">索引列上的取值唯一。</span><br><span class="line">Create unique index索引名on表名(列名1, 列名2,…… ) ;</span><br><span class="line">(2) 非唯一索引</span><br><span class="line">   索引列上的取值不唯一。</span><br><span class="line">Create index索引名on表名(列名1, 列名2,…… ) ;</span><br><span class="line">   按索引数据的存储方式</span><br><span class="line">(1) B*树索引</span><br><span class="line">   特点：全部的叶子节点都在同一层，也就是不管查找哪一条数据。须要运行的I/O数据是一样的。适合进行区间扫描。</span><br><span class="line"></span><br><span class="line">   定义语法：</span><br><span class="line">CREATE [UNIQUE] INDEX [方案名.]索引名 ON  [方案名.]表名</span><br><span class="line">     (列名1[ASC|DESC] [,列名2[ASC|DESC]] …)</span><br><span class="line">[TABLESPACE 表空间名]</span><br><span class="line">     [PCTFREE]</span><br><span class="line">     [INITRANS]</span><br><span class="line">     [MAXTRANS]</span><br><span class="line">     [STORAGE CLAUSE]</span><br><span class="line">     [LOGGING|NOLOGGING]</span><br><span class="line">(2) 位图索引</span><br><span class="line">   特点：对索引列有少数不同值的大表，特别适合用位图索引，因为位图索引的更新代价更大，所以适合非常少更新键值的表。</span><br><span class="line">   定义语法：</span><br><span class="line">CREATE BITMAP INDEX [方案名.]索引名 ON  [方案名.]表名</span><br><span class="line">     (列名1[ASC|DESC] [,列名2[ASC|DESC]] …)</span><br><span class="line">[TABLESPACE 表空间名]</span><br><span class="line">     [PCTFREE]</span><br><span class="line">     [INITRANS]</span><br><span class="line">     [MAXTRANS]</span><br><span class="line">     [STORAGE CLAUSE]</span><br><span class="line">     [LOGGING|NOLOGGING]</span><br><span class="line">(3) 逆向索引</span><br><span class="line">   特点：适合建在递增或递减的列上，从而减少批量插入数据时造成的索引块竞争。可是无法进行区间扫描。</span><br><span class="line">   定义语法：</span><br><span class="line">CREATE [UNIQUE] INDEX [方案名.]索引名 ON  [方案名.]表名</span><br><span class="line">     (列名[ASC|DESC]) reverse</span><br><span class="line">[TABLESPACE 表空间名]</span><br><span class="line">     [PCTFREE]</span><br><span class="line">     [INITRANS]</span><br><span class="line">     [MAXTRANS]</span><br><span class="line">     [STORAGE CLAUSE]</span><br><span class="line">     [LOGGING|NOLOGGING]</span><br><span class="line">(4) 函数索引</span><br><span class="line">   特点：适合于查询对表中字段的引用中使用了函数的情况。</span><br><span class="line">   举例：Select * from scott.emp where upper(ename) = &#x27;SMITH&#x27;;</span><br><span class="line">4、  索引的使用原则</span><br><span class="line">(1) 在大表上建立索引才有意义</span><br><span class="line">(2) 在where子句或是连接条件上常常引用的列上建立索引</span><br><span class="line">5、  索引缺点分析</span><br><span class="line">(1) 建立索引，系统要占用大约为表的1.2倍的硬盘和内存空间来保存索引。</span><br><span class="line"></span><br><span class="line">(2) 更新数据的时候，系统必须要有额外的时间同一时候对索引进行更新，以维持数据和索引的一致性。</span><br><span class="line"></span><br><span class="line">6、  合并与重建索引</span><br><span class="line">随着对表的不断更新，表中的索引会产生越来越多的存储碎片，要对碎片进行整理有两种方式：重建索引或合并索引。</span><br><span class="line">   合并索引：将B树索引中的叶节点存储碎片进行合并。</span><br><span class="line">ALTER INDEX 索引名 COALESCE deallocate unused;</span><br><span class="line">注：不加deallocate unused则合并后仍保留多于的空间。</span><br><span class="line"></span><br><span class="line">   重建索引：即进行又一次建立，并且能够改动之前的各种參数；可将索引移入另外的表空间。因为重建的过程中移除了逻辑删除的索引。能够提高空间利用率。</span><br><span class="line">    ALTER INDEX索引名REBUILD 又一次配置參数;</span><br><span class="line">注：在改变属性时还能够改动REVERSE參数，改为反向，或反向改为正向。</span><br><span class="line"></span><br><span class="line">7、  删除索引</span><br><span class="line">   作用</span><br><span class="line">(1)  不再须要的索引；</span><br><span class="line">(2)  通过一段时间观察。发现非常少使用该索引；</span><br><span class="line">(3)  该索引无效，必须在重建之前删除。</span><br><span class="line">(4)  该索引包括过多存储碎片，须要在重建之前删除该索引；</span><br><span class="line">(5) 索引没有提供所期望的性能改善。</span><br><span class="line">(6) 在批量加载数据之前，先删除索引然后重建。</span><br><span class="line">   语法：</span><br><span class="line">DROP INDEX 方案名.索引名;</span><br><span class="line">8、  案例</span><br><span class="line">--运行系统提前定义的存储过程来创建PLAN_TABLE表</span><br><span class="line">SQL&gt;@ F:appAdministratorproduct11.2.0dbhome_1RDBMSADMINutlxplan.sql</span><br><span class="line">SQL&gt; grant all on plan_table to public;</span><br><span class="line">--运行系统提前定义的存储过程来创建角色plustrace并赋予查询动态性能视图的权限</span><br><span class="line">SQL&gt;@F:appAdministratorproduct11.2.0dbhome_1sqlplusadminplustrce.sql</span><br><span class="line">SQL&gt;set autotrace on exp</span><br><span class="line">SQL&gt;create table student</span><br><span class="line">(</span><br><span class="line">Sno char(9) primary key,</span><br><span class="line">Sname char(20) unique,</span><br><span class="line">Ssex char(2),</span><br><span class="line">Sage smallint,</span><br><span class="line">Sdept char(20)</span><br><span class="line">);</span><br><span class="line">SQL&gt; insert into student values(&#x27;201010121&#x27;, &#x27;李勇&#x27;, &#x27;男&#x27;,20, &#x27;IS&#x27;);</span><br><span class="line">SQL&gt;insert into student values(&#x27;201010122&#x27;, &#x27;刘晨&#x27;, &#x27;男&#x27;,19, &#x27;IS&#x27;);</span><br><span class="line">SQL&gt;insert into student values(&#x27;201010123&#x27;, &#x27;张力&#x27;, &#x27;男&#x27;,20, &#x27;MA&#x27;);</span><br><span class="line">SQL&gt;insert into student values(&#x27;201010124&#x27;, &#x27;李颖&#x27;, &#x27;女&#x27;,20, &#x27;IS&#x27;);</span><br><span class="line">--对照以下三条查询语句的运行计划。观察TABLE ACCESS上的差别</span><br><span class="line">SQL&gt;select * from student where sno=&#x27;201010122&#x27;;</span><br><span class="line">SQL&gt;select * from student where sname=&#x27;刘晨&#x27;;</span><br><span class="line">SQL&gt;select * from student where sage=19;</span><br><span class="line">SQL&gt;set autotrace off</span><br><span class="line">--查询STUDENT表上的索引信息，如今有两个索引</span><br><span class="line">SQL&gt;select index_name, index_type, table_name, uniqueness from user_indexes where table_name=&#x27;STUDENT&#x27;;</span><br><span class="line">--如果index_name各自是SYS_C0011054和SYS_C0011053</span><br><span class="line">--以下进行B*树索引监控</span><br><span class="line">SQL&gt;alter index SYS_C0011054 MONITORING USAGE;</span><br><span class="line">--SYS_C0011054为student表上一个索引的index_name</span><br><span class="line">SQL&gt;select * from student where sno=&#x27;201010122&#x27;;</span><br><span class="line">SQL&gt;select * from student where sname=&#x27;刘晨&#x27;;</span><br><span class="line">SQL&gt;select * from v$object_usage;</span><br><span class="line">--创建位图索引</span><br><span class="line">SQL&gt;create bitmap index bidx_sex on student(ssex);</span><br><span class="line">--以下进行位图索引监控</span><br><span class="line">SQL&gt;alter index bidx_sex MONITORING USAGE;</span><br><span class="line">SQL&gt;select * from student where ssex =&#x27;男&#x27;;</span><br><span class="line">SQL&gt;select * from v$object_usage;</span><br><span class="line">说明：关闭索引监控需运行语句为</span><br><span class="line">SQL&gt;alter index SYS_C0011054 NOMONITORING USAGE;</span><br><span class="line">当中，SYS_C0011054为待关闭监控的索引名。</span><br><span class="line"></span><br><span class="line">9、  显示索引列</span><br><span class="line">创建索引时，须要提供相应的表列。通过查询数据字典dba_ind_columns能够显示全部的索引的表列信息。通过查询数据字典all_ind_columns能够显示当前用户可訪问的全部的索引表列信息。通过查询数据字典user_ind_columns能够显示当前用户索引的表列信息。</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">SQL&gt; Select column_name, column_length from user_ind_columns where index_name=&#x27;BIDX_SEX&#x27;;</span><br><span class="line">10、显示索引段位置及大小</span><br><span class="line">建立索引时。oracle会为索引分配相应的索引字段，索引数据被存放在索引段中。并且段名与索引名全然相同。比如：</span><br><span class="line">SQL&gt; Select tablespace_name, segment_type, bytes from user_segments where segment_name=&#x27;BIDX_SEX&#x27;;</span><br><span class="line">11、显示函数索引</span><br><span class="line">建立函数索引时，oracle会将函数索引的信息存放到数据字典中。通过查询数据字典dba_ind_expressions能够显示数据库全部函数索引所相应的函数或表达式。</span><br><span class="line"></span><br><span class="line">通过查询数据字典user_ind_expressions能够显示当前用户函数索引所相应的函数或表达式。</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">SQL&gt; Create index fun_ind_sdept on student(upper(Sdept));</span><br><span class="line">SQL&gt; Select column_expression from user_ind_expressions where index_name=&#x27;FUN_IND_SDEPT&#x27;;</span><br><span class="line">12、索引使用的限制情况</span><br><span class="line">(1) 使用不等于操作符（&lt;&gt;、!=）</span><br><span class="line">以下的查询即使在sno列有一个索引，查询语句仍然运行一次全表扫描。</span><br><span class="line">SQL&gt;  select * from student where sno&lt;&gt;&#x27;1&#x27;;</span><br><span class="line">把上面的语句改成例如以下的查询语句。在採用基于规则的优化器而不是基于代价的优化器时，将会使用索引。</span><br><span class="line">SQL&gt;  select * from student where sno &lt; &#x27;1&#x27; or sno &gt; &#x27;1&#x27;;</span><br><span class="line">注：通过把不等于操作符改成OR条件。就能够使用索引。以避免全表扫描。</span><br><span class="line">(2) 使用IS NULL 或IS NOT NULL</span><br><span class="line">使用IS NULL 或IS NOT NULL相同会限制索引的使用。因为NULL值并没有被定义。 在SQL语句中使用NULL会有非常多的麻烦。</span><br><span class="line"></span><br><span class="line">因此建议开发者在建表时，把须要索引的列设成NOT NULL。 如果被索引的列在某些行中存在NULL值，就不会使用这个索引，除非索引是一个位图索引。</span><br><span class="line">(3) 比較不匹配的数据类型</span><br><span class="line">比較不匹配的数据类型也是比較难于发现的性能问题之中的一个。</span><br><span class="line">注意以下查询的样例。sno是一个CHAR类型，在sno字段上有索引。以下的语句将运行全表扫描。</span><br><span class="line"></span><br><span class="line">SQL&gt;  select * from student where sno=1;</span><br><span class="line">Oracle能够自己主动把where子句变成to_number(sno)=1，这样就限制了索引的使用,改成以下的查询就能够使用索引：</span><br><span class="line">       SQL&gt;  select * from student where sno=&#x27;1&#x27;;</span><br><span class="line">(4) 当使系统数据字典或视图</span><br><span class="line">系统的数据字典表都未被分析过。可能导致极差的“运行计划”。</span><br><span class="line"></span><br><span class="line">可是不要擅自对数据字典表做分析，否则可能导致死锁。或系统性能下降。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本文由简悦 SimpRead 转码</p>
</blockquote>
<p>合理使用索引可以大大减少 I/O 数量，从而提高数据访问性能，Oracle提供了多种索引类型，如单列索引、复合索引、唯一索引、非唯一索引、B*树索引、位图索引、逆向索引和函数索引，以满足不同的数据访问需求。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Database</category>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title>IndexedDB</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Database/IndexedDB/IndexedDB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h1><p>Created by: Siyu Long<br>Created time: January 28, 2023 2:47 PM<br>Last edited by: Siyu Long<br>Last edited time: February 2, 2023 9:15 PM</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p>
<p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>
<h3 id="IndexedDB-具有以下特点："><a href="#IndexedDB-具有以下特点：" class="headerlink" title="IndexedDB 具有以下特点："></a>IndexedDB 具有以下特点：</h3><p><strong>（1）键值对储存。</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<p><strong>（2）异步。</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p><strong>（3）支持事务。</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p><strong>（4）同源限制</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p><strong>（5）储存空间大</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
<p><strong>（6）支持二进制储存。</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
<aside>
💡 IndexedDB 是浏览器提供的本地数据库，允许储存大量数据，提供查找接口，可以建立索引，是非关系型数据库（NoSQL）。它采用键值对储存，操作异步，支持事务，受同源限制，储存空间大，支持二进制储存

</aside>

<p>[[notion/学习/Database/Oracle/All articles]]</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Database</category>
        <category>IndexedDB</category>
      </categories>
  </entry>
  <entry>
    <title>1-什么是经济学</title>
    <url>/2023/07/29/notion/%E5%AD%A6%E4%B9%A0/Lessons/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-什么是经济学"><a href="#1-什么是经济学" class="headerlink" title="1-什么是经济学"></a>1-什么是经济学</h1><p>Created: January 26, 2023 11:51 PM<br><a href="http://player.bilibili.com/player.html?aid=62120450&bvid=BV1gt411g7RU&cid=107964696&page=1">http://player.bilibili.com/player.html?aid=62120450&amp;bvid=BV1gt411g7RU&amp;cid=107964696&amp;page=1</a></p>
<h1 id="经济学的三类问题"><a href="#经济学的三类问题" class="headerlink" title="经济学的三类问题"></a>经济学的三类问题</h1><ol>
<li>人们如何做出决策？- how people make decision?</li>
<li>人们如何相互作用？- how people interact?</li>
<li>整体经济如何运行？- how the economy as a whole works?</li>
</ol>
<h1 id="经济学10个原理-人们如何做出决策"><a href="#经济学10个原理-人们如何做出决策" class="headerlink" title="经济学10个原理-人们如何做出决策"></a>经济学10个原理-人们如何做出决策</h1><ol>
<li><p>人们面临得失交换、</p>
</li>
<li><p>某物的成本是为此所放弃的东西</p>
</li>
<li><p>理性人思考边际量</p>
</li>
<li><p>人们会对激励做出反应</p>
<hr>
</li>
<li><p>贸易能使人人受益</p>
</li>
<li><p>市场通常是组织经济活动的好方式</p>
</li>
<li><p>政府有时可以改进市场结果</p>
<hr>
</li>
<li><p>一国的生活水平取决于他的生产</p>
</li>
<li><p>当政府发行了过多的货币时物价上涨</p>
</li>
<li><p>社会面临通货膨胀和失业之间的短期得失交换</p>
</li>
</ol>
<blockquote>
<p>个人决策</p>
</blockquote>
<blockquote>
<p>个人和个人之间，企业和企业之间，企业和个人之间，国家和国家之间相互的作用</p>
</blockquote>
<blockquote>
<p>经济作为一个整体</p>
</blockquote>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Lessons</category>
        <category>清华大学-经济学原理</category>
      </categories>
  </entry>
  <entry>
    <title>Class</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/Class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>ES6 类可以通过使用 <code>class</code> 关键字来创建更清晰的语法结构，以及构造函数、静态方法和 getter 和 setter 等其他功能。使用 <code>class</code> 关键字可以让开发人员创建更有组织性且易于维护的对象，并且还可以享受内置优化带来的更好的性能。</p>
<p>使用 <code>class</code> 关键字可以更加优雅而简洁的定义类和类的方法，以及创建实例化的对象。首先，需要定义一个类，然后再在类中定义构造函数和其他方法，像执行类方法，定义静态方法，定义 getter 和 setter 等。接下来，你可以使用 <code>new</code> 关键字来实例化类，并调用它们的方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  static staticMethod() &#123;</span><br><span class="line">    // do something</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myClass = new MyClass(&#x27;MyClass&#x27;);</span><br><span class="line">let myName = myClass.getName();</span><br><span class="line">MyClass.staticMethod();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如，你可以使用 <code>class</code> 关键字为类和方法创建简单的抽象，用于实例化对象。下面是一个<strong>示例</strong>，演示了如何使用 <code>class</code> 关键字来定义一个类，添加构造函数、静态方法、getter 和 setter 等：</p>
<h1 id="Class-知识点"><a href="#Class-知识点" class="headerlink" title="Class 知识点"></a>Class 知识点</h1><p>类是一种特殊的函数，可用于创建对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyExampleClass &#123;</span><br><span class="line">  constructor(exampleName) &#123;</span><br><span class="line">    this.exampleName = exampleName;</span><br><span class="line">  &#125;</span><br><span class="line">  getExampleName() &#123;</span><br><span class="line">    return this.exampleName;</span><br><span class="line">  &#125;</span><br><span class="line">  static staticExampleMethod() &#123;</span><br><span class="line">    // do something</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类创建实例，并调用它们的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myExampleClass = new MyExampleClass(&#x27;MyExampleClass&#x27;);</span><br><span class="line">let myExampleName = myExampleClass.getExampleName();</span><br><span class="line">MyExampleClass.staticExampleMethod();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>💡</p>
<ol>
<li><p>每个函数都有prototype这个属性，指向一个对象，即该函数的原型</p>
</li>
<li><p>每个构造函数的实例都有proto这个属性，这个属性指向构造函数函数的prototype</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">A构造方法的prototype就是<span class="built_in">Object</span></span><br><span class="line">a实例的proto就是也是<span class="built_in">Object</span></span><br><span class="line">换种说法就是类的prototype代表的就是类的实例的原型</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://raw.githubusercontent.com/lsy1998/pics/main/202307250954084.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Generator</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/Generator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p><code>Generator</code> 函数是 ES6 提供的一种<code>异步编程</code>解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个<code>状态机</code>，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的<code>遍历器对象</code>，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，<code>Generator</code>函数是一个<code>普通函数</code>，但是有两个特征。一是， function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（ yield 在英语里的意思就是“<strong>产出</strong>”）。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<p><strong>第一次调用</strong>，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。 next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello ， done 属性的值 false ，表示遍历还没有结束。</p>
<p><strong>第二次调用</strong>，Generator 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式。 next 方法返回的对象的 value 属性就是当前 yield 表达式的值 world ， done 属性的值 false ，表示遍历还没有结束。</p>
<p><strong>第三次调用</strong>，Generator 函数从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。 next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined ）， done 属性的值 true ，表示遍历已经结束。</p>
<p><strong>第四次调用</strong>，此时 Generator 函数已经运行完毕， next 方法返回对象的 value 属性为 undefined ， done 属性为 true 。以后再调用 next 方法，返回的都是这个值。</p>
<p><strong>总结一下</strong>，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值； done 属性是一个布尔值，表示是否遍历结束。</p>
<p>Generator 函数可以不用 yield 表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;执行了！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> generator = f();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	generator.next()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<strong>函数 f 如果是普通函数，在为变量 generator 赋值时就会执行。但是，函数 f 是一个 Generator 函数，就变成只有调用 next 方法时，函数 f 才会执行</strong>。</p>
<p>看一个例子。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二次运行 next 方法的时候不带参数，导致 y 的值等于 2 * undefined （即 NaN ），除以 3 以后还是 NaN ，因此返回对象的 value 属性也等于 NaN 。第三次运行 Next 方法的时候不带参数，所以 z 等于 undefined ，返回对象的 value 属性等于 5 + NaN + undefined ，即 NaN 。</p>
<p>如果向 next 方法提供参数，返回结果就完全不一样了。上面代码第一次调用 b 的 next 方法时，返回 x+1 的值 6 ；第二次调用 next 方法，将上一次 yield 表达式的值设为 12 ，因此 y 等于 24 ，返回 y / 3 的值 8 ；第三次调用 next 方法，将上一次 yield 表达式的值设为 13 ，因此 z 等于 13 ，这时 x 等于 5 ， y 等于 24 ，所以 return 语句的值等于 42 。</p>
<p>注意，由于 next 方法的参数表示上一个 yield 表达式的返回值，所以在第一次使用 next 方法时，传递参数是无效的。V8 引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Symbol</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/Symbol/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p><code>ES5</code>的对象属性名都是<code>字符串</code>，这容易造成<code>属性名</code>的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，<strong>这样就从根本上防止属性名的冲突</strong>。这就是 ES6 引入 Symbol 的原因。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Javascript/ES6/Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p><code>[Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)</code>是一个对象，它代表了一个异步操作的最终完成或者失败。</p>
<p>在过去，要想做多重的异步操作，会导致经典的回调地狱：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(result, <span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">    doThirdThing(newResult, <span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br><span class="line">Copy to Clipboard</span><br></pre></td></tr></table></figure>

<p>现在，我们可以把回调绑定到返回的 Promise 上，形成一个 Promise 链：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doThirdThing(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race()</a> 是并行运行异步操作的两个组合式工具。</p>
<p>我们可以发起并行操作，然后等多个操作全部结束后进行下一步操作，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([func1(), func2(), func3()])</span><br><span class="line">.then(<span class="function">(<span class="params">[result1, result2, result3]</span>) =&gt;</span> &#123; <span class="comment">/* use result1, result2 and result3 */</span> &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Javascript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>乐理学习</title>
    <url>/2023/07/29/notion/%E5%AD%A6%E4%B9%A0/Long-term%20Target/Piano%20Learning/%E4%B9%90%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="乐理学习"><a href="#乐理学习" class="headerlink" title="乐理学习"></a>乐理学习</h1><p>高音谱号在五线谱上的四间分别是FACE(face脸)。</p>
<p>高音谱号在五线谱上的五线分别是EGBDF(every good boys deserve fudge)。</p>
<p>低音谱号在五线谱上的四间分别是ACEG(all cows eat grass)。</p>
<p>高音谱号在五线谱上的五线分别是GBDFA(green birds dont fly away)。</p>
<p>上加三间和下加三线都是ACE(啦哆咪)。</p>
<p>音程学习是为了更快读谱</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Long-term Target</category>
        <category>Piano Learning</category>
      </categories>
  </entry>
  <entry>
    <title>跨盘cd</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Python/Anaconda/%E8%B7%A8%E7%9B%98cd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="跨盘cd"><a href="#跨盘cd" class="headerlink" title="跨盘cd"></a>跨盘cd</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">cd **<span class="regexp">/d** xx/</span>xxx/xx</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Python</category>
        <category>Anaconda</category>
      </categories>
  </entry>
  <entry>
    <title>OpenCV</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Python/OpenCV/OpenCV/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h1 id="什么是opencv"><a href="#什么是opencv" class="headerlink" title="什么是opencv?"></a>什么是opencv?</h1><p>OpenCV（Open Source Computer Vision）是一个开源的计算机视觉库，它可以为各种应用提供实时图像处理功能，从而在许多方面改善了我们的生活。它提供了一些有用的功能，包括图像构建、边缘检测、形态学操作、目标检测、图像分类和跟踪等功能。此外，它还可以用来检测和识别图像中的物体，以及处理视频和图像流，从而达到实时监控的目的。通过使用OpenCV，可以轻松访问各种算法，从而提高应用的效率和性能。</p>
<p>[[all about opencv]]</p>
<p>OpenCV可以通过官方网站（<a href="https://opencv.org/%EF%BC%89%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8GitHub%E4%B8%8A%E4%B8%8B%E8%BD%BD%EF%BC%88https://github.com/opencv/opencv%EF%BC%89%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E4%BD%BF%E7%94%A8OpenCV%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BB%8ECocoaPods%E3%80%81Homebrew%E6%88%96Python%E7%9A%84pip%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B8%AD%E5%AE%89%E8%A3%85%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E5%BC%80%E5%8F%91%E8%80%85%E6%9B%B4%E8%BD%BB%E6%9D%BE%E5%9C%B0%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%A1%E7%90%86OpenCV%E3%80%82">https://opencv.org/）下载，也可以在GitHub上下载（https://github.com/opencv/opencv）。另外，使用OpenCV还可以从CocoaPods、Homebrew或Python的pip包管理器中安装，它们可以帮助开发者更轻松地安装和管理OpenCV。</a></p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Python</category>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Python 和 OpenCV 读取图片</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Python/OpenCV/%E4%BD%BF%E7%94%A8%20Python%20%E5%92%8C%20OpenCV%20%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用-Python-和-OpenCV-读取图片"><a href="#使用-Python-和-OpenCV-读取图片" class="headerlink" title="使用 Python 和 OpenCV 读取图片"></a>使用 Python 和 OpenCV 读取图片</h1><p>import cv2</p>
<h1 id="首先，我们需要调用-OpenCV-的函数，以便从文件系统中读取图像，我们可以指定文件的路径，以及文件名称"><a href="#首先，我们需要调用-OpenCV-的函数，以便从文件系统中读取图像，我们可以指定文件的路径，以及文件名称" class="headerlink" title="首先，我们需要调用 OpenCV 的函数，以便从文件系统中读取图像，我们可以指定文件的路径，以及文件名称"></a>首先，我们需要调用 OpenCV 的函数，以便从文件系统中读取图像，我们可以指定文件的路径，以及文件名称</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;[filename]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="如果图像被正确读取，则返回一个值，表示图像已经被正确读取，但如果出现异常，则返回一个空值"><a href="#如果图像被正确读取，则返回一个值，表示图像已经被正确读取，但如果出现异常，则返回一个空值" class="headerlink" title="如果图像被正确读取，则返回一个值，表示图像已经被正确读取，但如果出现异常，则返回一个空值"></a>如果图像被正确读取，则返回一个值，表示图像已经被正确读取，但如果出现异常，则返回一个空值</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> img is not None:</span><br><span class="line"># 如果图像被正确读取，则我们可以对图像进行更多的处理，例如缩放，调整大小，旋转等操作，以达到我们想要的效果</span><br><span class="line"># 另外，我们还可以在图像上绘制形状或者文字，以便增强图像的表现力</span><br><span class="line"># 同时，我们也可以使用 OpenCV 提供的函数处理图像，例如使用颜色空间转换，滤波器，图像金字塔等功能，以达到更好的效果</span><br><span class="line"><span class="attr">else</span>:</span><br><span class="line">print(<span class="string">&quot;Error loading image&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Python</category>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>安装Python OpenCV</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Python/OpenCV/%E5%AE%89%E8%A3%85Python%20OpenCV/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装Python-OpenCV"><a href="#安装Python-OpenCV" class="headerlink" title="安装Python OpenCV"></a>安装Python OpenCV</h1><p>本文提供了关于如何安装Python OpenCV的指南。OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉库，可以在Python中使用它来处理图像和视频，提供了一组算法，可以用来检测和识别图像中的物体，分析图像，以及进行图像和视频处理。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>要安装Python OpenCV，首先需要安装Python和OpenCV，因此，在安装Python OpenCV之前，需要先准备Python和OpenCV的安装环境。</p>
<h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><p>要安装Python，首先需要下载并安装Python解释器。有几种Python发行版可供选择，但是推荐使用<a href="https://www.anaconda.com/distribution/#download-section">Anaconda Python</a>，这是用于Python科学计算的最流行的发行版，它提供了许多内置库，可以有效地满足Python科学计算的要求。</p>
<h3 id="安装OpenCV"><a href="#安装OpenCV" class="headerlink" title="安装OpenCV"></a>安装OpenCV</h3><p>OpenCV可以通过<a href="https://anaconda.org/anaconda/opencv">Anaconda Cloud</a>从Anaconda Cloud获得。只需打开终端（在Linux和macOS中）或命令提示符（在Windows中），然后输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c anaconda opencv</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装OpenCV后，可以在Python环境中使用OpenCV的功能，例如图像处理、视频处理、图像分析等。</p>
<h2 id="安装Python-OpenCV-1"><a href="#安装Python-OpenCV-1" class="headerlink" title="安装Python OpenCV"></a>安装Python OpenCV</h2><p>安装OpenCV后，可以使用pip安装Python OpenCV包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装完成后，可以在Python程序中导入OpenCV：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>导入OpenCV后，就可以在Python程序中使用OpenCV的功能，例如图像处理、视频处理、图像分析、物体检测等。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文介绍了如何安装Python OpenCV。首先，需要准备Python和OpenCV的安装环境，然后安装Python和OpenCV，最后，使用pip安装Python OpenCV包，安装完成后，可以在Python程序中导入OpenCV，从而在Python程序中使用OpenCV的功能，实现计算机视觉的应用。</p>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Python</category>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>基础用法</title>
    <url>/2023/07/04/notion/%E5%AD%A6%E4%B9%A0/Vue/Pinia/%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h1><ol>
<li><p>state的访问</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">引入并实例化</span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useStore <span class="keyword">from</span> <span class="string">&#x27;XXX/xx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = useStore()</span><br><span class="line"><span class="keyword">const</span> &#123; linkList &#125; = storeToRefs(store) <span class="comment">//解析成响应式数据</span></span><br></pre></td></tr></table></figure></li>
<li><p>state的重置</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useStore()</span><br><span class="line"></span><br><span class="line">store.$reset()</span><br></pre></td></tr></table></figure></li>
<li><p>state的订阅（监听）</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在patch 后只触发一次</span></span><br><span class="line">store.$subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  linkListData.value = toRaw(state).linkList</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//toRaw()用来获取proxy的数据</span></span><br></pre></td></tr></table></figure></li>
<li><p>state的更新</p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">store.$patch(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  state.linkList.push(data[i]) <span class="comment">//操作对应数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>notion</category>
        <category>学习</category>
        <category>Vue</category>
        <category>Pinia</category>
      </categories>
  </entry>
</search>
